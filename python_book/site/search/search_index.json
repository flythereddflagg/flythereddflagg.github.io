{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"The Redd Python Book By Mark Redd The Redd Python Book by Mark Edward Redd is licensed under a Creative Commons Attribution 4.0 International License . All code examples and source code files are licensed under the MIT License . Project is in pre-alpha The Redd Python Book is a book I am writing to make a free resource to learn python for those unfamiliar with programming. As such, if you are already familiar with programming and want to learn python this may not be the best fit for you. Eventually, I want to produce PDF and HTML versions of this book but right now markdown is my preferred format for writing. Input and contributions welcome! Go to the Table of Contents to start reading!","title":"Home"},{"location":"#the-redd-python-book","text":"By Mark Redd The Redd Python Book by Mark Edward Redd is licensed under a Creative Commons Attribution 4.0 International License . All code examples and source code files are licensed under the MIT License . Project is in pre-alpha The Redd Python Book is a book I am writing to make a free resource to learn python for those unfamiliar with programming. As such, if you are already familiar with programming and want to learn python this may not be the best fit for you. Eventually, I want to produce PDF and HTML versions of this book but right now markdown is my preferred format for writing. Input and contributions welcome! Go to the Table of Contents to start reading!","title":"The Redd Python Book"},{"location":"00-Table-of-Contents/","text":"Table of Contents Intro and How to Use This Book Getting Started CLI Hello World Comments Strings and the Print Function Escape Characters Formatted Strings Variables and Memory Better String Formatting Input and Output Math and Data Logic and Boolean Operators If elif and else Errors Exceptions and Bugs File Reading and Writing Loops Iterables Dictionaries Functions More Functions Try Except Imports Reading Code Do a Project Objects and Classes Inheritance and Polymorphism Modules Comments and Code Documentation Packages and Project Structure","title":"Table of Contents"},{"location":"00-Table-of-Contents/#table-of-contents","text":"Intro and How to Use This Book Getting Started CLI Hello World Comments Strings and the Print Function Escape Characters Formatted Strings Variables and Memory Better String Formatting Input and Output Math and Data Logic and Boolean Operators If elif and else Errors Exceptions and Bugs File Reading and Writing Loops Iterables Dictionaries Functions More Functions Try Except Imports Reading Code Do a Project Objects and Classes Inheritance and Polymorphism Modules Comments and Code Documentation Packages and Project Structure","title":"Table of Contents"},{"location":"01-Intro-and-How-to-Use-This-Book/","text":"Previous: 00-Table of Contents | Table of Contents | Next: 02-Getting Started 1 - Introduction and How to Use this Book Python changed my life. Before learning Python, computers scared me. Python opened up to me a world of programming that made computers into useful tools instead of necessary evils. Regardless of the reason you are reading this book right now, I hope that Python will have a similar impact on you. I am writing this book to introduce Python to newcomers to programming. If you are an experienced programmer and are looking to add Python to your repertoire, this may not be the book for you. The intent of this book is, primarily, to give a solid introduction to Python and (and some computer science) to those who are completely new to programming. To that end, I have the following goals in mind while writing this book: Make a free Python resource I want to make a resource that will be free (as in free beer and free speech) forever so that any student of Python may have access to these introductory materials. Python is a language that anyone can learn and learning Python should not be a skill that is forever behind a pay wall. Teach to the \"Zen of Python\" The \" Zen of Python \" will be covered at some point in this book. It is a list of 20 principles that embody the design of Python written in poetic fashion. These principles are so powerful that I will continually try to use them in every lesson where applicable. Teach fundamentals about the computer and what is happening This is an aspect of teaching programming that is lost in many cases that I have been able to observe. In my experience if one understands what is happening on a fundamental level in the computer, two benefits arise. First, the code design, implementation and improvement will be faster and can help you know how to tackle difficult problems. Secondly, debugging your code will be less of a recursive refactoring black hole and more of a intuitive wave that you can surf into the sunset. Get as much as you want out of the learning experience I continually strive to structure this book such that, after learning a particular skill or aspect of the language, you can move on or go deeper if desired. This is part of the philosophy of learning at your own pace and will hopefully facilitate the depth of your learning. Also, this allows you to pursue your specific interests and flesh out your skill set in a way that benefits you the most. Introducing as many branches and directions as possible for programming Many introduction books on programming are content with covering the basics that are common to all programmers but then do not take you any further. In this book, I intend to point you to as many good resources as possible for as many branches of programming as I can. I will not recommend a resource unless I have used it myself and found it to be useful. There are, however, a few branches of programming for which I have not been able to find any good learning resources. Where this is the case, included are introductions to certain frameworks such as Tkinter and Pygame. Get you writing code as fast as possible I have always learned best by doing. I feel that for programming this is the best approach to learning therefore I aim to get you coding and keep you coding as much as possible. Get you reasonably coding proficient within 20 hours instead of 10,000 hours I have heard it said that it takes 10,000 hours to become proficient at something. I, along with this guy , believe that is false. My best aim is to get you reasonably proficient at Python within 20 hours of coding. With that said, you may find that you reach your 20-hour mark and are not finished with the book in terms of learning the basics. That is okay. You may find that a reasonable amount of proficiency is possible in less than 20 hours. That is also okay. Learn at your own pace, but understand that 10,000 hours of coding is NOT required to gain amazing benefits from coding. Okay, that is my soap box on the principles of this book. I will do my best to be as succinct as possible from here on out. How to use this book Sections In each section of this book reading and exercises will be ordered by how mandatory they are. If you wish to move as quickly as possible, you may only do the first part of each section where I will cover the essential material. However, I do recommend doing all parts of every section to get the most out of this book as well as to hone your skills. The sections generally will be divided in to 3 subsections. Each of these sections has a distinct purpose. Depending on your level of skill and interest there are a number of ways of approaching each section. They are as follows: Reading and basic exercises This will be the main content of each section and is mandatory as you learn. It will include a relatively short introduction on the subject of each section and provide exercises intended to get you reasonably competent in a particular concept or skill. Once you have completed this subsection, you may move on to the next section with confidence that you have gotten the essential parts of the section. Hone Your Skills This subsection will include more challenging exercises designed to push you to find applications of the skill or concept in each section. If you feel weak on a particular topic, these sections provide a way to deepen your understanding and ensure you 'own' the concepts in each section. One of the most important skills you can learn is how to find answers for yourself. To that end, do not be surprised if some of the exercises ask you to go and research something yourself. Included in these subsections will be some extra information or directions to resources online and elsewhere that are intended to help you understand each concept more fully. Advanced Mastery These sections may not be attached to every section. However, I have added these subsections whenever I feel there are some deeper things to learn or some principles that will serve you as you master programming. These sections may involve concepts we have not covered yet as well so if you get to a point where you feel lost, just skip it and come back to it later. This book is intended to serve you and not the other way around. Therefore, I recommend you do the basics of each section. Beyond that, you are free to pursue what interests you and skip anything that doesn't. I am still playing with the layout of this text but a possible way to approach learning the material is to do the basics first and then add to your knowledge with the other two subsections. Boring Before Interesting In the 1984 film \" The Karate Kid \", Mr. Miyagi, the teacher, doesn't start training Daniel, the protagonist, in Karate by teaching him fancy moves but begins by having him perform many menial tasks with no apparent point to them. It is in doing these seemingly pointless tasks that Daniel first begins to have skill in Karate. You will find that anytime you want to learn a new skill you must do many boring and seemingly pointless things before you can do something interesting or useful. Every discipline has this feature. I am telling you this because for me, a person with a very limited attention span, the beginning of programming was agonizingly slow and seemingly pointless and you may feel that way too. However, if you will do some simple things in every section you will be well on your way to becoming a good programmer. The simple things you must do are the following: Read each section Type the corresponding code EXACTLY as it is written without copy-pasting it Make it run When things get boring or tedious, remember the Karate Kid. You are building a foundation on which you can move mountains. Learning to feed yourself I will sometimes have you read Official Python documentation or visit other websites or resources. I do this for a number of reasons but most importantly, I want you to be able to teach yourself everything this book cannot. It would be my goal that, after you have read and learned everything in this book, you can put it down and never pick it up again because you have learned how to find answers to your own questions. Doing this will make you that much more effective as a programmer and in everything you do. Remember: Whenever I tell you to search for something on the Internet, remember that the best way to use a search engine is to type \"Python\" and then write what you are looking for. This will be a boon to your learning as you go along. Previous: 00-Table of Contents | Table of Contents | Next: 02-Getting Started","title":"1. Intro and How to Use This Book"},{"location":"01-Intro-and-How-to-Use-This-Book/#1-introduction-and-how-to-use-this-book","text":"Python changed my life. Before learning Python, computers scared me. Python opened up to me a world of programming that made computers into useful tools instead of necessary evils. Regardless of the reason you are reading this book right now, I hope that Python will have a similar impact on you. I am writing this book to introduce Python to newcomers to programming. If you are an experienced programmer and are looking to add Python to your repertoire, this may not be the book for you. The intent of this book is, primarily, to give a solid introduction to Python and (and some computer science) to those who are completely new to programming. To that end, I have the following goals in mind while writing this book: Make a free Python resource I want to make a resource that will be free (as in free beer and free speech) forever so that any student of Python may have access to these introductory materials. Python is a language that anyone can learn and learning Python should not be a skill that is forever behind a pay wall. Teach to the \"Zen of Python\" The \" Zen of Python \" will be covered at some point in this book. It is a list of 20 principles that embody the design of Python written in poetic fashion. These principles are so powerful that I will continually try to use them in every lesson where applicable. Teach fundamentals about the computer and what is happening This is an aspect of teaching programming that is lost in many cases that I have been able to observe. In my experience if one understands what is happening on a fundamental level in the computer, two benefits arise. First, the code design, implementation and improvement will be faster and can help you know how to tackle difficult problems. Secondly, debugging your code will be less of a recursive refactoring black hole and more of a intuitive wave that you can surf into the sunset. Get as much as you want out of the learning experience I continually strive to structure this book such that, after learning a particular skill or aspect of the language, you can move on or go deeper if desired. This is part of the philosophy of learning at your own pace and will hopefully facilitate the depth of your learning. Also, this allows you to pursue your specific interests and flesh out your skill set in a way that benefits you the most. Introducing as many branches and directions as possible for programming Many introduction books on programming are content with covering the basics that are common to all programmers but then do not take you any further. In this book, I intend to point you to as many good resources as possible for as many branches of programming as I can. I will not recommend a resource unless I have used it myself and found it to be useful. There are, however, a few branches of programming for which I have not been able to find any good learning resources. Where this is the case, included are introductions to certain frameworks such as Tkinter and Pygame. Get you writing code as fast as possible I have always learned best by doing. I feel that for programming this is the best approach to learning therefore I aim to get you coding and keep you coding as much as possible. Get you reasonably coding proficient within 20 hours instead of 10,000 hours I have heard it said that it takes 10,000 hours to become proficient at something. I, along with this guy , believe that is false. My best aim is to get you reasonably proficient at Python within 20 hours of coding. With that said, you may find that you reach your 20-hour mark and are not finished with the book in terms of learning the basics. That is okay. You may find that a reasonable amount of proficiency is possible in less than 20 hours. That is also okay. Learn at your own pace, but understand that 10,000 hours of coding is NOT required to gain amazing benefits from coding. Okay, that is my soap box on the principles of this book. I will do my best to be as succinct as possible from here on out.","title":"1 - Introduction and How to Use this Book"},{"location":"01-Intro-and-How-to-Use-This-Book/#how-to-use-this-book","text":"","title":"How to use this book"},{"location":"01-Intro-and-How-to-Use-This-Book/#sections","text":"In each section of this book reading and exercises will be ordered by how mandatory they are. If you wish to move as quickly as possible, you may only do the first part of each section where I will cover the essential material. However, I do recommend doing all parts of every section to get the most out of this book as well as to hone your skills. The sections generally will be divided in to 3 subsections. Each of these sections has a distinct purpose. Depending on your level of skill and interest there are a number of ways of approaching each section. They are as follows: Reading and basic exercises This will be the main content of each section and is mandatory as you learn. It will include a relatively short introduction on the subject of each section and provide exercises intended to get you reasonably competent in a particular concept or skill. Once you have completed this subsection, you may move on to the next section with confidence that you have gotten the essential parts of the section. Hone Your Skills This subsection will include more challenging exercises designed to push you to find applications of the skill or concept in each section. If you feel weak on a particular topic, these sections provide a way to deepen your understanding and ensure you 'own' the concepts in each section. One of the most important skills you can learn is how to find answers for yourself. To that end, do not be surprised if some of the exercises ask you to go and research something yourself. Included in these subsections will be some extra information or directions to resources online and elsewhere that are intended to help you understand each concept more fully. Advanced Mastery These sections may not be attached to every section. However, I have added these subsections whenever I feel there are some deeper things to learn or some principles that will serve you as you master programming. These sections may involve concepts we have not covered yet as well so if you get to a point where you feel lost, just skip it and come back to it later. This book is intended to serve you and not the other way around. Therefore, I recommend you do the basics of each section. Beyond that, you are free to pursue what interests you and skip anything that doesn't. I am still playing with the layout of this text but a possible way to approach learning the material is to do the basics first and then add to your knowledge with the other two subsections.","title":"Sections"},{"location":"01-Intro-and-How-to-Use-This-Book/#boring-before-interesting","text":"In the 1984 film \" The Karate Kid \", Mr. Miyagi, the teacher, doesn't start training Daniel, the protagonist, in Karate by teaching him fancy moves but begins by having him perform many menial tasks with no apparent point to them. It is in doing these seemingly pointless tasks that Daniel first begins to have skill in Karate. You will find that anytime you want to learn a new skill you must do many boring and seemingly pointless things before you can do something interesting or useful. Every discipline has this feature. I am telling you this because for me, a person with a very limited attention span, the beginning of programming was agonizingly slow and seemingly pointless and you may feel that way too. However, if you will do some simple things in every section you will be well on your way to becoming a good programmer. The simple things you must do are the following: Read each section Type the corresponding code EXACTLY as it is written without copy-pasting it Make it run When things get boring or tedious, remember the Karate Kid. You are building a foundation on which you can move mountains.","title":"Boring Before Interesting"},{"location":"01-Intro-and-How-to-Use-This-Book/#learning-to-feed-yourself","text":"I will sometimes have you read Official Python documentation or visit other websites or resources. I do this for a number of reasons but most importantly, I want you to be able to teach yourself everything this book cannot. It would be my goal that, after you have read and learned everything in this book, you can put it down and never pick it up again because you have learned how to find answers to your own questions. Doing this will make you that much more effective as a programmer and in everything you do. Remember: Whenever I tell you to search for something on the Internet, remember that the best way to use a search engine is to type \"Python\" and then write what you are looking for. This will be a boon to your learning as you go along. Previous: 00-Table of Contents | Table of Contents | Next: 02-Getting Started","title":"Learning to feed yourself"},{"location":"02-Getting-Started/","text":"Previous: 01-Intro and How to Use This Book | Table of Contents | Next: 03-CLI 2 - Getting started Python is used by many different professionals for different reasons. One of the things that makes Python so useful is it\u2019s versatility. For this reason before you begin, it is useful to think about what you want to get out of Python. I, for example, am a chemical engineer and was introduced to Python in the context of engineering and even now I use it to solve engineering problems. However, I also wanted to learn how to make games as a hobby. Think about what you want out of Python before continuing. It is possible at this point that even after serious thought you just don\u2019t know yet what you want out of Python. This is just fine for now so don\u2019t worry too much about it. But keep in mind your learning will accelerate in a profound way if you have a goal in mind or an idea or project you can be passionate about. Python the programming language Python is a programming language. Without being too pedantic, a programming language is a way to 'talk' to your computer and give it instructions. Many programming languages are designed for specific tasks such as displaying things on the screen (e.g. HTML, CSS) or doing complex math (e.g. R, MATLAB). These languages are very useful within their scope of use but they are generally not functionally complete. Python on the other hand can be considered a functionally complete programming language. All this is to say that Python is designed so that you can write code to do anything a common computer can do. In fact there is very little that Python cannot do! You can write games, make a web server, do complex math, make attractive Graphical User Interfaces (GUIs) and many more things. In a very real sense, the only limits are your imagination. Python 3 Installation Notes for Linux/Unix and Mac OS X Users: The following steps should apply to you in the same way they apply to Windows users with a few caveats If you are an Mac OS X user you can open your terminal by searching your applications using spotlight search (press \u2318+Space and type in \"Terminal\" in the search box). For Linux/Unix users you can usually open your terminal by pressing ctrl+alt+t . You may find that Python 3 is already installed on your system. You can check if this is the case by just opening your terminal and typing \"Python3\". A string of text should appear indicating that Python has started. Also you should see >>> at the bottom of the page. If this does not happen then you will need to go through the following steps. Let's start by going to https://www.Python.org/downloads/ you will see a button there. Ensure that the correct operating system is selected (e.g. Windows, Mac OS X, Linux/Unix). Click on the \"Download Python 3.x.x\" button to begin the download. Once downloaded, open the file and you will see the following image. Ensure \"Add Python 3.X to PATH\" is checked and click \"Install Now\". Select \"Next\" on the next few screens and allow it to install on your computer. Note: If you want to get the 64-bit version or do any custom installation then I'm going to assume you know what you are doing and this tutorial is not necessary for you. If you don't know what any of that means then just do as it says above and you will be fine. Once the installation finishes, open your terminal or Windows PowerShell and type in Python into the prompt and press Enter. You should see something like: Then type exit() and exit the terminal. If all of this went as described above, congratulations! You have successfully installed Python on your computer! However if something went wrong, consult the Trouble Shooting Section below. Text Editor The next thing to consider is the way you will write code. True to my coding upbringing, I strongly discourage IDEs and IDLEs. They are not conducive to you learning how to code and will make you dependent on them. I have met too many coders that cannot work on anything but their own IDE and therefore are useless if anything even remotely different comes along. I am asking for some faith from you right now. But trust me when I say that if you learn to code without an IDE you will learn better than any of your peers that use an IDE. The question then becomes 'What do I use to code?' I will offer some recommendations but please don't spend too much time agonizing over which text editor to use. They are all largely the same anyway. The only thing that in my mind are must-haves for your text editor are: - Syntax Hightlighting - Line Numbers If you can find a text editor that does those two things then you are in business. Feel free to use any editor that can do those two things. (Just don't use and IDE or an IDLE.) Otherwise, here are my recommendations: For Windows users: Notepad++ For Macintosh users: Sublime Text For Linux users: Gedit For any other user looking for possible alternatives (that work on any desktop platform): Atom.io Sublime Text VS Code CLI Since one of my goals for you is to teach you on some level how your computer actually works (among other reasons) we will be using the Command Line Interface (CLI) for Windows this means the built-in Windows Power Shell, for Mac OSX and Linux this means the Terminal. Therefore we will spend some time getting to know the terminal before we begin in earnest. System requirements You may wonder if you computer can handle Python programming. I will simply say that as long as your computer was manufactured after about 2009 you shouldn't worry about anything. That is, with few exceptions, Python should not tax your computer any more than your web browser or office applications do. I do make some assumptions about your knowledge of computers. If any of the following do not apply to you please familiarize yourself with them before proceeding: I can use a web browser to follow links in this book. I am familiar with and know how to perform a search on a search engine like Google.com . Once you have determined you are ready, lets begin programming! Troubleshooting Your Installation |Space Intentionally Left blank| Previous: 01-Intro and How to Use This Book | Table of Contents | Next: 03-CLI","title":"2. Getting Started"},{"location":"02-Getting-Started/#2-getting-started","text":"Python is used by many different professionals for different reasons. One of the things that makes Python so useful is it\u2019s versatility. For this reason before you begin, it is useful to think about what you want to get out of Python. I, for example, am a chemical engineer and was introduced to Python in the context of engineering and even now I use it to solve engineering problems. However, I also wanted to learn how to make games as a hobby. Think about what you want out of Python before continuing. It is possible at this point that even after serious thought you just don\u2019t know yet what you want out of Python. This is just fine for now so don\u2019t worry too much about it. But keep in mind your learning will accelerate in a profound way if you have a goal in mind or an idea or project you can be passionate about.","title":"2 - Getting started"},{"location":"02-Getting-Started/#python-the-programming-language","text":"Python is a programming language. Without being too pedantic, a programming language is a way to 'talk' to your computer and give it instructions. Many programming languages are designed for specific tasks such as displaying things on the screen (e.g. HTML, CSS) or doing complex math (e.g. R, MATLAB). These languages are very useful within their scope of use but they are generally not functionally complete. Python on the other hand can be considered a functionally complete programming language. All this is to say that Python is designed so that you can write code to do anything a common computer can do. In fact there is very little that Python cannot do! You can write games, make a web server, do complex math, make attractive Graphical User Interfaces (GUIs) and many more things. In a very real sense, the only limits are your imagination.","title":"Python the programming language"},{"location":"02-Getting-Started/#python-3-installation","text":"Notes for Linux/Unix and Mac OS X Users: The following steps should apply to you in the same way they apply to Windows users with a few caveats If you are an Mac OS X user you can open your terminal by searching your applications using spotlight search (press \u2318+Space and type in \"Terminal\" in the search box). For Linux/Unix users you can usually open your terminal by pressing ctrl+alt+t . You may find that Python 3 is already installed on your system. You can check if this is the case by just opening your terminal and typing \"Python3\". A string of text should appear indicating that Python has started. Also you should see >>> at the bottom of the page. If this does not happen then you will need to go through the following steps. Let's start by going to https://www.Python.org/downloads/ you will see a button there. Ensure that the correct operating system is selected (e.g. Windows, Mac OS X, Linux/Unix). Click on the \"Download Python 3.x.x\" button to begin the download. Once downloaded, open the file and you will see the following image. Ensure \"Add Python 3.X to PATH\" is checked and click \"Install Now\". Select \"Next\" on the next few screens and allow it to install on your computer. Note: If you want to get the 64-bit version or do any custom installation then I'm going to assume you know what you are doing and this tutorial is not necessary for you. If you don't know what any of that means then just do as it says above and you will be fine. Once the installation finishes, open your terminal or Windows PowerShell and type in Python into the prompt and press Enter. You should see something like: Then type exit() and exit the terminal. If all of this went as described above, congratulations! You have successfully installed Python on your computer! However if something went wrong, consult the Trouble Shooting Section below.","title":"Python 3 Installation"},{"location":"02-Getting-Started/#text-editor","text":"The next thing to consider is the way you will write code. True to my coding upbringing, I strongly discourage IDEs and IDLEs. They are not conducive to you learning how to code and will make you dependent on them. I have met too many coders that cannot work on anything but their own IDE and therefore are useless if anything even remotely different comes along. I am asking for some faith from you right now. But trust me when I say that if you learn to code without an IDE you will learn better than any of your peers that use an IDE. The question then becomes 'What do I use to code?' I will offer some recommendations but please don't spend too much time agonizing over which text editor to use. They are all largely the same anyway. The only thing that in my mind are must-haves for your text editor are: - Syntax Hightlighting - Line Numbers If you can find a text editor that does those two things then you are in business. Feel free to use any editor that can do those two things. (Just don't use and IDE or an IDLE.) Otherwise, here are my recommendations: For Windows users: Notepad++ For Macintosh users: Sublime Text For Linux users: Gedit For any other user looking for possible alternatives (that work on any desktop platform): Atom.io Sublime Text VS Code","title":"Text Editor"},{"location":"02-Getting-Started/#cli","text":"Since one of my goals for you is to teach you on some level how your computer actually works (among other reasons) we will be using the Command Line Interface (CLI) for Windows this means the built-in Windows Power Shell, for Mac OSX and Linux this means the Terminal. Therefore we will spend some time getting to know the terminal before we begin in earnest.","title":"CLI"},{"location":"02-Getting-Started/#system-requirements","text":"You may wonder if you computer can handle Python programming. I will simply say that as long as your computer was manufactured after about 2009 you shouldn't worry about anything. That is, with few exceptions, Python should not tax your computer any more than your web browser or office applications do. I do make some assumptions about your knowledge of computers. If any of the following do not apply to you please familiarize yourself with them before proceeding: I can use a web browser to follow links in this book. I am familiar with and know how to perform a search on a search engine like Google.com . Once you have determined you are ready, lets begin programming!","title":"System requirements"},{"location":"02-Getting-Started/#troubleshooting-your-installation","text":"|Space Intentionally Left blank| Previous: 01-Intro and How to Use This Book | Table of Contents | Next: 03-CLI","title":"Troubleshooting Your Installation"},{"location":"03-CLI/","text":"Previous: 02-Getting Started | Table of Contents | Next: 04-Hello World 3 - CLI Introduction Welcome to the Command Line Interface (CLI)! Before we begin programming we need to understand something about the context and environment that we are working in. First, we start with a little nomenclature. Perhaps you have seen a black, white or blue window with nothing but text in it on your computer. This is called the command line or the command line interface. I will refer to it as the \"command line\" in this lesson. An example of one is shown below: This interface was at one point the only way to use a computer. Generally speaking, if you wanted to explore files, play a computer game or use any program, this was the way you needed to do it. There were no windowing systems or point-and-click interfaces. The way you did anything was to type commands into the prompt (seen above as the text after the $ ) and look at the output that resulted. We will be doing something similar in this lesson. To enter any command simply type the command in and press Enter. Secondly, you should be familiar with basic terminology relating to file systems. (i.e. words like \"folder\", \"file\", \"program\" and \"app\"/\"application\"). I will use the words 'directory' and 'folder' interchangeably. All file systems I have seen start with a \"root\" folder (usually C:\\ for Windows and / for OS X and Linux). File systems start at this root folder and have a tree of sub-folders in which all files are organized. We will explore this via the command line and cover how to do basic navigation and commands. The command line is a large and powerful interface so this lesson is by no means comprehensive. It is intended to get you just competent enough to do programming. We will explore more about the command line later. Open the command line Depending on your operating system (e.g. Microsoft Windows, Apple Mac OS X, Linux) the way to open your command line differs significantly. Once your command line is open however, almost everything else is the same or very similar. I will indicate the differences where this is the case. Windows 7/8/10 From your desktop, press the windows key. (The start menu should pop up.) Type in \"powershell\" into the start menu search bar. (A bunch of options should be displayed) Select \"Windows PowerShell\" from the list of options to open it. (A blue box with some text and a prompt should appear that looks something like this: C:\\Users\\\"YOUR USERNAME\"\\> ) Apple Mac OS X Open spotlight search by pressing \u2318+Space. (A spotlight search bar should appear on your screen.) Type \"terminal\" into the search bar. (Options should appear under the search bar.) Select the \"Terminal\" application to open it. (A white box with some text should appear with a prompt that looks something like: \"YOUR COMPUTER'S NAME\":~ \"YOUR USERNAME\"$ ) Linux Press ctrl+t or ctrl+alt+t from your desktop. (A bash window should appear with some text in it and a prompt that looks like: \"YOUR USERNAME\"@\"YOUR COMPUTER'S NAME\" ~ $ or -bash-4.2$ ) Regardless of what kind of prompt appears on your command line interface, ignore everything on the line before the $ or the > that is, the prompt symbol. That part before the prompt symbol is usually irrelevant to understanding what is happening anyway. In this lesson and the rest of the book, I have omitted anything before the prompt symbol and you may interpret the $ or the > as being equivalent. Therefore, when you see something like $ clear written in the book, you should read that as, \"Type the text clear into the command line prompt and press enter.\" Once you have successfully opened your command line interface, you may begin the rest of the lesson. The object of this lesson is to practice and become familiar with each of the commands listed below. A summary table at the end of the lesson lists all the commands and what they do. Where am I? (Command: pwd ) Begin by typing the following in your prompt and pressing Enter: $ pwd 'pwd' means 'print working directory'. This command will show you where you are in the directory structure of your computer. For example typing this command into the terminal on my linux computer will return /home/mer/ , which tells me I am in the 'mer' directory of the 'home' directory of the root directory of my computer. Similarly in Windows, pwd returns C:\\Users\\<YOURNAME>\\ . Therefore if you ever get lost while navigating in the terminal, use pwd to figure out where you are. Moving Around (Command: cd ) Type the following into your terminal and press Enter: $ cd ~ cd means 'change directory' and is one of the main ways you will navigate the command line. The normal usage of the \"change directory\" command is of the form: $ cd \"NAME OF DIRECTORY\" (e.g. cd Documents ) but in this case we are using the \"home\" short cut ( ~ ). The tilde ( ~ ) is a short hand that stands for the 'home' directory. This can take you to slightly different places depending on the operating system you are running, but should be the default starting place for any folders you may wish to navigate. If you need to get back home or want to navigate from the home folder as a root folder the ~ will get you there. So when you enter `` what you are telling the terminal is this: \"Take me me to the home folder.\" Or \"Change the working directory to the home folder\". Working in folders (Commands: ls , mkdir , and touch or New-Item ) Now that you are in the 'home' folder, enter the following: $ ls ls is short hand for \"list files and sub-folders in the current directory\". Upon entering this command you should see a list of files and directories in your home folder. Let's make a directory in your home folder. Enter the following: $ mkdir peas Now enter the ls command and you will notice a new folder in your home folder called 'peas' you made it with the 'make directory' command. Let's go in there! $ cd peas $ ls $ If you type in the above commands in you will notice that nothing comes up! There is nothing in this folder yet so lets make a file to put in this folder! This is bit different for Windows so follow the Windows commands if you are using Windows. Command for Mac OS X or Linux bash $ touch carrots.py Command for Windows ```powershell New-Item -type file carrots.py ``` You have just created an empty file called carrots.py . The .py part of the filename is called the extension and is a way that a user communicates what kind of file is being used. Generally, Python files have the .py extension but they are not fundamentally different from plain text files (i.e. files that end in .txt ). Make another file called cool_beans.txt using the touch command (if you're on Mac OS X or Linux) or New-Item command (if you're on windows). Go on try it yourself! Did you do it? Check that you it worked using the ls command. You should see that you have two files in this folder. If you're curious you can \"print the working directory\" and find this folder in your file explorer program on your computer. Cool huh? Now that we know how to create files and folders we will now learn how to delete them. Deleting Files and Folders (Commands: rm , rmdir ) Now that we know how to create files and folders we will now learn how to delete them. Let's delete your files by entering the command: $ rm carrots.py rm means \"remove\". Verify that this has been deleted with ls . Now let's delete the other file. $ rm cool_beans.txt When you finish this your directory should once again be empty. You can verify this with ls . Now...how do we get out of here? You may want to go directly to the home directory using $ cd ~ but you may not always want to go all the way back to the home directory when all you really want is to go to the parent directory. I will now show you the way to do this. Simply enter: $ cd .. This is a shorthand for, \"change directory to the immediate parent directory\" in a manner that is known as \"relative path reference\". In the command line, . or ./ is short hand for \"the directory I'm in right now\" and .. or ../ means \"the immediate parent folder of where I am right now\". You can verify that you have indeed left the peas directory by using the pwd and ls commands. Now it is time to actually delete the directory. $ rmdir peas If you didn't have any errors doing this congratulations! You have finished the basic exercises for the command line! Review Below is a table of all the commands we learned in this lesson and pertinent information about each. Command Usage Effect pwd $ pwd \"Print Working Directory\": Prints the location of the folder you are currently in. cd $ cd NAME \"Change Directory\": Changes your location to that of NAME . The tilde ~ refers to the home directory, . refers to the current directory and .. refers to the immediate parent directory. ls $ ls Lists all files and sub-folders in the current directory. mkdir $ mkdir NAME \"Make Directory\": Makes a directory in the current directory called NAME . touch $ touch NAME.EXT ( Mac and Linux ) Makes a new file in the current directory with a name of NAME and an extension of .ext New-item > New-Item -type file NAME.ext ( Windows ) Same as touch . rm $ rm NAME \"Remove\": Permanently deletes the file called NAME where NAME includes both the filename and the extension. rmdir $ rmdir NAME \"Remove Directory\": Permanently deletes a directory called NAME . (Only works if the directory is empty.) Memorize these commands or keep this cheat sheet with you to help you work in the command line. Once you feel comfortable with these commands then it's time to start programming! Hone your skills Here are a few questions you should research: Normally you have to remove every file in a directory before you can delete the directory. What is a way you can delete a directory and all its contents using one line of command line code? Why would you not want to do this? How could you navigate to the parent directory's parent's parent directory in one line of code? Look up commands to 'copy', 'rename' and 'move' files in command line. How would you complete these common tasks in command line? Research other common commands in command line and learn them for your benefit. There are many good tutorials to use many powerful commands in the command line. Advanced mastery Look up 'shell scripting' for your platform (i.e. Windows Command Prompt (cmd) or Windows Powershell, Linux Bash, or OS X Terminal). Begin to learn to shell script on your computer. We will cover some basics of shell scripting later of study but beginning to learn shell scripting can be powerful as many of the concepts we will learn apply to shell scripting as well. Previous: 02-Getting Started | Table of Contents | Next: 04-Hello World","title":"3. CLI"},{"location":"03-CLI/#3-cli","text":"","title":"3 - CLI"},{"location":"03-CLI/#introduction","text":"Welcome to the Command Line Interface (CLI)! Before we begin programming we need to understand something about the context and environment that we are working in. First, we start with a little nomenclature. Perhaps you have seen a black, white or blue window with nothing but text in it on your computer. This is called the command line or the command line interface. I will refer to it as the \"command line\" in this lesson. An example of one is shown below: This interface was at one point the only way to use a computer. Generally speaking, if you wanted to explore files, play a computer game or use any program, this was the way you needed to do it. There were no windowing systems or point-and-click interfaces. The way you did anything was to type commands into the prompt (seen above as the text after the $ ) and look at the output that resulted. We will be doing something similar in this lesson. To enter any command simply type the command in and press Enter. Secondly, you should be familiar with basic terminology relating to file systems. (i.e. words like \"folder\", \"file\", \"program\" and \"app\"/\"application\"). I will use the words 'directory' and 'folder' interchangeably. All file systems I have seen start with a \"root\" folder (usually C:\\ for Windows and / for OS X and Linux). File systems start at this root folder and have a tree of sub-folders in which all files are organized. We will explore this via the command line and cover how to do basic navigation and commands. The command line is a large and powerful interface so this lesson is by no means comprehensive. It is intended to get you just competent enough to do programming. We will explore more about the command line later.","title":"Introduction"},{"location":"03-CLI/#open-the-command-line","text":"Depending on your operating system (e.g. Microsoft Windows, Apple Mac OS X, Linux) the way to open your command line differs significantly. Once your command line is open however, almost everything else is the same or very similar. I will indicate the differences where this is the case. Windows 7/8/10 From your desktop, press the windows key. (The start menu should pop up.) Type in \"powershell\" into the start menu search bar. (A bunch of options should be displayed) Select \"Windows PowerShell\" from the list of options to open it. (A blue box with some text and a prompt should appear that looks something like this: C:\\Users\\\"YOUR USERNAME\"\\> ) Apple Mac OS X Open spotlight search by pressing \u2318+Space. (A spotlight search bar should appear on your screen.) Type \"terminal\" into the search bar. (Options should appear under the search bar.) Select the \"Terminal\" application to open it. (A white box with some text should appear with a prompt that looks something like: \"YOUR COMPUTER'S NAME\":~ \"YOUR USERNAME\"$ ) Linux Press ctrl+t or ctrl+alt+t from your desktop. (A bash window should appear with some text in it and a prompt that looks like: \"YOUR USERNAME\"@\"YOUR COMPUTER'S NAME\" ~ $ or -bash-4.2$ ) Regardless of what kind of prompt appears on your command line interface, ignore everything on the line before the $ or the > that is, the prompt symbol. That part before the prompt symbol is usually irrelevant to understanding what is happening anyway. In this lesson and the rest of the book, I have omitted anything before the prompt symbol and you may interpret the $ or the > as being equivalent. Therefore, when you see something like $ clear written in the book, you should read that as, \"Type the text clear into the command line prompt and press enter.\" Once you have successfully opened your command line interface, you may begin the rest of the lesson. The object of this lesson is to practice and become familiar with each of the commands listed below. A summary table at the end of the lesson lists all the commands and what they do.","title":"Open the command line"},{"location":"03-CLI/#where-am-i-command-pwd","text":"Begin by typing the following in your prompt and pressing Enter: $ pwd 'pwd' means 'print working directory'. This command will show you where you are in the directory structure of your computer. For example typing this command into the terminal on my linux computer will return /home/mer/ , which tells me I am in the 'mer' directory of the 'home' directory of the root directory of my computer. Similarly in Windows, pwd returns C:\\Users\\<YOURNAME>\\ . Therefore if you ever get lost while navigating in the terminal, use pwd to figure out where you are.","title":"Where am I? (Command: pwd)"},{"location":"03-CLI/#moving-around-command-cd","text":"Type the following into your terminal and press Enter: $ cd ~ cd means 'change directory' and is one of the main ways you will navigate the command line. The normal usage of the \"change directory\" command is of the form: $ cd \"NAME OF DIRECTORY\" (e.g. cd Documents ) but in this case we are using the \"home\" short cut ( ~ ). The tilde ( ~ ) is a short hand that stands for the 'home' directory. This can take you to slightly different places depending on the operating system you are running, but should be the default starting place for any folders you may wish to navigate. If you need to get back home or want to navigate from the home folder as a root folder the ~ will get you there. So when you enter `` what you are telling the terminal is this: \"Take me me to the home folder.\" Or \"Change the working directory to the home folder\".","title":"Moving Around (Command: cd)"},{"location":"03-CLI/#working-in-folders-commands-ls-mkdir-and-touch-or-new-item","text":"Now that you are in the 'home' folder, enter the following: $ ls ls is short hand for \"list files and sub-folders in the current directory\". Upon entering this command you should see a list of files and directories in your home folder. Let's make a directory in your home folder. Enter the following: $ mkdir peas Now enter the ls command and you will notice a new folder in your home folder called 'peas' you made it with the 'make directory' command. Let's go in there! $ cd peas $ ls $ If you type in the above commands in you will notice that nothing comes up! There is nothing in this folder yet so lets make a file to put in this folder! This is bit different for Windows so follow the Windows commands if you are using Windows. Command for Mac OS X or Linux bash $ touch carrots.py Command for Windows ```powershell New-Item -type file carrots.py ``` You have just created an empty file called carrots.py . The .py part of the filename is called the extension and is a way that a user communicates what kind of file is being used. Generally, Python files have the .py extension but they are not fundamentally different from plain text files (i.e. files that end in .txt ). Make another file called cool_beans.txt using the touch command (if you're on Mac OS X or Linux) or New-Item command (if you're on windows). Go on try it yourself! Did you do it? Check that you it worked using the ls command. You should see that you have two files in this folder. If you're curious you can \"print the working directory\" and find this folder in your file explorer program on your computer. Cool huh? Now that we know how to create files and folders we will now learn how to delete them.","title":"Working in folders (Commands: ls, mkdir, and touch or New-Item)"},{"location":"03-CLI/#deleting-files-and-folders-commands-rm-rmdir","text":"Now that we know how to create files and folders we will now learn how to delete them. Let's delete your files by entering the command: $ rm carrots.py rm means \"remove\". Verify that this has been deleted with ls . Now let's delete the other file. $ rm cool_beans.txt When you finish this your directory should once again be empty. You can verify this with ls . Now...how do we get out of here? You may want to go directly to the home directory using $ cd ~ but you may not always want to go all the way back to the home directory when all you really want is to go to the parent directory. I will now show you the way to do this. Simply enter: $ cd .. This is a shorthand for, \"change directory to the immediate parent directory\" in a manner that is known as \"relative path reference\". In the command line, . or ./ is short hand for \"the directory I'm in right now\" and .. or ../ means \"the immediate parent folder of where I am right now\". You can verify that you have indeed left the peas directory by using the pwd and ls commands. Now it is time to actually delete the directory. $ rmdir peas If you didn't have any errors doing this congratulations! You have finished the basic exercises for the command line!","title":"Deleting Files and Folders (Commands: rm, rmdir)"},{"location":"03-CLI/#review","text":"Below is a table of all the commands we learned in this lesson and pertinent information about each. Command Usage Effect pwd $ pwd \"Print Working Directory\": Prints the location of the folder you are currently in. cd $ cd NAME \"Change Directory\": Changes your location to that of NAME . The tilde ~ refers to the home directory, . refers to the current directory and .. refers to the immediate parent directory. ls $ ls Lists all files and sub-folders in the current directory. mkdir $ mkdir NAME \"Make Directory\": Makes a directory in the current directory called NAME . touch $ touch NAME.EXT ( Mac and Linux ) Makes a new file in the current directory with a name of NAME and an extension of .ext New-item > New-Item -type file NAME.ext ( Windows ) Same as touch . rm $ rm NAME \"Remove\": Permanently deletes the file called NAME where NAME includes both the filename and the extension. rmdir $ rmdir NAME \"Remove Directory\": Permanently deletes a directory called NAME . (Only works if the directory is empty.) Memorize these commands or keep this cheat sheet with you to help you work in the command line. Once you feel comfortable with these commands then it's time to start programming!","title":"Review"},{"location":"03-CLI/#hone-your-skills","text":"Here are a few questions you should research: Normally you have to remove every file in a directory before you can delete the directory. What is a way you can delete a directory and all its contents using one line of command line code? Why would you not want to do this? How could you navigate to the parent directory's parent's parent directory in one line of code? Look up commands to 'copy', 'rename' and 'move' files in command line. How would you complete these common tasks in command line? Research other common commands in command line and learn them for your benefit. There are many good tutorials to use many powerful commands in the command line.","title":"Hone your skills"},{"location":"03-CLI/#advanced-mastery","text":"Look up 'shell scripting' for your platform (i.e. Windows Command Prompt (cmd) or Windows Powershell, Linux Bash, or OS X Terminal). Begin to learn to shell script on your computer. We will cover some basics of shell scripting later of study but beginning to learn shell scripting can be powerful as many of the concepts we will learn apply to shell scripting as well. Previous: 02-Getting Started | Table of Contents | Next: 04-Hello World","title":"Advanced mastery"},{"location":"04-Hello-World/","text":"Previous: 03-CLI | Table of Contents | Next: 05-Comments 4 - Hello World! If you have completed the two sections successfully you are ready now to begin the actual programming! We will begin with the most basic program that actually does something in Python. This is common when you want to begin any programming language. As with all things, beginning in Python is very simple. Making your first Python source file Start by opening your text editor and opening a new file Pick a folder to keep all your Python learning files in. This could be in your home folder but I like to put it in my \"Documents\" folder. Use the 'Save as' dialog to save this file in a folder where you want to keep all your Python files Give the file the name hello_world.py and save it You will notice the .py part of the filename. This is called an extension and is a way of telling the computer or anyone who looks at the file what kind of file it is. Make sure you name all files you make in Python using this extension. Also it is good practice to never use spaces when naming files used in programming. Use underscores instead of spaces. There are reasons for this but just for now trust me when I say that you are avoiding a lot of confusion and problems if you just commit to never using spaces in your filenames when you write code. NOTE: I will give you the name of each filename you should be using for each exercise in this book. When you see an octothorpe ( # ) followed by a filename at the beginning of a code example, it means I want you to make a new file with that name by following the steps above. Type the following exactly as it is written here. Do not copy-paste it. # hello_world.py print(\"Hello World!\") Go to your terminal and navigate to the folder that holds your Python file. Enter the following command in your terminal: $ python hello_world.py Here is what should happen $ python hello_world.py Hello World! $ If you see the above output, congratulations! You have just written and run your first Python program! What is happening here? Traditionally, displaying \"Hello World!\" in a console window is the first thing that every programmer generally learns to do in a new language. Later we will get into more detail on how exactly everything works and what is happening on a fundamental level. Go back to your Python file and add the following under the first line so the whole file looks like this: # hello_world.py print(\"Hello World!\") print(\"I skipped a line in code!\") print(\"Here is a little song:\") print(\"Twinkle, twinkle little star,\") print(\"How I wonder what you are.\") print(\"Up above the world so high,\") print(\"Like a diamond in the sky\") print(\"Twinkle, twinkle little star\") print(\"How I wonder what you are.\") Here is what should happen Re-run the code as before and you should see the following: $ python hello_world.py Hello World! I skipped a line in code! Here is a little song: Twinkle, twinkle little star, How I wonder what you are. Up above the world so high, Like a diamond in the sky Twinkle, twinkle little star How I wonder what you are. $ As you can see here, the code runs in order line by line, ignoring any blank lines. This is how any python program works. It starts on line 1 and executes each line of code until it reaches the end of the file. Once you see the output appear exactly as it appears above, congratulations! You have completed the first exercise! This is the general format for most of the sections in this book. For each section I will have you write some code and then we will go back and try to understand it. Hone Your Skills This is the simplest type of program that exists in Python (i.e. simple statements in a ordered list). Now is a good time to get used to some fundamental concepts: There is no such thing as perfect code It is likely that unless you were paying very careful attention to what you were doing that you made a mistake. In which case you may have gotten an error such as the one below In this example example, I deleted the last three characters on line 8 and got this message. As you can see, Python tells me exactly where my mistake is and what kind of error it is. Take some time and mess with this program. Delete different parts and try to run it and see the kind of errors you get. My hope is that you'll get two things out of this: First, don't be afraid to make mistakes (although you of course want to avoid them if you can) and secondly, when an error does happen, this should help you begin to be comfortable with how python reports errors and exceptions. We will cover these in more detail in a later lesson. File \"hello_world.py\", line 8 print(\"How I wonder what you are ^ SyntaxError: EOL while scanning string literal \"Sparse is better than dense\" From \" Zen of Python \" there is a line that says, \"Sparse is better than dense\". This refers, in part, to the fact that it is often much easier to read code when there is some white space in between lines. When you write code you should be organizing it in your mind and this should reflect in how the code is written. Look back at the code that you wrote down from this lesson. Does the spacing make sense? How would you change the spacing to be more consistent? Would you add more lines here or fewer there? Rewrite the code to reflect your mental understanding of the code. Previous: 03-CLI | Table of Contents | Next: 05-Comments","title":"4. Hello World"},{"location":"04-Hello-World/#4-hello-world","text":"If you have completed the two sections successfully you are ready now to begin the actual programming! We will begin with the most basic program that actually does something in Python. This is common when you want to begin any programming language. As with all things, beginning in Python is very simple.","title":"4 - Hello World!"},{"location":"04-Hello-World/#making-your-first-python-source-file","text":"Start by opening your text editor and opening a new file Pick a folder to keep all your Python learning files in. This could be in your home folder but I like to put it in my \"Documents\" folder. Use the 'Save as' dialog to save this file in a folder where you want to keep all your Python files Give the file the name hello_world.py and save it You will notice the .py part of the filename. This is called an extension and is a way of telling the computer or anyone who looks at the file what kind of file it is. Make sure you name all files you make in Python using this extension. Also it is good practice to never use spaces when naming files used in programming. Use underscores instead of spaces. There are reasons for this but just for now trust me when I say that you are avoiding a lot of confusion and problems if you just commit to never using spaces in your filenames when you write code. NOTE: I will give you the name of each filename you should be using for each exercise in this book. When you see an octothorpe ( # ) followed by a filename at the beginning of a code example, it means I want you to make a new file with that name by following the steps above. Type the following exactly as it is written here. Do not copy-paste it. # hello_world.py print(\"Hello World!\") Go to your terminal and navigate to the folder that holds your Python file. Enter the following command in your terminal: $ python hello_world.py Here is what should happen $ python hello_world.py Hello World! $ If you see the above output, congratulations! You have just written and run your first Python program! What is happening here? Traditionally, displaying \"Hello World!\" in a console window is the first thing that every programmer generally learns to do in a new language. Later we will get into more detail on how exactly everything works and what is happening on a fundamental level. Go back to your Python file and add the following under the first line so the whole file looks like this: # hello_world.py print(\"Hello World!\") print(\"I skipped a line in code!\") print(\"Here is a little song:\") print(\"Twinkle, twinkle little star,\") print(\"How I wonder what you are.\") print(\"Up above the world so high,\") print(\"Like a diamond in the sky\") print(\"Twinkle, twinkle little star\") print(\"How I wonder what you are.\") Here is what should happen Re-run the code as before and you should see the following: $ python hello_world.py Hello World! I skipped a line in code! Here is a little song: Twinkle, twinkle little star, How I wonder what you are. Up above the world so high, Like a diamond in the sky Twinkle, twinkle little star How I wonder what you are. $ As you can see here, the code runs in order line by line, ignoring any blank lines. This is how any python program works. It starts on line 1 and executes each line of code until it reaches the end of the file. Once you see the output appear exactly as it appears above, congratulations! You have completed the first exercise! This is the general format for most of the sections in this book. For each section I will have you write some code and then we will go back and try to understand it.","title":"Making your first Python source file"},{"location":"04-Hello-World/#hone-your-skills","text":"This is the simplest type of program that exists in Python (i.e. simple statements in a ordered list). Now is a good time to get used to some fundamental concepts: There is no such thing as perfect code It is likely that unless you were paying very careful attention to what you were doing that you made a mistake. In which case you may have gotten an error such as the one below In this example example, I deleted the last three characters on line 8 and got this message. As you can see, Python tells me exactly where my mistake is and what kind of error it is. Take some time and mess with this program. Delete different parts and try to run it and see the kind of errors you get. My hope is that you'll get two things out of this: First, don't be afraid to make mistakes (although you of course want to avoid them if you can) and secondly, when an error does happen, this should help you begin to be comfortable with how python reports errors and exceptions. We will cover these in more detail in a later lesson. File \"hello_world.py\", line 8 print(\"How I wonder what you are ^ SyntaxError: EOL while scanning string literal \"Sparse is better than dense\" From \" Zen of Python \" there is a line that says, \"Sparse is better than dense\". This refers, in part, to the fact that it is often much easier to read code when there is some white space in between lines. When you write code you should be organizing it in your mind and this should reflect in how the code is written. Look back at the code that you wrote down from this lesson. Does the spacing make sense? How would you change the spacing to be more consistent? Would you add more lines here or fewer there? Rewrite the code to reflect your mental understanding of the code. Previous: 03-CLI | Table of Contents | Next: 05-Comments","title":"Hone Your Skills"},{"location":"05-Comments/","text":"Previous: 04-Hello World | Table of Contents | Next: 06-Strings and the Print Function 5 - Comments The next thing you need to understand that is fundamental to programming is comments in code. What is an octothorpe? You have probably seen this symbol at some point: # The proper name for this symbol is an octothorpe. However, I have heard the following names for it: Hash, Hashtag, Pound and Tic-tac-toe symbol. For the purposes of this book I will refer to it as a hash. The hash has a special purpose that will be seen in the code you will write below. # octothorpe.py # I can explain the code here \"\"\" I can do some lengthy explanations here too. But this can span over multiple lines \"\"\" ''' Sometimes I want to use single quotes though when I want to do this, Python doesn't care. It just keeps on doing its thing and ignoring me ''' print(\"Here is some text that will appear.\") # this is a print statement #print(\"Here is some text that will not appear.\") print(\"A good line of code is hard to find.\") \"\"\" print(\"But this line doesn't even work.\") \"\"\" print(\"At last we can print again.\") \"\"\" print(\"none\") print(\"of\") print(\"these\") print(\"lines\") print(\"print\") \"\"\" print(\"Well I guess we're done here.\") Here is what should happen $ python octothorpe.py Here is some text that will appear. A good line of code is hard to find. At last we can print again. Well I guess we're done here. $ Again if the result you get isn't exactly like the book's, go back in fix it until you get it right. About comments As you may be able to surmise from the code, the hash symbol tells Python, \"Ignore everything after this on this line\". The triple quotes ( \"\"\" or ''' ) begin and end a block of text that can span as many lines as you want that Python will likewise ignore. (There are a few exceptions to this but we will cover them later.) These are generally called \"comments\" in the code. They let the programmer make comments that either explain small bits of code or provide detailed explanations of his code. They also allow the programmer to disable chunks of code if desired. NOTE: Whenever you use quotes in Python you must be consistent which ever you decide to use for a particular case. Comment Conventions The following rules of thumb apply to code comments and are demonstrated below (don't bother writing this all out, just read it): ''' File : comment_conventions.py Author : Mark Redd Version : 1.0 Description : It is common to have a header at the top of your file that has the filename, author and a general description of the program in the file. This space may also be used to include pertient data about the software such as its version number or the date it was last modified. In many cases this header may be long and detailed depending on the intent of the programmer. For the purposes of this book, we will not worry about having headers in our code until we tackle some larger, more complex problems but it's good to know that these things exist. ''' '''Single line comments that explain code ''' # should be in one of two places: # This comment explains the line below print(\"Here are some words\") # The comment may be here as well if space permits # If needed, the comment may span # multiple lines. The comment is generally # above the line or block of code # it explains in any case. print(\"Here are some words\") # The comment may be here as well if space permits \"\"\" It is bad practice to write comments that trail off the visible screen. Later we will explore code style and explain this convetion more fully. Multi-line comments may be placed wherever appropriate to make general comments or explain a large block of code. \"\"\" I will often put comments in the code I have you write. You will need to put these in your code as well but also I will have you explain your code line by line with comments. You may find it useful to take notes as you write code to help you remember what you have learned. Hone Your Skills Look up what Python Docstrings are. Why would you want to use them? Comment and uncomment some of the lines in the code you wrote. What can you happen by uncommenting code? Previous: 04-Hello World | Table of Contents | Next: 06-Strings and the Print Function","title":"5. Comments"},{"location":"05-Comments/#5-comments","text":"The next thing you need to understand that is fundamental to programming is comments in code.","title":"5 - Comments"},{"location":"05-Comments/#what-is-an-octothorpe","text":"You have probably seen this symbol at some point: # The proper name for this symbol is an octothorpe. However, I have heard the following names for it: Hash, Hashtag, Pound and Tic-tac-toe symbol. For the purposes of this book I will refer to it as a hash. The hash has a special purpose that will be seen in the code you will write below. # octothorpe.py # I can explain the code here \"\"\" I can do some lengthy explanations here too. But this can span over multiple lines \"\"\" ''' Sometimes I want to use single quotes though when I want to do this, Python doesn't care. It just keeps on doing its thing and ignoring me ''' print(\"Here is some text that will appear.\") # this is a print statement #print(\"Here is some text that will not appear.\") print(\"A good line of code is hard to find.\") \"\"\" print(\"But this line doesn't even work.\") \"\"\" print(\"At last we can print again.\") \"\"\" print(\"none\") print(\"of\") print(\"these\") print(\"lines\") print(\"print\") \"\"\" print(\"Well I guess we're done here.\") Here is what should happen $ python octothorpe.py Here is some text that will appear. A good line of code is hard to find. At last we can print again. Well I guess we're done here. $ Again if the result you get isn't exactly like the book's, go back in fix it until you get it right.","title":"What is an octothorpe?"},{"location":"05-Comments/#about-comments","text":"As you may be able to surmise from the code, the hash symbol tells Python, \"Ignore everything after this on this line\". The triple quotes ( \"\"\" or ''' ) begin and end a block of text that can span as many lines as you want that Python will likewise ignore. (There are a few exceptions to this but we will cover them later.) These are generally called \"comments\" in the code. They let the programmer make comments that either explain small bits of code or provide detailed explanations of his code. They also allow the programmer to disable chunks of code if desired. NOTE: Whenever you use quotes in Python you must be consistent which ever you decide to use for a particular case.","title":"About comments"},{"location":"05-Comments/#comment-conventions","text":"The following rules of thumb apply to code comments and are demonstrated below (don't bother writing this all out, just read it): ''' File : comment_conventions.py Author : Mark Redd Version : 1.0 Description : It is common to have a header at the top of your file that has the filename, author and a general description of the program in the file. This space may also be used to include pertient data about the software such as its version number or the date it was last modified. In many cases this header may be long and detailed depending on the intent of the programmer. For the purposes of this book, we will not worry about having headers in our code until we tackle some larger, more complex problems but it's good to know that these things exist. ''' '''Single line comments that explain code ''' # should be in one of two places: # This comment explains the line below print(\"Here are some words\") # The comment may be here as well if space permits # If needed, the comment may span # multiple lines. The comment is generally # above the line or block of code # it explains in any case. print(\"Here are some words\") # The comment may be here as well if space permits \"\"\" It is bad practice to write comments that trail off the visible screen. Later we will explore code style and explain this convetion more fully. Multi-line comments may be placed wherever appropriate to make general comments or explain a large block of code. \"\"\" I will often put comments in the code I have you write. You will need to put these in your code as well but also I will have you explain your code line by line with comments. You may find it useful to take notes as you write code to help you remember what you have learned.","title":"Comment Conventions"},{"location":"05-Comments/#hone-your-skills","text":"Look up what Python Docstrings are. Why would you want to use them? Comment and uncomment some of the lines in the code you wrote. What can you happen by uncommenting code? Previous: 04-Hello World | Table of Contents | Next: 06-Strings and the Print Function","title":"Hone Your Skills"},{"location":"06-Strings-and-the-Print-Function/","text":"Previous: 05-Comments | Table of Contents | Next: 07-Escape Characters 6 - Strings and the print function The print function Lets talk about the print statement or as it is more correctly called, the print function. \"print\" is what is known as a built-in function in Python. Let's get some terminology out of the way before moving on: Function : A chunk of code that you can reuse multiple times with a single line of code. We will learn a lot more about functions later on and you will even build your own. But for now, just understand the following: There is some chunk of code labeled 'print' out there in the Python ether When you write print(stuff) in your code you are telling the computer, \"ACTIVATE THAT CHUNK OF CODE LABELED 'print'!\" The chunk of code then comes alive and says, \"Okay! My job is to write the stuff between the parentheses in the terminal window!\" The chunk of code does just that and then becomes dormant awaiting the next time it is called to action. When we talk about functions you will see that they have things (such as stuff above) between the parentheses. Sometimes these things are in a comma-separated list. These things between the parentheses are called arguments . For now, we have just one argument being fed to the print function and that is simply the text you want printed out to the screen. Strings You may have noticed that the text inside the parentheses is also between single or double quotes. It may not be clear why this is. In Python, putting text inside quotes designates it as a string. String : a sequence of characters that is generally treated as non-code text The quotes are necessary to differentiate between code being fed into the print statement and the text to be printed. If you want to print single quotes ( ' ' ) in your text you can do this by enclosing the text with double quotes ( \" \" ) or vice versa. Python does not care if you use single or double quotes to enclose your strings as long as you are consistent. # string_quotes.py print(\"This is:\") print(\"a string with 'double' quotes enclosing it but 'single quotes' inside it.\") print('a string with \"single\" quotes enclosing it but \"double quotes\" inside it.') print(\"This will cause an error because I am mixing \"double\" and'single' quotes.\") This is what should happen $ python string_quotes.py File \"string_quotes.py\", line 6 print(\"This will cause an error in Python because I am mixing \"double\" quotes with 'single' quotes.\") ^ SyntaxError: invalid syntax $ If we comment out the last line we will get: # string_quotes.py print(\"This is:\") print(\"a string with 'double' quotes enclosing it but 'single quotes' inside it.\") print('a string with \"single\" quotes enclosing it but \"double quotes\" inside it.') #print(\"This will cause an error because I am mixing \"double\" and'single' quotes.\") $ python string_quotes.py This is a string with 'double' quotes enclosing it but 'single quotes' inside it. This is a string with \"single\" quotes enclosing it but \"double quotes\" inside it. $ When ever you make a string by using quotes always remember to be consistent with your use of single and double quotes or you will run into problems. Advanced Mastery Look up strings as they relate to computers. How are strings represented in computer language? Previous: 05-Comments | Table of Contents | Next: 07-Escape Characters","title":"6. Strings and the Print Function"},{"location":"06-Strings-and-the-Print-Function/#6-strings-and-the-print-function","text":"","title":"6 - Strings and the print function"},{"location":"06-Strings-and-the-Print-Function/#the-print-function","text":"Lets talk about the print statement or as it is more correctly called, the print function. \"print\" is what is known as a built-in function in Python. Let's get some terminology out of the way before moving on: Function : A chunk of code that you can reuse multiple times with a single line of code. We will learn a lot more about functions later on and you will even build your own. But for now, just understand the following: There is some chunk of code labeled 'print' out there in the Python ether When you write print(stuff) in your code you are telling the computer, \"ACTIVATE THAT CHUNK OF CODE LABELED 'print'!\" The chunk of code then comes alive and says, \"Okay! My job is to write the stuff between the parentheses in the terminal window!\" The chunk of code does just that and then becomes dormant awaiting the next time it is called to action. When we talk about functions you will see that they have things (such as stuff above) between the parentheses. Sometimes these things are in a comma-separated list. These things between the parentheses are called arguments . For now, we have just one argument being fed to the print function and that is simply the text you want printed out to the screen.","title":"The print function"},{"location":"06-Strings-and-the-Print-Function/#strings","text":"You may have noticed that the text inside the parentheses is also between single or double quotes. It may not be clear why this is. In Python, putting text inside quotes designates it as a string. String : a sequence of characters that is generally treated as non-code text The quotes are necessary to differentiate between code being fed into the print statement and the text to be printed. If you want to print single quotes ( ' ' ) in your text you can do this by enclosing the text with double quotes ( \" \" ) or vice versa. Python does not care if you use single or double quotes to enclose your strings as long as you are consistent. # string_quotes.py print(\"This is:\") print(\"a string with 'double' quotes enclosing it but 'single quotes' inside it.\") print('a string with \"single\" quotes enclosing it but \"double quotes\" inside it.') print(\"This will cause an error because I am mixing \"double\" and'single' quotes.\") This is what should happen $ python string_quotes.py File \"string_quotes.py\", line 6 print(\"This will cause an error in Python because I am mixing \"double\" quotes with 'single' quotes.\") ^ SyntaxError: invalid syntax $ If we comment out the last line we will get: # string_quotes.py print(\"This is:\") print(\"a string with 'double' quotes enclosing it but 'single quotes' inside it.\") print('a string with \"single\" quotes enclosing it but \"double quotes\" inside it.') #print(\"This will cause an error because I am mixing \"double\" and'single' quotes.\") $ python string_quotes.py This is a string with 'double' quotes enclosing it but 'single quotes' inside it. This is a string with \"single\" quotes enclosing it but \"double quotes\" inside it. $ When ever you make a string by using quotes always remember to be consistent with your use of single and double quotes or you will run into problems.","title":"Strings"},{"location":"06-Strings-and-the-Print-Function/#advanced-mastery","text":"Look up strings as they relate to computers. How are strings represented in computer language? Previous: 05-Comments | Table of Contents | Next: 07-Escape Characters","title":"Advanced Mastery"},{"location":"07-Escape-Characters/","text":"Previous: 06-Strings and the Print Function | Table of Contents | Next: 08-Formatted Strings 7 - Escape Characters You may ask \"What do I do if I need a string to have a mixture of double and single quotes?\" For example: John's character says, \"I'd like to buy some cheese.\" This is where escape characters come in handy. An escape character is a text character that can be represented by a backslash followed by a character or series of characters (e.g. \\t , \\n , \\u03b7 ). Escape characters make possible the mixing of single and double quotes (among many other things) as you will see in this next exercise. Now go back to your text editor and write the following code (again, do NOT copy-paste it). Notice the use of escape characters and try to figure out what each one does. # esc_chars.py # here is an example of the use of escape characters # Both of lines do the same thing # Why might you prefer one over the other? print(\"John's character says, \\\"I'd like to buy some cheese.\\\"\") print('John\\'s character says, \"I\\'d like to buy some cheese.\"') # here are some more escape character examples # notice what all the other escape characters do print(\"\\nThere once was an old man from Peru\") print(\"who dreamed he was eating his shoe.\") print(\"\\tHe woke up in fright,\") print(\"\\tin the middle of the night,\") print(\"and found it was perfectly true!\\n\\n\") # here are a few more new characters and examples print(\"\\t\\tI have tabbed over here!\") print(\"I am about to do a carriage return!\\rI did it!--\") print(\"How do you print a backslash? \\\\ like that!\") print(\"\\nI just made a new line! Now I will do another!\\n\") print(\"Here is a greek eta character: \\u03b7\") Here is what should happen $ python esc_chars.py John's character says, \"I'd like to buy some cheese.\" John's character says, \"I'd like to buy some cheese.\" There once was an old man from Peru who dreamed he was eating his shoe. He woke up in fright, in the middle of the night, and found it was perfectly true! I have tabbed over here! I did it!--to do a carriage return! How do you print a backslash? \\ like that! I just made a new line! Now I will do another! Here is a funny character: \u03b7 If on any of these exercises you do not see the output appear exactly as you saw it in the book, go back and fix it until it does. What is happening here? Let's examine all the escape characters introduced in this exercise: \\\" and \\\" : These are quote escapes and tell python to treat them as part of the text of the string rather than the beginning or ending of a string. Hence, both times you wrote the mixed quote sentence you could enclose the text with either \" or ' and print the same string depending on which escapes you used. \\n : This is a newline character and printing it makes a newline on which you can continue to write text. The print statement automatically adds this character to the end of every string. In some languages like C you must explicitly put in this character yourself. \\t : This is the tab character and printing it inserts 4 or 8 spaces depending on the system you are using. \\r : This is the carriage return character and it returns the print cursor to the beginning of the line. Notice how the first part of the printed line is now overwritten with the \"I did it!\" part. \\\\ : This is the backslash character and tells python to treat this character as a single backslash. As you can see, the only thing that came out of the print statement was a backslash\" \\u03b7 : This is called a \"Unicode escape character\". It follows the format \\uhhhh where hhhh references the 4-character hexadecimal code that corresponds to what was printed (in this case, $\\eta$). Using that 4-character hexadecimal code you can express over 65000 characters. If you want to know a character's code simply search on the internet for \"Unicode CHARACTER NAME \". (e.g. \"Unicode eta\" for $ \\eta $) These are not all the potential escape characters. You can learn more about these by doing the exercises under \"Hone your skills\". For now, understand that these are only a small part of python's printing and display capabilities but what we have covered here are the most useful and used most often in programming. Hone Your Skills Look up what hexadecimal is. Why is it used? Using the Internet and experimenting in Python, figure out what the following escape characters do. \\a \\b \\f \\N{char} \\o** \\x** Look up how to make Python print $\\epsilon = \\gamma c^2$ (those are the greek letters epsilon ($\\epsilon$) and gamma ($\\gamma\u200b$) and the equation reads: \"epsilon equals gamma c squared\") Advanced Mastery Make Python print out the Navier-Stokes Equations for a 3-D system in Cartesian coordinates formatted like a normal math equation using escape sequences and print statements. Previous: 06-Strings and the Print Function | Table of Contents | Next: 08-Formatted Strings","title":"7. Escape Characters"},{"location":"07-Escape-Characters/#7-escape-characters","text":"You may ask \"What do I do if I need a string to have a mixture of double and single quotes?\" For example: John's character says, \"I'd like to buy some cheese.\" This is where escape characters come in handy. An escape character is a text character that can be represented by a backslash followed by a character or series of characters (e.g. \\t , \\n , \\u03b7 ). Escape characters make possible the mixing of single and double quotes (among many other things) as you will see in this next exercise. Now go back to your text editor and write the following code (again, do NOT copy-paste it). Notice the use of escape characters and try to figure out what each one does. # esc_chars.py # here is an example of the use of escape characters # Both of lines do the same thing # Why might you prefer one over the other? print(\"John's character says, \\\"I'd like to buy some cheese.\\\"\") print('John\\'s character says, \"I\\'d like to buy some cheese.\"') # here are some more escape character examples # notice what all the other escape characters do print(\"\\nThere once was an old man from Peru\") print(\"who dreamed he was eating his shoe.\") print(\"\\tHe woke up in fright,\") print(\"\\tin the middle of the night,\") print(\"and found it was perfectly true!\\n\\n\") # here are a few more new characters and examples print(\"\\t\\tI have tabbed over here!\") print(\"I am about to do a carriage return!\\rI did it!--\") print(\"How do you print a backslash? \\\\ like that!\") print(\"\\nI just made a new line! Now I will do another!\\n\") print(\"Here is a greek eta character: \\u03b7\") Here is what should happen $ python esc_chars.py John's character says, \"I'd like to buy some cheese.\" John's character says, \"I'd like to buy some cheese.\" There once was an old man from Peru who dreamed he was eating his shoe. He woke up in fright, in the middle of the night, and found it was perfectly true! I have tabbed over here! I did it!--to do a carriage return! How do you print a backslash? \\ like that! I just made a new line! Now I will do another! Here is a funny character: \u03b7 If on any of these exercises you do not see the output appear exactly as you saw it in the book, go back and fix it until it does. What is happening here? Let's examine all the escape characters introduced in this exercise: \\\" and \\\" : These are quote escapes and tell python to treat them as part of the text of the string rather than the beginning or ending of a string. Hence, both times you wrote the mixed quote sentence you could enclose the text with either \" or ' and print the same string depending on which escapes you used. \\n : This is a newline character and printing it makes a newline on which you can continue to write text. The print statement automatically adds this character to the end of every string. In some languages like C you must explicitly put in this character yourself. \\t : This is the tab character and printing it inserts 4 or 8 spaces depending on the system you are using. \\r : This is the carriage return character and it returns the print cursor to the beginning of the line. Notice how the first part of the printed line is now overwritten with the \"I did it!\" part. \\\\ : This is the backslash character and tells python to treat this character as a single backslash. As you can see, the only thing that came out of the print statement was a backslash\" \\u03b7 : This is called a \"Unicode escape character\". It follows the format \\uhhhh where hhhh references the 4-character hexadecimal code that corresponds to what was printed (in this case, $\\eta$). Using that 4-character hexadecimal code you can express over 65000 characters. If you want to know a character's code simply search on the internet for \"Unicode CHARACTER NAME \". (e.g. \"Unicode eta\" for $ \\eta $) These are not all the potential escape characters. You can learn more about these by doing the exercises under \"Hone your skills\". For now, understand that these are only a small part of python's printing and display capabilities but what we have covered here are the most useful and used most often in programming.","title":"7 - Escape Characters"},{"location":"07-Escape-Characters/#hone-your-skills","text":"Look up what hexadecimal is. Why is it used? Using the Internet and experimenting in Python, figure out what the following escape characters do. \\a \\b \\f \\N{char} \\o** \\x** Look up how to make Python print $\\epsilon = \\gamma c^2$ (those are the greek letters epsilon ($\\epsilon$) and gamma ($\\gamma\u200b$) and the equation reads: \"epsilon equals gamma c squared\")","title":"Hone Your Skills"},{"location":"07-Escape-Characters/#advanced-mastery","text":"Make Python print out the Navier-Stokes Equations for a 3-D system in Cartesian coordinates formatted like a normal math equation using escape sequences and print statements. Previous: 06-Strings and the Print Function | Table of Contents | Next: 08-Formatted Strings","title":"Advanced Mastery"},{"location":"08-Formatted-Strings/","text":"Previous: 07-Escape Characters | Table of Contents | Next: 09-Variables and Memory 8 - Formatted Strings As you use the print function there will be times when you want to \"fill in the blank\" and you can do this with format statements. Also we will introduce a few more features in addition to these. # format_strings.py # We can print a comma-separated list print(\"How much will this cost?\", 23.00, \"dollars\") # this is more readable with a .format statement print(\"How much will this cost? {} dollars.\".format(23.0)) # The benefits of formatting become more apparent with more blanks to fill in. print(\"Prices for cheese: ${}/1 oz, ${}/5 oz, ${}/10 oz\".format(1.23, 5.35, 9.84)) # Change the formatting order with indices in the braces print(\"Would you like {2}, {0} or {1}?\".format(\"Brie\", \"Gouda\", \"Cheddar\")) # line up numbers and define decimal places with format codes print(\"\"\" Prices for cheese: ${:5.2f}/ 1 oz ${:5.2f}/ 5 oz ${:5.2f}/10 oz \"\"\".format(1.23232, 5.3593, 9.84655)) Here is what should happen $ python format_strings.py How much will this cost? 23.0 dollars How much will this cost? 23.0 dollars. Prices for cheese: $1.23/1 oz, $5.35/5 oz, $9.84/10 oz Would you like 'Cheddar', Brie or Gouda? Prices for cheese: $ 1.23/ 1 oz $ 5.36/ 5 oz $ 9.85/10 oz $ Formatting and the .format() method We must understand a few things before understanding this code. Print statements can be called on multiple strings separated by commas. As seen in line 4 that reads print(\"How much will this cost?\", 23.00, \"dollars\") when we put a list of comma-separated strings in a print function, the print function prints them out with a space instead of a new line between them. We have introduced a powerful feature in the .format statement. The .format statement refers to special kind of code called a 'method'. A method is like a function, such as the print function, but in this case it is tied to whatever is on the left side of the dot ( . ). In this case, it only acts on the string to which it is tied. We first see this in line 7 which reads: print(\"How much will this cost? {} dollars.\".format(23.0)) To understand this process, here is what .format() does to the string from which it is called: Scans the string looking for braces ( {} ) in the text If there is text between the braces it interprets the text as format instructions. It then looks at what is given between the parentheses ( .format(\"Text\") ) and puts that text in place of the braces formatting it as per the format instructions. Format commands Let's look at each example of a .format statement one by one: print(\"Prices for cheese: ${}/1 oz, ${}/5 oz, ${}/10 oz\".format(1.23, 5.35, 9.84)) Each pair of braces is replaced by each value, in order, as they appear in the comma-separated list inside the parentheses. This is the default behavior if no format instructions in the braces are given. This is executed in the same way on line 24. If you notice in the case of line 24, there are numbers in the braces. Each of these is an index number that counts from 0. (NOTE: In Python, counting always begins with 0. I.E. 0, 1, 2, ... instead of 1, 2, 3, ... . We will explain more about this when we discuss lists and iterables.) This means that when you write the following \"{1}\".format(\"First\", \"Second\") you are commanding .format(\"First\", \"Second\") to replace that text with \"Second\" . If the string were instead \"{0}\" the text would be replace by \"First\" print(\"Would you like {2}, {0} or {1}?\".format(\"Brie\", \"Gouda\", \"Cheddar\")) As above you are putting indexes in the format braces. But what we see here is that you can put them in any order you want and even repeat them if you wish. (See \"Hone your Skills\" for an example of repetition.) python print(\"\"\" Prices for cheese: ${:5.2f}/ 1 oz ${:5.2f}/ 5 oz ${:5.2f}/10 oz \"\"\".format(1.23232, 5.3593, 9.84655)) Here we see that we are using format commands to organize data. The part that says {:5.2f} means to allow at least 5 spaces for the number to exist (fill any unused space with whitespace), round the number to 2 decimal places, and treat the number as a floating point number f . We have omitted the index of the values for simplicity but they would be written on the left side of the colon (e.g. {0:5.2f} ). There are other formatting commands other than this but this is a good start to using formatting that will come up again and again. To review: # formatting cheat sheet print(\"{<format index or identifier>:<format commands>}\".format(arguments)) Hone Your Skills print(\"No. \" * 3) print(\"No.\",\"No.\",\"No.\") print(\"{0} {0} {0}\".format(\"No.\")) print(\"{} {} {}\".format(\"No.\",\"No.\",\"No.\")) print(\"{0} \".format(\"No.\") * 3) Write the above code in a separate Python file and run it. As you will see, all 5 lines apparently do the same thing. Which way is the best way to do that and why? What are some potential advantages and drawbacks to each? Try rewriting lines of code from format_strings.py to make it so all the cheeses are aligned vertically. How can you do this with what we learned in this exercise? Look in the Python documentation for other format commands. Experiment with these and learn how to use them. Previous: 07-Escape Characters | Table of Contents | Next: 09-Variables and Memory","title":"8. Formatted Strings"},{"location":"08-Formatted-Strings/#8-formatted-strings","text":"As you use the print function there will be times when you want to \"fill in the blank\" and you can do this with format statements. Also we will introduce a few more features in addition to these. # format_strings.py # We can print a comma-separated list print(\"How much will this cost?\", 23.00, \"dollars\") # this is more readable with a .format statement print(\"How much will this cost? {} dollars.\".format(23.0)) # The benefits of formatting become more apparent with more blanks to fill in. print(\"Prices for cheese: ${}/1 oz, ${}/5 oz, ${}/10 oz\".format(1.23, 5.35, 9.84)) # Change the formatting order with indices in the braces print(\"Would you like {2}, {0} or {1}?\".format(\"Brie\", \"Gouda\", \"Cheddar\")) # line up numbers and define decimal places with format codes print(\"\"\" Prices for cheese: ${:5.2f}/ 1 oz ${:5.2f}/ 5 oz ${:5.2f}/10 oz \"\"\".format(1.23232, 5.3593, 9.84655)) Here is what should happen $ python format_strings.py How much will this cost? 23.0 dollars How much will this cost? 23.0 dollars. Prices for cheese: $1.23/1 oz, $5.35/5 oz, $9.84/10 oz Would you like 'Cheddar', Brie or Gouda? Prices for cheese: $ 1.23/ 1 oz $ 5.36/ 5 oz $ 9.85/10 oz $","title":"8 - Formatted Strings"},{"location":"08-Formatted-Strings/#formatting-and-the-format-method","text":"We must understand a few things before understanding this code. Print statements can be called on multiple strings separated by commas. As seen in line 4 that reads print(\"How much will this cost?\", 23.00, \"dollars\") when we put a list of comma-separated strings in a print function, the print function prints them out with a space instead of a new line between them. We have introduced a powerful feature in the .format statement. The .format statement refers to special kind of code called a 'method'. A method is like a function, such as the print function, but in this case it is tied to whatever is on the left side of the dot ( . ). In this case, it only acts on the string to which it is tied. We first see this in line 7 which reads: print(\"How much will this cost? {} dollars.\".format(23.0)) To understand this process, here is what .format() does to the string from which it is called: Scans the string looking for braces ( {} ) in the text If there is text between the braces it interprets the text as format instructions. It then looks at what is given between the parentheses ( .format(\"Text\") ) and puts that text in place of the braces formatting it as per the format instructions.","title":"Formatting and the .format() method"},{"location":"08-Formatted-Strings/#format-commands","text":"Let's look at each example of a .format statement one by one: print(\"Prices for cheese: ${}/1 oz, ${}/5 oz, ${}/10 oz\".format(1.23, 5.35, 9.84)) Each pair of braces is replaced by each value, in order, as they appear in the comma-separated list inside the parentheses. This is the default behavior if no format instructions in the braces are given. This is executed in the same way on line 24. If you notice in the case of line 24, there are numbers in the braces. Each of these is an index number that counts from 0. (NOTE: In Python, counting always begins with 0. I.E. 0, 1, 2, ... instead of 1, 2, 3, ... . We will explain more about this when we discuss lists and iterables.) This means that when you write the following \"{1}\".format(\"First\", \"Second\") you are commanding .format(\"First\", \"Second\") to replace that text with \"Second\" . If the string were instead \"{0}\" the text would be replace by \"First\" print(\"Would you like {2}, {0} or {1}?\".format(\"Brie\", \"Gouda\", \"Cheddar\")) As above you are putting indexes in the format braces. But what we see here is that you can put them in any order you want and even repeat them if you wish. (See \"Hone your Skills\" for an example of repetition.) python print(\"\"\" Prices for cheese: ${:5.2f}/ 1 oz ${:5.2f}/ 5 oz ${:5.2f}/10 oz \"\"\".format(1.23232, 5.3593, 9.84655)) Here we see that we are using format commands to organize data. The part that says {:5.2f} means to allow at least 5 spaces for the number to exist (fill any unused space with whitespace), round the number to 2 decimal places, and treat the number as a floating point number f . We have omitted the index of the values for simplicity but they would be written on the left side of the colon (e.g. {0:5.2f} ). There are other formatting commands other than this but this is a good start to using formatting that will come up again and again. To review: # formatting cheat sheet print(\"{<format index or identifier>:<format commands>}\".format(arguments))","title":"Format commands"},{"location":"08-Formatted-Strings/#hone-your-skills","text":"print(\"No. \" * 3) print(\"No.\",\"No.\",\"No.\") print(\"{0} {0} {0}\".format(\"No.\")) print(\"{} {} {}\".format(\"No.\",\"No.\",\"No.\")) print(\"{0} \".format(\"No.\") * 3) Write the above code in a separate Python file and run it. As you will see, all 5 lines apparently do the same thing. Which way is the best way to do that and why? What are some potential advantages and drawbacks to each? Try rewriting lines of code from format_strings.py to make it so all the cheeses are aligned vertically. How can you do this with what we learned in this exercise? Look in the Python documentation for other format commands. Experiment with these and learn how to use them. Previous: 07-Escape Characters | Table of Contents | Next: 09-Variables and Memory","title":"Hone Your Skills"},{"location":"09-Variables-and-Memory/","text":"Previous: 08-Formatted Strings | Table of Contents | Next: 10-Better String Formatting 9 - Variables and Memory Now we will introduce some concepts that make Python far more powerful. You have the ability to store things in computer memory and the following exercise will demonstrate how to use it. # vars_and_mem.py # equals sign ( = ) is the assignment operator # it says: assign whatever is on the right # to the name on the left first_text = \"Here is some text!\" more_text = \"This is another string of text.\" print(\"{} {}\".format(first_text, more_text)) message = \"You can print numbers too! Here are some\" number_1 = 1 number_2 = 23 number_34 = 25.34 print(\"{} {} {} {}\".format(message, number_1, number_2, number_34)) # now lets do the same thing but assign these names to new values! message = \"Here are some more numbers\" number_1 = 34.1 number_2 = 203 number_34 = 3.14159265 print(\"{} {} {} {}\".format(message, number_1, number_2, number_34)) Here is what should happen $ python vars_and_mem.py Here is some text! This is another string of text. You can print numbers too! Here are some 1 23 25.34 Here are some more numbers 34.1 203 3.14159265 $ You can see that each name that is assigned a value can be used multiple times and refers to the same value that gets stored in memory. This name is called a variable . Here is how the computer works with variables: Computer Bare Essentials I want to begin here by saying a few things about computers that hopefully will help you understand them better. Computers, including those that that run everything from your desktop to your phone to your car, basically only do 3 things: Store numbers as 1s and 0s in different places Move those 1s and 0s between the different storage places Combine those 1s and 0s mathematically (i.e. addition and subtraction) Of course, computers can do these things at blinding speeds and can be endlessly combined to do all sorts of complex things but these three basics make up all of computing. The programs we have been writing so far do just those things but the details of how this is done is hidden from you but don't be fooled! Nothing more than those three things is happening at any time. Storing Information One of the most important things you can learn is how memory works on a computer. Storing 1s and 0s is the first thing that a computer must be able to do in order to function. For now the most important things you need to understand are these: There are three basic parts to the computer that we will interact with constantly. They are: The CPU The RAM or volatile memory The hard drive or persistent memory CPU stands for central processing unit. Every instruction you write gets executed there. RAM stands for Random Access Memory. You will put information relevant to your programs there as your program runs. As soon as your program stops running, all the information you have in RAM gets erased. The hard drive is like the RAM except the information you write there stays there until you actively erase it. We will be doing more with the hard drive later The RAM is where your variables are stored. Without oversimplifying, you can think of the RAM as a large set of P.O. Boxes in a vast post office. Each P.O. box has a number associated with it called an address. When you run code like x = 23 you are executing the following: Find an appropriate, empty 'box' and write 23 in that box. Get the address of the 'box' and associate it with the name 'x'. (This erases any previous associations x may have had before.) Anytime x is referenced after that command, the computer looks up the address associated with 'x' and goes directly to the 'box' with that address and replaces 'x' with whatever is in that 'box'. More Practice The python interpreter will illustrate this better. Go to your terminal and enter python to start the interpreter. $ python Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Run the following commands: >>> x = 23 >>> type(x) <class 'int'> >>> id(x) 140737371887328 >>> x 23 >>> exit() type , id and exit are other built-in functions like print that provide some useful information about x . type spits out the type of variable between its parentheses. id spits out the address of the variable in the RAM. This will be different for every time you start the Python interpreter. Entering the name of the variable simply prints its value and exit() simply exits the program. Naming Variables As a programmer you will have to give names to your variables. Within certain rules you can make up any name you want but the following guides will help you make smart choices about how you name variables. Naming Rules in Python Python follows some rules on what a valid variable name can be. The rules are as follows: Names must start with a letter or and underscore _ (e.g. Spam, eggs, _cheese) Names must only contain numbers, letters or underscores (i.e. spaces and punctuation are not allowed) Names are case sensitive (i.e. Spam, spAm and spam are three different names) Names cannot be one of the 35 reserved words in Python. These are listed in the table below. (As a note should you feel the need to use one of these names, you can turn it into a valid variable name by adding leading or trailing underscores e.g. _False or False__ or a trailing number e.g. False1 ) Reserved Words False None True and as assert async await break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield Naming Conventions and Guidelines Within the limits of these rules, you can call your variables any name you want and make them as long or as short as you want. However, there are some conventions you should stick to you make your coding better. The following conventions will help make your code easier to write and fix when something goes wrong. (And trust me, something always goes wrong.): Use lower case and underscores There are two common ways to name a variable. For an example we will consider a variable that will bear a name that can be read as \"black knight\". The first way is lower case with underscores for spaces: black_knight . The second is often called \"camel case\": BlackKnight . Obviously you can use all caps ( BLACKKNIGHT ), no spaces ( blackknight ), some form abbreviation ( blk_knt ) or any combination of these. However, the lower case with underscores and camel case are the most common for general use variables. When writing Python especially as you are learning, stick to the lower case with underscores. For what we will be doing this will help your code be more readable and clear to you and anyone else reading it. Understand however, that this is not a hard and fast rule and should be broken if there is a good reason to do so. We will break this rule later on as we explore more features. Avoid names that conflict with existing names When naming you will find that, outside the 35 key words above, when you define a name, it overrides any variable connected to that name before. Therefore the following code: python print = 2 print(\"cheese\") will not work because you have changed the meaning of print from that of a function that writes things on the screen to an integer with a value of 2. Try this out for yourself. When naming variables always be careful to not use names that are already being used for another purpose. Write descriptive names One time while working on someone else's code, I came across a line of code that looked something like this (I have changed it for privacy reasons but the lesson still stands): python val = a*cav + b*wtmcls + c*hcpv + d As a chemical engineer, I had some context but could not figure out what this was saying. Initially I could infer the following: This was a mathematical statement equivalent to $val = a \\cdot cav + b \\cdot wtmcls + c\\cdot hcpv + d$ a, b, c and d were constants related to all the other variables and if I could figure out the other 4 variables I could easily figure out a, b, c and d val was short for 'value'. What value? I couldn't figure it out. The other 3 variables? I had no idea what they were. After weeks of digging I finally figured out what each of these variables were. val was a predicted value of viscosity cav stood for 'compound average value' wtmcls was the number of 'water molecules' in the compound hcpv was the 'heat capacity value' for that compound Now you don't need to understand what this does exactly but consider how much easier it would have been if the code had been written like this: python viscosity_value = a*compound_avg_val + b*h2o_molecules + c*heat_capacity + d I have done this in my own code. I have worked on code and been lazy with naming. I came back to my code later and found I had to rewrite everything because I couldn't understand what I did before. This will take practice but it behooves you to write your variable names (and the rest of your code for that matter) descriptively to avoid issues like the one above. \u200b Help your reader understand the code without comments Ideally you want to write code clearly enough that it is apparent what the code does without needing comments explaining it. Comments are important and I do not want to diminish their importance but this clear writing is better than commenting. Up to now what your code does should be obvious to anyone that can read Python without any comments. However, as we go through the next several exercises think of ways you could name your variables so your code is more clear. Any good programmer knows that the majority of the time we spend coding is actually spent reading and not writing. Python makes it easy for you to write readable code and the first step is write good variable names. Hone Your Skills Go to the Python Built-in Function page and experiment with as many functions in the Python interpreter as you can. What does each of these built in functions do? Using the addition operator + , write a program that adds two numbers together and then print the result. (Use three descriptively named variables.) Experiment with different names of variables in vars_and_mem.py . How can you make your variables more clear to those reading your code? Advanced Mastery Use the internet to answer the following questions: What is binary? How are numbers represented as 1s and 0s? How are characters represented as 1s and 0s? How do computers do addition and subtraction using binary math? What is 2's compliment? Why is it used? Previous: 08-Formatted Strings | Table of Contents | Next: 10-Better String Formatting","title":"9. Variables and Memory"},{"location":"09-Variables-and-Memory/#9-variables-and-memory","text":"Now we will introduce some concepts that make Python far more powerful. You have the ability to store things in computer memory and the following exercise will demonstrate how to use it. # vars_and_mem.py # equals sign ( = ) is the assignment operator # it says: assign whatever is on the right # to the name on the left first_text = \"Here is some text!\" more_text = \"This is another string of text.\" print(\"{} {}\".format(first_text, more_text)) message = \"You can print numbers too! Here are some\" number_1 = 1 number_2 = 23 number_34 = 25.34 print(\"{} {} {} {}\".format(message, number_1, number_2, number_34)) # now lets do the same thing but assign these names to new values! message = \"Here are some more numbers\" number_1 = 34.1 number_2 = 203 number_34 = 3.14159265 print(\"{} {} {} {}\".format(message, number_1, number_2, number_34)) Here is what should happen $ python vars_and_mem.py Here is some text! This is another string of text. You can print numbers too! Here are some 1 23 25.34 Here are some more numbers 34.1 203 3.14159265 $ You can see that each name that is assigned a value can be used multiple times and refers to the same value that gets stored in memory. This name is called a variable . Here is how the computer works with variables:","title":"9 - Variables and Memory"},{"location":"09-Variables-and-Memory/#computer-bare-essentials","text":"I want to begin here by saying a few things about computers that hopefully will help you understand them better. Computers, including those that that run everything from your desktop to your phone to your car, basically only do 3 things: Store numbers as 1s and 0s in different places Move those 1s and 0s between the different storage places Combine those 1s and 0s mathematically (i.e. addition and subtraction) Of course, computers can do these things at blinding speeds and can be endlessly combined to do all sorts of complex things but these three basics make up all of computing. The programs we have been writing so far do just those things but the details of how this is done is hidden from you but don't be fooled! Nothing more than those three things is happening at any time.","title":"Computer Bare Essentials"},{"location":"09-Variables-and-Memory/#storing-information","text":"One of the most important things you can learn is how memory works on a computer. Storing 1s and 0s is the first thing that a computer must be able to do in order to function. For now the most important things you need to understand are these: There are three basic parts to the computer that we will interact with constantly. They are: The CPU The RAM or volatile memory The hard drive or persistent memory CPU stands for central processing unit. Every instruction you write gets executed there. RAM stands for Random Access Memory. You will put information relevant to your programs there as your program runs. As soon as your program stops running, all the information you have in RAM gets erased. The hard drive is like the RAM except the information you write there stays there until you actively erase it. We will be doing more with the hard drive later The RAM is where your variables are stored. Without oversimplifying, you can think of the RAM as a large set of P.O. Boxes in a vast post office. Each P.O. box has a number associated with it called an address. When you run code like x = 23 you are executing the following: Find an appropriate, empty 'box' and write 23 in that box. Get the address of the 'box' and associate it with the name 'x'. (This erases any previous associations x may have had before.) Anytime x is referenced after that command, the computer looks up the address associated with 'x' and goes directly to the 'box' with that address and replaces 'x' with whatever is in that 'box'.","title":"Storing Information"},{"location":"09-Variables-and-Memory/#more-practice","text":"The python interpreter will illustrate this better. Go to your terminal and enter python to start the interpreter. $ python Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> Run the following commands: >>> x = 23 >>> type(x) <class 'int'> >>> id(x) 140737371887328 >>> x 23 >>> exit() type , id and exit are other built-in functions like print that provide some useful information about x . type spits out the type of variable between its parentheses. id spits out the address of the variable in the RAM. This will be different for every time you start the Python interpreter. Entering the name of the variable simply prints its value and exit() simply exits the program.","title":"More Practice"},{"location":"09-Variables-and-Memory/#naming-variables","text":"As a programmer you will have to give names to your variables. Within certain rules you can make up any name you want but the following guides will help you make smart choices about how you name variables.","title":"Naming Variables"},{"location":"09-Variables-and-Memory/#naming-rules-in-python","text":"Python follows some rules on what a valid variable name can be. The rules are as follows: Names must start with a letter or and underscore _ (e.g. Spam, eggs, _cheese) Names must only contain numbers, letters or underscores (i.e. spaces and punctuation are not allowed) Names are case sensitive (i.e. Spam, spAm and spam are three different names) Names cannot be one of the 35 reserved words in Python. These are listed in the table below. (As a note should you feel the need to use one of these names, you can turn it into a valid variable name by adding leading or trailing underscores e.g. _False or False__ or a trailing number e.g. False1 ) Reserved Words False None True and as assert async await break class continue def del elif else except finally for from global if import in is lambda nonlocal not or pass raise return try while with yield","title":"Naming Rules in Python"},{"location":"09-Variables-and-Memory/#naming-conventions-and-guidelines","text":"Within the limits of these rules, you can call your variables any name you want and make them as long or as short as you want. However, there are some conventions you should stick to you make your coding better. The following conventions will help make your code easier to write and fix when something goes wrong. (And trust me, something always goes wrong.): Use lower case and underscores There are two common ways to name a variable. For an example we will consider a variable that will bear a name that can be read as \"black knight\". The first way is lower case with underscores for spaces: black_knight . The second is often called \"camel case\": BlackKnight . Obviously you can use all caps ( BLACKKNIGHT ), no spaces ( blackknight ), some form abbreviation ( blk_knt ) or any combination of these. However, the lower case with underscores and camel case are the most common for general use variables. When writing Python especially as you are learning, stick to the lower case with underscores. For what we will be doing this will help your code be more readable and clear to you and anyone else reading it. Understand however, that this is not a hard and fast rule and should be broken if there is a good reason to do so. We will break this rule later on as we explore more features. Avoid names that conflict with existing names When naming you will find that, outside the 35 key words above, when you define a name, it overrides any variable connected to that name before. Therefore the following code: python print = 2 print(\"cheese\") will not work because you have changed the meaning of print from that of a function that writes things on the screen to an integer with a value of 2. Try this out for yourself. When naming variables always be careful to not use names that are already being used for another purpose. Write descriptive names One time while working on someone else's code, I came across a line of code that looked something like this (I have changed it for privacy reasons but the lesson still stands): python val = a*cav + b*wtmcls + c*hcpv + d As a chemical engineer, I had some context but could not figure out what this was saying. Initially I could infer the following: This was a mathematical statement equivalent to $val = a \\cdot cav + b \\cdot wtmcls + c\\cdot hcpv + d$ a, b, c and d were constants related to all the other variables and if I could figure out the other 4 variables I could easily figure out a, b, c and d val was short for 'value'. What value? I couldn't figure it out. The other 3 variables? I had no idea what they were. After weeks of digging I finally figured out what each of these variables were. val was a predicted value of viscosity cav stood for 'compound average value' wtmcls was the number of 'water molecules' in the compound hcpv was the 'heat capacity value' for that compound Now you don't need to understand what this does exactly but consider how much easier it would have been if the code had been written like this: python viscosity_value = a*compound_avg_val + b*h2o_molecules + c*heat_capacity + d I have done this in my own code. I have worked on code and been lazy with naming. I came back to my code later and found I had to rewrite everything because I couldn't understand what I did before. This will take practice but it behooves you to write your variable names (and the rest of your code for that matter) descriptively to avoid issues like the one above. \u200b Help your reader understand the code without comments Ideally you want to write code clearly enough that it is apparent what the code does without needing comments explaining it. Comments are important and I do not want to diminish their importance but this clear writing is better than commenting. Up to now what your code does should be obvious to anyone that can read Python without any comments. However, as we go through the next several exercises think of ways you could name your variables so your code is more clear. Any good programmer knows that the majority of the time we spend coding is actually spent reading and not writing. Python makes it easy for you to write readable code and the first step is write good variable names.","title":"Naming Conventions and Guidelines"},{"location":"09-Variables-and-Memory/#hone-your-skills","text":"Go to the Python Built-in Function page and experiment with as many functions in the Python interpreter as you can. What does each of these built in functions do? Using the addition operator + , write a program that adds two numbers together and then print the result. (Use three descriptively named variables.) Experiment with different names of variables in vars_and_mem.py . How can you make your variables more clear to those reading your code?","title":"Hone Your Skills"},{"location":"09-Variables-and-Memory/#advanced-mastery","text":"Use the internet to answer the following questions: What is binary? How are numbers represented as 1s and 0s? How are characters represented as 1s and 0s? How do computers do addition and subtraction using binary math? What is 2's compliment? Why is it used? Previous: 08-Formatted Strings | Table of Contents | Next: 10-Better String Formatting","title":"Advanced Mastery"},{"location":"10-Better-String-Formatting/","text":"Previous: 09-Variables and Memory | Table of Contents | Next: 11-Input and Output 10 - Better String Formatting This is a short lesson in which we will learn a \"trick\" that will make all that formatting a lot more efficient using variables. # adv_format.py # let's make some variables pickle_brand = \"Fantastic\" number_of_pickles = 7 average_pickle_weight = 2.34758475 # oz # now lets print those variables in a string pickle_info = \"\"\"I have a jar of {} brand pickles. In the jar, there are {} pickles with an average weight of {} ounces.\\n\"\"\".format( pickle_brand, number_of_pickles, average_pickle_weight) print(pickle_info) # lets redefine pickle_info in a better way pickle_info = f\"\"\"I have a jar of {pickle_brand} brand pickles. In the jar, there are {number_of_pickles} pickles with an average weight of {average_pickle_weight:.3f} ounces.\\n\"\"\" print(pickle_info) # lets take a bunch of numbers below random_number_1 = 7583 # integer random_number_2 = -123 # negative integer random_number_3 = 23.0 # float number random_number_4 = 4838495.23221 # bigger float number random_number_5 = 483.234 # medium float number random_number_6 = 1293.0 # round float number # now let's print them print(\"Printing the numbers without any formatting.\") print(f\"{random_number_1}\") print(f\"{random_number_2}\") print(f\"{random_number_3}\") print(f\"{random_number_4}\") print(f\"{random_number_5}\") print(f\"{random_number_6}\") print(\"\") print(\"Notice how this can be hard to read.\") print(\"Let's try printing them while up the decimals.\") print(f\"{random_number_1:7d}\") print(f\"{random_number_2:7d}\") print(f\"{random_number_3:11.3f}\") print(f\"{random_number_4:11.3f}\") print(f\"{random_number_5:11.3f}\") print(f\"{random_number_6:11.3f}\") Here is what should happen $ python adv_format.py I have a jar of Fantastic brand pickles. In the jar, there are 7 pickles with an average weight of 2.34758475 ounces. I have a jar of Fantastic brand pickles. In the jar, there are 7 pickles with an average weight of 2.348 ounces. Printing the numbers without any formatting. 7583 -123 23.0 4838495.23221 483.234 1293.0 Notice how this can be hard to read. Let's try printing them while up the decimals. 7583 -123 23.000 4838495.232 483.234 1293.000 $ What is happening here? lets go through each new concept one-by-one: Lines 8-14: You can have a indented new line in python anytime you have a comma or a open parenthesis also you can assign a multi-line string to a variable in this way. You'll notice this was many lines of code to get this to do what we want. And Python has a better way. Lines 19-21 and 33- 50: Notice the f in front of the string. This is known as a \"literal string interpolation\" and is explained below. Lines 43-50 and line 21: These are format instructions. d is the symbol that corresponds to formatting an integer. f is the symbol for floats. The number before the decimal is the amount of space padding. The number after the decimal is the number of decimal places to show in the number. There are more instructions that can be passed. See \"Hone your skills\" for more on this subject. The important thing here is that for numbers, changing the padding and decimal places can align the numbers' decimals in an easy-to-read fashion. Literal String Interpolation The f that we put in front of a string is referred to technically as a \"literal string interpolation\". Colloquially, we call it an \"f-string\". It tells Python to automatically call format on the string using the variable names in the braces. The colon and the text following it tells Python to accept format codes that we explored before. This feature was added relatively recently and is now the standard way of string formatting. Hone Your Skills Look up what a Python PEP is and specifically look up PEP 498. Why do PEPs exist? f is not the only thing that we can put at the beginning of a string to make it do something different. What happens when you put the following letters in front of a string? (Google these if you can't figure it out.) r b u Now you can make a form with variables that will print out information. Make a form that gives the name, age and occupation of whatever you set those variables The format instructions are detailed here in the Python documentation. Learn what each of these things do and experiment with them. Experiment with the format instructions. Can you align all the numbers in different ways? Previous: 09-Variables and Memory | Table of Contents | Next: 11-Input and Output","title":"10. Better String Formatting"},{"location":"10-Better-String-Formatting/#10-better-string-formatting","text":"This is a short lesson in which we will learn a \"trick\" that will make all that formatting a lot more efficient using variables. # adv_format.py # let's make some variables pickle_brand = \"Fantastic\" number_of_pickles = 7 average_pickle_weight = 2.34758475 # oz # now lets print those variables in a string pickle_info = \"\"\"I have a jar of {} brand pickles. In the jar, there are {} pickles with an average weight of {} ounces.\\n\"\"\".format( pickle_brand, number_of_pickles, average_pickle_weight) print(pickle_info) # lets redefine pickle_info in a better way pickle_info = f\"\"\"I have a jar of {pickle_brand} brand pickles. In the jar, there are {number_of_pickles} pickles with an average weight of {average_pickle_weight:.3f} ounces.\\n\"\"\" print(pickle_info) # lets take a bunch of numbers below random_number_1 = 7583 # integer random_number_2 = -123 # negative integer random_number_3 = 23.0 # float number random_number_4 = 4838495.23221 # bigger float number random_number_5 = 483.234 # medium float number random_number_6 = 1293.0 # round float number # now let's print them print(\"Printing the numbers without any formatting.\") print(f\"{random_number_1}\") print(f\"{random_number_2}\") print(f\"{random_number_3}\") print(f\"{random_number_4}\") print(f\"{random_number_5}\") print(f\"{random_number_6}\") print(\"\") print(\"Notice how this can be hard to read.\") print(\"Let's try printing them while up the decimals.\") print(f\"{random_number_1:7d}\") print(f\"{random_number_2:7d}\") print(f\"{random_number_3:11.3f}\") print(f\"{random_number_4:11.3f}\") print(f\"{random_number_5:11.3f}\") print(f\"{random_number_6:11.3f}\") Here is what should happen $ python adv_format.py I have a jar of Fantastic brand pickles. In the jar, there are 7 pickles with an average weight of 2.34758475 ounces. I have a jar of Fantastic brand pickles. In the jar, there are 7 pickles with an average weight of 2.348 ounces. Printing the numbers without any formatting. 7583 -123 23.0 4838495.23221 483.234 1293.0 Notice how this can be hard to read. Let's try printing them while up the decimals. 7583 -123 23.000 4838495.232 483.234 1293.000 $ What is happening here? lets go through each new concept one-by-one: Lines 8-14: You can have a indented new line in python anytime you have a comma or a open parenthesis also you can assign a multi-line string to a variable in this way. You'll notice this was many lines of code to get this to do what we want. And Python has a better way. Lines 19-21 and 33- 50: Notice the f in front of the string. This is known as a \"literal string interpolation\" and is explained below. Lines 43-50 and line 21: These are format instructions. d is the symbol that corresponds to formatting an integer. f is the symbol for floats. The number before the decimal is the amount of space padding. The number after the decimal is the number of decimal places to show in the number. There are more instructions that can be passed. See \"Hone your skills\" for more on this subject. The important thing here is that for numbers, changing the padding and decimal places can align the numbers' decimals in an easy-to-read fashion.","title":"10 - Better String Formatting"},{"location":"10-Better-String-Formatting/#literal-string-interpolation","text":"The f that we put in front of a string is referred to technically as a \"literal string interpolation\". Colloquially, we call it an \"f-string\". It tells Python to automatically call format on the string using the variable names in the braces. The colon and the text following it tells Python to accept format codes that we explored before. This feature was added relatively recently and is now the standard way of string formatting.","title":"Literal String Interpolation"},{"location":"10-Better-String-Formatting/#hone-your-skills","text":"Look up what a Python PEP is and specifically look up PEP 498. Why do PEPs exist? f is not the only thing that we can put at the beginning of a string to make it do something different. What happens when you put the following letters in front of a string? (Google these if you can't figure it out.) r b u Now you can make a form with variables that will print out information. Make a form that gives the name, age and occupation of whatever you set those variables The format instructions are detailed here in the Python documentation. Learn what each of these things do and experiment with them. Experiment with the format instructions. Can you align all the numbers in different ways? Previous: 09-Variables and Memory | Table of Contents | Next: 11-Input and Output","title":"Hone Your Skills"},{"location":"11-Input-and-Output/","text":"Previous: 10-Better String Formatting | Table of Contents | Next: 12-Math and Data 11 - Input and Output Up to now, we have had our scripts take pre-determined input and turn it into output in the form of text printed to the console screen. Our script does nothing else. What if we want to be able to do more than that? What if we want to interact with the user? In this lesson we will cover getting and using user input. Lets start with this exercise: # input_output.py # use input() to get user input user_name = input(\"Enter your name :\") user_age = input(\"Enter your age :\") user_job = input(\"Enter your occupation:\") # let's print out what we got from the user print(f\"Hello {user_name}! You are {user_age} years old.\") print(f\"You work as a/an {user_job}.\") Here is what should happen $ python io_files.py Enter your name :John Doe Enter your age :30 Enter your occupation:Panda Caretaker Hello John Doe! You are 30 years old. You work as a/an Panda Caretaker. $ What is happening here? As you can see the built-in input function allows you to take user data and store it in variables. Whatever the user enters into the input is saved as a string and you can then do what you wish with it. Do a mini project With this capability, we can start to write programs that can be used by someone other than the programmer! To get you used to this I want you to write your first independent program. You can do any project you want using everything you have learned so far. If you have something you really want to do, go for it. I only ask that you do the following in your project: Use some format statements Use the input function Beyond that you can do any project you want. If you do not know what you want to do I will suggest the following project. The Wacky Stories Game You may have heard of the game Mad Libs . This is a similar concept that you will implement yourself. The rules of the game are simple. Take a short story like the following: Jake and John went fishing. While in the boat, Jake got a bite on his line and pulled up the biggest fish either of the men had ever seen. John exclaimed, \"Now that is a fish!\" The men took it home and made fish and chips. The story should be a bit longer but for our purposes this will do. You'll notice that this story is rather mundane so we are going to make it wacky! Take the text of the story and replace key words from the story with a prompt for the type of word in parentheses. (Name of person in the room[person 1]) and (Name of different person in the room[person 2]) went (verb ending in 'ing'). While in the (noun), (person 1) got a (noun) on his/her (noun) and pulled up the (superlative adjective) (noun) either of the (plural animal) had ever seen. (person 2) exclaimed, \"Now that is a (noun)!\" The (plural animal) took it home and made (plural noun). Prompt the user for each unique word and save each of these to a variable. Then using what you have learned, print out the complete story with the users words in place of the omitted words so you could get a story like: Jill and Mark went farming. While in the needle, Jill got a Canned air on his/her guitar and pulled up the greatest germ either of the sloths had ever seen. Mark exclaimed, \"Now that is a gift card!\" The cockroaches took it home and made slides. Previous: 10-Better String Formatting | Table of Contents | Next: 12-Math and Data","title":"11. Input and Output"},{"location":"11-Input-and-Output/#11-input-and-output","text":"Up to now, we have had our scripts take pre-determined input and turn it into output in the form of text printed to the console screen. Our script does nothing else. What if we want to be able to do more than that? What if we want to interact with the user? In this lesson we will cover getting and using user input. Lets start with this exercise: # input_output.py # use input() to get user input user_name = input(\"Enter your name :\") user_age = input(\"Enter your age :\") user_job = input(\"Enter your occupation:\") # let's print out what we got from the user print(f\"Hello {user_name}! You are {user_age} years old.\") print(f\"You work as a/an {user_job}.\") Here is what should happen $ python io_files.py Enter your name :John Doe Enter your age :30 Enter your occupation:Panda Caretaker Hello John Doe! You are 30 years old. You work as a/an Panda Caretaker. $ What is happening here? As you can see the built-in input function allows you to take user data and store it in variables. Whatever the user enters into the input is saved as a string and you can then do what you wish with it.","title":"11 - Input and Output"},{"location":"11-Input-and-Output/#do-a-mini-project","text":"With this capability, we can start to write programs that can be used by someone other than the programmer! To get you used to this I want you to write your first independent program. You can do any project you want using everything you have learned so far. If you have something you really want to do, go for it. I only ask that you do the following in your project: Use some format statements Use the input function Beyond that you can do any project you want. If you do not know what you want to do I will suggest the following project.","title":"Do a mini project"},{"location":"11-Input-and-Output/#the-wacky-stories-game","text":"You may have heard of the game Mad Libs . This is a similar concept that you will implement yourself. The rules of the game are simple. Take a short story like the following: Jake and John went fishing. While in the boat, Jake got a bite on his line and pulled up the biggest fish either of the men had ever seen. John exclaimed, \"Now that is a fish!\" The men took it home and made fish and chips. The story should be a bit longer but for our purposes this will do. You'll notice that this story is rather mundane so we are going to make it wacky! Take the text of the story and replace key words from the story with a prompt for the type of word in parentheses. (Name of person in the room[person 1]) and (Name of different person in the room[person 2]) went (verb ending in 'ing'). While in the (noun), (person 1) got a (noun) on his/her (noun) and pulled up the (superlative adjective) (noun) either of the (plural animal) had ever seen. (person 2) exclaimed, \"Now that is a (noun)!\" The (plural animal) took it home and made (plural noun). Prompt the user for each unique word and save each of these to a variable. Then using what you have learned, print out the complete story with the users words in place of the omitted words so you could get a story like: Jill and Mark went farming. While in the needle, Jill got a Canned air on his/her guitar and pulled up the greatest germ either of the sloths had ever seen. Mark exclaimed, \"Now that is a gift card!\" The cockroaches took it home and made slides. Previous: 10-Better String Formatting | Table of Contents | Next: 12-Math and Data","title":"The Wacky Stories Game"},{"location":"12-Math-and-Data/","text":"Previous: 11-Input and Output | Table of Contents | Next: 13-Logic and Boolean Operators 12 - Math, Operators and Data Types Now before going further we need to talk about math. This is not a book about math. I will cover some concepts related to scientific/engineering math in a more advanced lesson but I expect that you already know about the following concepts: Addition and Subtraction Multiplication and Division Remainders of Division Exponents Absolute Values If you have never heard of any of these concepts before, I suggest you familiarize yourself with them before proceeding so you have at least a basic understanding of what they are. However if you intend to proceed anyway, just skip the stuff with which you are not familiar as it is probable you will never have to use it. The following exercise will introduce you to the basics of math: # math_learning.py # we will use the variables x, y and z x = 24.3 y = 9.0 z = x print(\"x =\", x) print(\"y =\", y) # basic math operators print(\"x + y =\", x + y) # addition print(\"x - y =\", x - y) # subtraction print(\"x * y =\", x * y) # multiplication print(\"x ** y =\", x ** y) # exponentiation print(\"x / y =\", x / y) # division print(\"x // y =\", x // y) # integer division or floor division print(\"x % y =\", x % y) # modulo or remainder print(\"z was:\", z) # assignment operators z += x # same as z = z + x z -= x # same as z = z - x z *= x # same as z = z * x z **= x # same as z = z ** x z /= x # same as z = z / x z //= x # same as z = z // x z %= x # same as z = z % x print(\"z is now:\", z) Here is what should happen $ python math_learning.py x = 24.3 y = 9.0 x + y = 33.3 x - y = 15.3 x * y = 218.70000000000002 x ** y = 2954312706550.8345 x / y = 2.7 x // y = 2.0 x % y = 6.300000000000001 z was: 24.3 z is now: 4.70613749314111 $ What is happening here? This is a demonstration of binary math operators and assignment operators. Both will be explained below. Lines 28 - 34 demonstrate the assignment operators and were the equivalent of z = (((((z + x - x) * x) ** x) / x) // x) % x , z = (z * x)**x / x // x % x or z = modulo(\\frac{(zx)^x}{x} // x, x) We will explain all of this in this lesson. Data Types In the lesson on Variables and Memory , we talked about a computer can only move and store numbers in \"boxes\". However, we can represent anything we want as a series of \"boxes\" with numbers using some clever tricks that we will not get into here. Suffice it to say that the computer has a way of 'marking' a box or series of boxes as number, letter, chunk of code or, indeed, anything we want. This mark allows the computer to deal with those boxes in a logical manner. For example, you should not try to mathematically divide a string. Therefore, the computer marks the series of numbers as a string so it knows how to properly deal with it and the code: name = \"John\" / 3 does not make any sense will make Python throw an error. The different ways a computer can \"mark\" a set of numbers for interpretation are called \"data types\" or simply \"types\". Later on, we will deepen our understanding of types but for now we will talk about 3 basic types. Integers An integer is any whole number, positive or negative (e.g. -3, -2, -1, 0, 1, 2, 3). This changes how it is combined with other numbers (as we will see later). As it happens, an integer is the only type that can be directly expressed as 1s and 0s in computer memory. Every other data type must have an interpretation attached to it (i.e. a data type). The most obvious feature of an integer is that it cannot have a decimal or any fraction value. To have those features you need a float or a floating point number. Float A floating point number or \"float\" for short is a number that can have a non-whole or fractional value. Values like 1.0 , -0.06020 , or 16575.23 are all floats. A float generally takes up more memory than an integer and can give you more accuracy in mathematical calculations. The accuracy a computer can have is limited by how much space a float can take up. An important note about floats and integers are that if you combine them mathematically, you will always get a float back. Therefore if you need to \"upgrade\" and integer to a float you can do so by multiplying an integer by 1.0 . python number = 2 # 'number' is an integer number = number * 1.0 # 'number' now has the same value but is a float String A string, is fundamentally a series of numbers in boxes in computer memory that are interpreted as a sequence of letters. Those numbers can be used to express thousands of characters. Strings can interact with floats and integers and be combined using operators but do not act the same way floats and integers do as we will see below. There are many more types than these and we will introduce them later on. These are, however, the most common and fundamental types. If you wish to ever know the type of any variable you can use print(type(var)) . Math Operators Each set of symbols between x and y is called a binary operator. Below is a brief description of each binary operator and what it does to a integer, float and string. Operator Math Example Integer and float String + (plus) x + y =x + y Addition Concatenate two strings - (dash) x - y =x - y Subtraction No meaning * (asterisk) x * y = xy = x\\cdot y Multiplication Multiply a string by a positive integer to concatenate string y with itself x times ** (double asterisk) x ** y =x^y The exponent No meaning / (forward slash) x / y =x/y=\\frac{x}{y} Float (i.e. normal) division No meaning // (double forward slash) x // y =\\frac{x}{y} rounded down to integer Integer division or floor division No meaning % (percent character) x % y = y - x * (x // y) Modulo or Remainder \"Old style\" string formatting Among the above operators, the less commonly known operators are the last 2 and therefore we will give more details about them below: Integer Division This is like normal division but the resulting number is rounded down to the next lowest integer. The result is always an integer value but not necessarily an integer number (e.g. 2.0 may be returned instead of 2 ) Modulo This is the same thing as a remainder. For example: how many times does 3 goes into 5 evenly? Answer: 1 but if we subtract the product of 3 and 1 from 5 we get what is left over. Assignment Operators The assignment operator = will always evaluate whatever is on the right side of it before storing it in memory. Therefore, an operation like z = z + x tells the computer to do the following: Take the current value of z and add it to x Once you have that result, store that result in the same place Python has a shorthand for all of these operators to make certain things easier later on. We will explore this in a later lesson. These shorthand versions are also called assignment operators. Below is a summary of the assignment operators and their corresponding string operations. Operator Same as String Operation += Plus-equals z = z + x Append x to z -= Minus-equals z = z - x No meaning *= Times-equals z = z * x The new z is the old z repeated x times **= Exponent-equals z = z ** x No meaning /= Divide-equals z = z / x No meaning //= Double-divide-equals z = z // x No meaning %= Modulo-equals z = z % x An expansion of the \"old-style\" formatting Order of Operations Python uses normal math conventions when evaluating math expressions the following order of operations is observed proceeding left to right when conflicts appear: Parentheses Exponents Multiplication, Division, Integer Division and Modulo Addition and Subtraction All Python expressions follow the convention of being evaluated left to right and any order can be broken by using parentheses. Built-in Math Functions Lastly we will talk about some built-in functions (like print() ) can help us evaluate and convert between math and string operations: int This function can be used to turn a float or a string into an integer if there is any way to interpret it as such. Therefore expressions like int(\"123\") , int(123.223) and int(123) will all work and return 123 as an integer but int(\"a 123\") will throw an error. float This will likewise turn any type into a float if possible. (e.g. float(\"123.00\") , float(\"123\") , float(123.00) and float(123) will all work and return 123 as an integer but float(\"a 123\") will throw an error.) str This function will turn any type into a string if possible. (e.g. str(123) becomes \"123\" and str(123.00) becomes \"123.0\" ) abs This gives the absolute value of the number pow Pow or power is the exponent function and pow(x, y) is equivalent to x ** y Hone Your Skills Write your own script that uses the built-in functions. Can you break them? What are their limitations? Using the input function, write a script that asks the user for the parameters a , b and c corresponding to the quadratic equation ($ax^2+bx+c = 0$) and calculates the roots of the equation using the quadratic formula with the user providing a, b and c. (Hint: A square root is the same as taking a number to the $\\frac{1}{2}$ power. e.g. $\\sqrt{a+b} = (a+b)^\\frac{1}{2}$) Advanced Mastery Notice in the results of math_learning.py that you got some answers that were lots of 0s followed by a single digit. Research \"round off error\" to understand why this happens. Previous: 11-Input and Output | Table of Contents | Next: 13-Logic and Boolean Operators","title":"12. Math and Data"},{"location":"12-Math-and-Data/#12-math-operators-and-data-types","text":"Now before going further we need to talk about math. This is not a book about math. I will cover some concepts related to scientific/engineering math in a more advanced lesson but I expect that you already know about the following concepts: Addition and Subtraction Multiplication and Division Remainders of Division Exponents Absolute Values If you have never heard of any of these concepts before, I suggest you familiarize yourself with them before proceeding so you have at least a basic understanding of what they are. However if you intend to proceed anyway, just skip the stuff with which you are not familiar as it is probable you will never have to use it. The following exercise will introduce you to the basics of math: # math_learning.py # we will use the variables x, y and z x = 24.3 y = 9.0 z = x print(\"x =\", x) print(\"y =\", y) # basic math operators print(\"x + y =\", x + y) # addition print(\"x - y =\", x - y) # subtraction print(\"x * y =\", x * y) # multiplication print(\"x ** y =\", x ** y) # exponentiation print(\"x / y =\", x / y) # division print(\"x // y =\", x // y) # integer division or floor division print(\"x % y =\", x % y) # modulo or remainder print(\"z was:\", z) # assignment operators z += x # same as z = z + x z -= x # same as z = z - x z *= x # same as z = z * x z **= x # same as z = z ** x z /= x # same as z = z / x z //= x # same as z = z // x z %= x # same as z = z % x print(\"z is now:\", z) Here is what should happen $ python math_learning.py x = 24.3 y = 9.0 x + y = 33.3 x - y = 15.3 x * y = 218.70000000000002 x ** y = 2954312706550.8345 x / y = 2.7 x // y = 2.0 x % y = 6.300000000000001 z was: 24.3 z is now: 4.70613749314111 $ What is happening here? This is a demonstration of binary math operators and assignment operators. Both will be explained below. Lines 28 - 34 demonstrate the assignment operators and were the equivalent of z = (((((z + x - x) * x) ** x) / x) // x) % x , z = (z * x)**x / x // x % x or z = modulo(\\frac{(zx)^x}{x} // x, x) We will explain all of this in this lesson.","title":"12 - Math, Operators and Data Types"},{"location":"12-Math-and-Data/#data-types","text":"In the lesson on Variables and Memory , we talked about a computer can only move and store numbers in \"boxes\". However, we can represent anything we want as a series of \"boxes\" with numbers using some clever tricks that we will not get into here. Suffice it to say that the computer has a way of 'marking' a box or series of boxes as number, letter, chunk of code or, indeed, anything we want. This mark allows the computer to deal with those boxes in a logical manner. For example, you should not try to mathematically divide a string. Therefore, the computer marks the series of numbers as a string so it knows how to properly deal with it and the code: name = \"John\" / 3 does not make any sense will make Python throw an error. The different ways a computer can \"mark\" a set of numbers for interpretation are called \"data types\" or simply \"types\". Later on, we will deepen our understanding of types but for now we will talk about 3 basic types. Integers An integer is any whole number, positive or negative (e.g. -3, -2, -1, 0, 1, 2, 3). This changes how it is combined with other numbers (as we will see later). As it happens, an integer is the only type that can be directly expressed as 1s and 0s in computer memory. Every other data type must have an interpretation attached to it (i.e. a data type). The most obvious feature of an integer is that it cannot have a decimal or any fraction value. To have those features you need a float or a floating point number. Float A floating point number or \"float\" for short is a number that can have a non-whole or fractional value. Values like 1.0 , -0.06020 , or 16575.23 are all floats. A float generally takes up more memory than an integer and can give you more accuracy in mathematical calculations. The accuracy a computer can have is limited by how much space a float can take up. An important note about floats and integers are that if you combine them mathematically, you will always get a float back. Therefore if you need to \"upgrade\" and integer to a float you can do so by multiplying an integer by 1.0 . python number = 2 # 'number' is an integer number = number * 1.0 # 'number' now has the same value but is a float String A string, is fundamentally a series of numbers in boxes in computer memory that are interpreted as a sequence of letters. Those numbers can be used to express thousands of characters. Strings can interact with floats and integers and be combined using operators but do not act the same way floats and integers do as we will see below. There are many more types than these and we will introduce them later on. These are, however, the most common and fundamental types. If you wish to ever know the type of any variable you can use print(type(var)) .","title":"Data Types"},{"location":"12-Math-and-Data/#math-operators","text":"Each set of symbols between x and y is called a binary operator. Below is a brief description of each binary operator and what it does to a integer, float and string. Operator Math Example Integer and float String + (plus) x + y =x + y Addition Concatenate two strings - (dash) x - y =x - y Subtraction No meaning * (asterisk) x * y = xy = x\\cdot y Multiplication Multiply a string by a positive integer to concatenate string y with itself x times ** (double asterisk) x ** y =x^y The exponent No meaning / (forward slash) x / y =x/y=\\frac{x}{y} Float (i.e. normal) division No meaning // (double forward slash) x // y =\\frac{x}{y} rounded down to integer Integer division or floor division No meaning % (percent character) x % y = y - x * (x // y) Modulo or Remainder \"Old style\" string formatting Among the above operators, the less commonly known operators are the last 2 and therefore we will give more details about them below: Integer Division This is like normal division but the resulting number is rounded down to the next lowest integer. The result is always an integer value but not necessarily an integer number (e.g. 2.0 may be returned instead of 2 ) Modulo This is the same thing as a remainder. For example: how many times does 3 goes into 5 evenly? Answer: 1 but if we subtract the product of 3 and 1 from 5 we get what is left over.","title":"Math Operators"},{"location":"12-Math-and-Data/#assignment-operators","text":"The assignment operator = will always evaluate whatever is on the right side of it before storing it in memory. Therefore, an operation like z = z + x tells the computer to do the following: Take the current value of z and add it to x Once you have that result, store that result in the same place Python has a shorthand for all of these operators to make certain things easier later on. We will explore this in a later lesson. These shorthand versions are also called assignment operators. Below is a summary of the assignment operators and their corresponding string operations. Operator Same as String Operation += Plus-equals z = z + x Append x to z -= Minus-equals z = z - x No meaning *= Times-equals z = z * x The new z is the old z repeated x times **= Exponent-equals z = z ** x No meaning /= Divide-equals z = z / x No meaning //= Double-divide-equals z = z // x No meaning %= Modulo-equals z = z % x An expansion of the \"old-style\" formatting","title":"Assignment Operators"},{"location":"12-Math-and-Data/#order-of-operations","text":"Python uses normal math conventions when evaluating math expressions the following order of operations is observed proceeding left to right when conflicts appear: Parentheses Exponents Multiplication, Division, Integer Division and Modulo Addition and Subtraction All Python expressions follow the convention of being evaluated left to right and any order can be broken by using parentheses.","title":"Order of Operations"},{"location":"12-Math-and-Data/#built-in-math-functions","text":"Lastly we will talk about some built-in functions (like print() ) can help us evaluate and convert between math and string operations: int This function can be used to turn a float or a string into an integer if there is any way to interpret it as such. Therefore expressions like int(\"123\") , int(123.223) and int(123) will all work and return 123 as an integer but int(\"a 123\") will throw an error. float This will likewise turn any type into a float if possible. (e.g. float(\"123.00\") , float(\"123\") , float(123.00) and float(123) will all work and return 123 as an integer but float(\"a 123\") will throw an error.) str This function will turn any type into a string if possible. (e.g. str(123) becomes \"123\" and str(123.00) becomes \"123.0\" ) abs This gives the absolute value of the number pow Pow or power is the exponent function and pow(x, y) is equivalent to x ** y","title":"Built-in Math Functions"},{"location":"12-Math-and-Data/#hone-your-skills","text":"Write your own script that uses the built-in functions. Can you break them? What are their limitations? Using the input function, write a script that asks the user for the parameters a , b and c corresponding to the quadratic equation ($ax^2+bx+c = 0$) and calculates the roots of the equation using the quadratic formula with the user providing a, b and c. (Hint: A square root is the same as taking a number to the $\\frac{1}{2}$ power. e.g. $\\sqrt{a+b} = (a+b)^\\frac{1}{2}$)","title":"Hone Your Skills"},{"location":"12-Math-and-Data/#advanced-mastery","text":"Notice in the results of math_learning.py that you got some answers that were lots of 0s followed by a single digit. Research \"round off error\" to understand why this happens. Previous: 11-Input and Output | Table of Contents | Next: 13-Logic and Boolean Operators","title":"Advanced Mastery"},{"location":"13-Logic-and-Boolean-Operators/","text":"Previous: 12-Math and Data | Table of Contents | Next: 14-If elif and else 13 - Logic and Boolean Operators For this section's exercises there will be a short example that you will work in the Python interpreter instead of a Python script. Enter each command from each exercise complete them. True and False One of the most important concepts in programming is that of Boolean logic. On a fundamental level the computer only knows 2 things: 1 and 0, Yes and No, On and Off, True and False. Everything else in a computer must be constructed from these two things. Within this framework the computer can do many things such as make decisions. However to make a decision, the computer must be able to evaluate the truth value of everything. Therefore everything can be evaluated as True or False using the built-in bool function. This gives rise to a new data type, the Boolean data type. The Boolean data type can only have two values namely True or False . This makes it among the simplest and most useful of data types. By Try this out in the interpreter Go to your python interpreter and try running the following commands: $ python3 Python 3.6.7 (default, Oct 22 2018, 11:32:17) [GCC 8.2.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> bool(True) True >>> bool(False) False >>> bool(0) False >>> bool(34) True >>> bool(-1) True >>> bool(0.0) False >>> bool(0.001) True >>> bool(\"\") False >>> bool(\"s\") True >>> exit() $ What I hope you get out of this is that, for the three data types we have covered so far, anything that is a non-empty or non-zero value will evaluate to True and empty or zero values will evaluate to False. True and False are both key words in Python to express these boolean concepts. And every data type in Python, by default, will evaluate to one or the other. In the next lesson we will explore how we can use this idea to make decisions. Another way to return the truth of something is by using the logical comparison operators. Comparison Operators We will introduce another set of binary operators called comparison operators. For all these operators we will use the example of x <OPERATOR> y to demonstrate the meaning of each operator Code Symbol Meaning == Equal to != Not equal to > Greater than < Less than >= Greater than or equal to <= Less than or equal to Try this out in the interpreter A few things to do while doing this exercise: Note that some of these return errors. Which ones do this and why? Read each line as you write it as such: \"1 is equal to 2: False\" \"Empty quotes is equal to 0: False\" etc. This will help you learn to think about these logical statements. $ python3 Python 3.6.7 (default, Oct 22 2018, 11:32:17) [GCC 8.2.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> 1 == 2 False >>> \"\" == 0 False >>> 0 == 0 True >>> 1.0 == 1 True >>> 3 != 2 True >>> \"\" != 0 True >>> 0 != 0 False >>> 3 < 2 False >>> 3 >=2 True >>> 3 > 3 False >>> \"\" == \"\" True >>> \"\" > 3 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: '>' not supported between instances of 'str' and 'int' >>> \"\" > \"23\" False >>> \"\" < \"23\" True >>> \"23\" < \"23\" False >>> \"23\" == \"23\" True >>> \"23\" == \"24\" False >>> \"23\" > \"24\" False >>> exit() $ You can see from the results of the above exercise that some types are incompatible with others. Also note that in most cases combining numbers and strings returns a not equal condition. Logical operators True and False may be combined using logical operators. This allows many statements to be chained and combined in logical ways. They use the truth value and based on their logic and then return one of the values. In a more useful sense, if you only combine two Boolean values or expressions that evaluate to Boolean values you can pull some logic out of the expression. The following is pulled directly from the official Python documentation to help you understand the result of each operator: Boolean Operations \u2014 and , or , not These are the Boolean operations, ordered by ascending priority: Operation Result Notes x or y if x is false, then y , else x (1) x and y if x is false, then x , else y (2) not x if x is false, then True , else False (3) Notes: This is a short-circuit operator, so it only evaluates the second argument if the first one is false. This is a short-circuit operator, so it only evaluates the second argument if the first one is true. not has a lower priority than non-Boolean operators, so not a == b is interpreted as not (a == b) , and a == not b is a syntax error. Try this out in the interpreter $ python Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> 1 and 2 2 >>> 2 and 1 1 >>> bool(2) and bool(1) True >>> True and False False >>> True and True True >>> True or False True >>> True and False or True True >>> True and (False or True) True >>> True or False or True True >>> True and False and True False >>> \"\" and 4 '' >>> 3.14 or 0.0 3.14 >>> bool(3 and 4 and 0) False >>> \"cheese\" or \"crackers\" 'cheese' >>> \"cheese\" and \"crackers\" 'crackers' >>> True and not False True >>> not True or False False >>> not 3 False >>> not 0 True >>> exit() $ For all of these operators, memorize their behavior and practice with them Hone your skills Make your own table or a set of flash cards for each of these operators and practice predicting the result of many different comparisons, logical statements and uses of the bool function. Advanced Mastery Look at the official Python documentation on built-in types, focusing on the Boolean data type. Or, make your own internet search. Answer the following questions: How do the equality operator == and the is operator differ? Does order matter in logical operator statements? How can you use this to your advantage? For objects that are not numbers or strings, how is the Truth value evaluated? How could you change this evaluation? Previous: 12-Math and Data | Table of Contents | Next: 14-If elif and else","title":"13. Logic and Boolean Operators"},{"location":"13-Logic-and-Boolean-Operators/#13-logic-and-boolean-operators","text":"For this section's exercises there will be a short example that you will work in the Python interpreter instead of a Python script. Enter each command from each exercise complete them.","title":"13 - Logic and Boolean Operators"},{"location":"13-Logic-and-Boolean-Operators/#true-and-false","text":"One of the most important concepts in programming is that of Boolean logic. On a fundamental level the computer only knows 2 things: 1 and 0, Yes and No, On and Off, True and False. Everything else in a computer must be constructed from these two things. Within this framework the computer can do many things such as make decisions. However to make a decision, the computer must be able to evaluate the truth value of everything. Therefore everything can be evaluated as True or False using the built-in bool function. This gives rise to a new data type, the Boolean data type. The Boolean data type can only have two values namely True or False . This makes it among the simplest and most useful of data types. By","title":"True and False"},{"location":"13-Logic-and-Boolean-Operators/#try-this-out-in-the-interpreter","text":"Go to your python interpreter and try running the following commands: $ python3 Python 3.6.7 (default, Oct 22 2018, 11:32:17) [GCC 8.2.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> bool(True) True >>> bool(False) False >>> bool(0) False >>> bool(34) True >>> bool(-1) True >>> bool(0.0) False >>> bool(0.001) True >>> bool(\"\") False >>> bool(\"s\") True >>> exit() $ What I hope you get out of this is that, for the three data types we have covered so far, anything that is a non-empty or non-zero value will evaluate to True and empty or zero values will evaluate to False. True and False are both key words in Python to express these boolean concepts. And every data type in Python, by default, will evaluate to one or the other. In the next lesson we will explore how we can use this idea to make decisions. Another way to return the truth of something is by using the logical comparison operators.","title":"Try this out in the interpreter"},{"location":"13-Logic-and-Boolean-Operators/#comparison-operators","text":"We will introduce another set of binary operators called comparison operators. For all these operators we will use the example of x <OPERATOR> y to demonstrate the meaning of each operator Code Symbol Meaning == Equal to != Not equal to > Greater than < Less than >= Greater than or equal to <= Less than or equal to","title":"Comparison Operators"},{"location":"13-Logic-and-Boolean-Operators/#try-this-out-in-the-interpreter_1","text":"A few things to do while doing this exercise: Note that some of these return errors. Which ones do this and why? Read each line as you write it as such: \"1 is equal to 2: False\" \"Empty quotes is equal to 0: False\" etc. This will help you learn to think about these logical statements. $ python3 Python 3.6.7 (default, Oct 22 2018, 11:32:17) [GCC 8.2.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> 1 == 2 False >>> \"\" == 0 False >>> 0 == 0 True >>> 1.0 == 1 True >>> 3 != 2 True >>> \"\" != 0 True >>> 0 != 0 False >>> 3 < 2 False >>> 3 >=2 True >>> 3 > 3 False >>> \"\" == \"\" True >>> \"\" > 3 Traceback (most recent call last): File \"<stdin>\", line 1, in <module> TypeError: '>' not supported between instances of 'str' and 'int' >>> \"\" > \"23\" False >>> \"\" < \"23\" True >>> \"23\" < \"23\" False >>> \"23\" == \"23\" True >>> \"23\" == \"24\" False >>> \"23\" > \"24\" False >>> exit() $ You can see from the results of the above exercise that some types are incompatible with others. Also note that in most cases combining numbers and strings returns a not equal condition.","title":"Try this out in the interpreter"},{"location":"13-Logic-and-Boolean-Operators/#logical-operators","text":"True and False may be combined using logical operators. This allows many statements to be chained and combined in logical ways. They use the truth value and based on their logic and then return one of the values. In a more useful sense, if you only combine two Boolean values or expressions that evaluate to Boolean values you can pull some logic out of the expression. The following is pulled directly from the official Python documentation to help you understand the result of each operator:","title":"Logical operators"},{"location":"13-Logic-and-Boolean-Operators/#boolean-operations-and-or-not","text":"These are the Boolean operations, ordered by ascending priority: Operation Result Notes x or y if x is false, then y , else x (1) x and y if x is false, then x , else y (2) not x if x is false, then True , else False (3) Notes: This is a short-circuit operator, so it only evaluates the second argument if the first one is false. This is a short-circuit operator, so it only evaluates the second argument if the first one is true. not has a lower priority than non-Boolean operators, so not a == b is interpreted as not (a == b) , and a == not b is a syntax error.","title":"Boolean Operations \u2014 and, or, not"},{"location":"13-Logic-and-Boolean-Operators/#try-this-out-in-the-interpreter_2","text":"$ python Python 3.7.0 (v3.7.0:1bf9cc5093, Jun 27 2018, 04:59:51) [MSC v.1914 64 bit (AMD64)] on win32 Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> 1 and 2 2 >>> 2 and 1 1 >>> bool(2) and bool(1) True >>> True and False False >>> True and True True >>> True or False True >>> True and False or True True >>> True and (False or True) True >>> True or False or True True >>> True and False and True False >>> \"\" and 4 '' >>> 3.14 or 0.0 3.14 >>> bool(3 and 4 and 0) False >>> \"cheese\" or \"crackers\" 'cheese' >>> \"cheese\" and \"crackers\" 'crackers' >>> True and not False True >>> not True or False False >>> not 3 False >>> not 0 True >>> exit() $ For all of these operators, memorize their behavior and practice with them","title":"Try this out in the interpreter"},{"location":"13-Logic-and-Boolean-Operators/#hone-your-skills","text":"Make your own table or a set of flash cards for each of these operators and practice predicting the result of many different comparisons, logical statements and uses of the bool function.","title":"Hone your skills"},{"location":"13-Logic-and-Boolean-Operators/#advanced-mastery","text":"Look at the official Python documentation on built-in types, focusing on the Boolean data type. Or, make your own internet search. Answer the following questions: How do the equality operator == and the is operator differ? Does order matter in logical operator statements? How can you use this to your advantage? For objects that are not numbers or strings, how is the Truth value evaluated? How could you change this evaluation? Previous: 12-Math and Data | Table of Contents | Next: 14-If elif and else","title":"Advanced Mastery"},{"location":"14-If-elif-and-else/","text":"Previous: 13-Logic and Boolean Operators | Table of Contents | Next: 15-Errors Exceptions and Bugs 14 - If, elif and else We will use the concepts of True and False to drive our scripts ability to make decisions. The following exercise will help introduce program decisions and conditionals. Note: This will be the first time we see indented blocks of code. Whenever you see an indented line of code, follow the Python standard of always indenting 4 spaces (do not use tabs). Your text editor can and should be configured to insert 4 spaces instead of a tab character \\t when the \"Tab\" key is pressed. # if_else.py # let's start with some variables # this will tell us to print an error # message if necessary error = False # this is how much the farmer # needs in revenue to break even break_even = 1000.00 # these are farming data berry_farmer = \"Barry Farmer\" wheat_farmer = \"Ray Wheatley\" number_of_berries = 3294 bushels_of_wheat = 523.45 berry_hired_hands = 34 wheat_hired_hands = 23 price_per_bushel = 2.50 price_per_100_berries = 15.23 # now let's get the farmer we # want to know about farmer_name = input(\"Enter the name of the farmer\\n\\t--> \") if farmer_name == berry_farmer: produce = \"Berries\" amount = number_of_berries / 100 hands = berry_hired_hands pricing = price_per_100_berries elif farmer_name == wheat_farmer: produce = \"Wheat\" amount = bushels_of_wheat hands = wheat_hired_hands pricing = price_per_bushel else: error = True if not error: revenue = amount * pricing payment_per_hand = revenue / hands if revenue < break_even: message = \"Farm is below break-even point. Sorry\" else: message = \"Farm is above break-even point. Congratulations!\" print(f\"\"\" --- Farm Report for {farmer_name} --- Product for sale : {produce:>11} Price per unit : ${pricing:10.2f} Total revenue : ${revenue:10.2f} Amount owed to each hired hand : ${payment_per_hand:10.2f} {message} \"\"\") else: print(f\"Farmer name \\\"{farmer_name}\\\" does not exist in record!\") Here is what should happen $ python if_else.py Enter the name of the farmer --> Barry Farmer --- Farm Report for Barry Farmer --- Product for sale : Berries Price per unit : $ 15.23 Total revenue : $ 501.68 Amount owed to each hired hand : $ 14.76 Farm is below break-even point. Sorry $ python if_else.py Enter the name of the farmer --> Ray Wheatley --- Farm Report for Ray Wheatley --- Product for sale : Wheat Price per unit : $ 2.50 Total revenue : $ 1308.62 Amount owed to each hired hand : $ 56.90 Farm is above break-even point. Congratulations! $ python if_else.py Enter the name of the farmer --> Gary Hart Farmer name \"Gary Hart\" does not exist in record! $ What is happening Here? We are using conditional logic to get data for a pair of farmers. We begin by prompting the user for the farmer's name. We then check the names of the farmers we have data for. If the name does not match any of the farmer's on record we print an error message. (This is the else part on line 63.) The error variable we set earlier in the script will be set to True on line 42 in the case that we do not find the name of any farmer in record. Should the name given match a name in our records we prepare the output by setting appropriate variables and then formatting and printing them out in the absence of an error. Conditionals The section about logical operators introduced us to the idea that everything can be evaluated with a value of True or False . In this section we put that logic to work for us. The conditional or \"if\" statement in python has the following syntax: if Expression1: # don't forget the colon do_thing_one() # indent 4 spaces # if Expression1 evaluates to False check Expression 2 elif Expression2: do_thing_two() # and so on elif Expression3: do_thing_three() # if all previous expressions evaluate to False do the 'else' part else: do_thing_three() We will explain the syntax step by step. When Python comes to an if statement, the following is executed: Python evaluates whatever is in place for Expression1 for a truth value. If Expression1 evaluates to True : Everything in the indented block of code under if will be executed. Once the block has ended (by un-indenting), the rest of the elif and else blocks of code are skipped. If Expression1 evaluates to False , Expression2 is checked for its truth value If Expression2 evaluates to True : Everything in the indented block of code under elif will be executed. Once the block has ended (by un-indenting), the rest of the elif and else blocks of code are skipped. If Expression2 evaluates to False , Expression3 is checked for its truth value and so on... This pattern continues for all the elif expressions. Finally, if none of the 'if' or elif expressions evaluate to True , the code under the else is executed. Python's conditional syntax allows as many elif statements as the programmer wishes. However, the elif and else parts are not necessary. You may choose to have a conditional block without an else or without an elif part. For coding purposes this is good practice as we will see in the section about errors. Indented Blocks We have introduced an important syntax in Python. That is the indented block. This one feature that Python uses to make it more readable and to avoid cluttering the code page with unnecessary symbols or words. As you saw below each if , elif or else statement, the code is executed as normal. An indented block is just a way of python separating a chunk of code and executing it in a different context, in this case, the context is that the code is executed if the logical expression evaluates to True . There are many other contexts that we will cover later but for now, memorize the following rules about indented blocks: Indented blocks must start with a colon : . A colon tells Python in effect \"This is the beginning of a new indented block\" Indent 4 spaces. Four spaces is an accepted convention although Python will technically allow whatever spacing you want as long as you are consistent. Any code you see written will follow the 4 space convention and that is the standard so it is best if you follow suit. If you mix spacings or are inconsistent with this Python will throw a syntax error. End the block by un-indenting. The only way Python knows that the indented block has ended is when an un-indented line of code is observed. Nested blocks are allowed. If you want to have an indented block inside an indented block that is fine. the same rules apply in all cases. You may not know understand yet why these are so important but as we go along it will be obvious why they exist. Hone Your Skills Write a script that has several nested if and elif statements. Can you simplify the logic to not need as many nested blocks of code? Advanced Mastery There is a problem in the above script if_else.py that can cause errors if we're not careful. Can you find the problem? How would you fix it? Previous: 13-Logic and Boolean Operators | Table of Contents | Next: 15-Errors Exceptions and Bugs","title":"14. If elif and else"},{"location":"14-If-elif-and-else/#14-if-elif-and-else","text":"We will use the concepts of True and False to drive our scripts ability to make decisions. The following exercise will help introduce program decisions and conditionals. Note: This will be the first time we see indented blocks of code. Whenever you see an indented line of code, follow the Python standard of always indenting 4 spaces (do not use tabs). Your text editor can and should be configured to insert 4 spaces instead of a tab character \\t when the \"Tab\" key is pressed. # if_else.py # let's start with some variables # this will tell us to print an error # message if necessary error = False # this is how much the farmer # needs in revenue to break even break_even = 1000.00 # these are farming data berry_farmer = \"Barry Farmer\" wheat_farmer = \"Ray Wheatley\" number_of_berries = 3294 bushels_of_wheat = 523.45 berry_hired_hands = 34 wheat_hired_hands = 23 price_per_bushel = 2.50 price_per_100_berries = 15.23 # now let's get the farmer we # want to know about farmer_name = input(\"Enter the name of the farmer\\n\\t--> \") if farmer_name == berry_farmer: produce = \"Berries\" amount = number_of_berries / 100 hands = berry_hired_hands pricing = price_per_100_berries elif farmer_name == wheat_farmer: produce = \"Wheat\" amount = bushels_of_wheat hands = wheat_hired_hands pricing = price_per_bushel else: error = True if not error: revenue = amount * pricing payment_per_hand = revenue / hands if revenue < break_even: message = \"Farm is below break-even point. Sorry\" else: message = \"Farm is above break-even point. Congratulations!\" print(f\"\"\" --- Farm Report for {farmer_name} --- Product for sale : {produce:>11} Price per unit : ${pricing:10.2f} Total revenue : ${revenue:10.2f} Amount owed to each hired hand : ${payment_per_hand:10.2f} {message} \"\"\") else: print(f\"Farmer name \\\"{farmer_name}\\\" does not exist in record!\") Here is what should happen $ python if_else.py Enter the name of the farmer --> Barry Farmer --- Farm Report for Barry Farmer --- Product for sale : Berries Price per unit : $ 15.23 Total revenue : $ 501.68 Amount owed to each hired hand : $ 14.76 Farm is below break-even point. Sorry $ python if_else.py Enter the name of the farmer --> Ray Wheatley --- Farm Report for Ray Wheatley --- Product for sale : Wheat Price per unit : $ 2.50 Total revenue : $ 1308.62 Amount owed to each hired hand : $ 56.90 Farm is above break-even point. Congratulations! $ python if_else.py Enter the name of the farmer --> Gary Hart Farmer name \"Gary Hart\" does not exist in record! $ What is happening Here? We are using conditional logic to get data for a pair of farmers. We begin by prompting the user for the farmer's name. We then check the names of the farmers we have data for. If the name does not match any of the farmer's on record we print an error message. (This is the else part on line 63.) The error variable we set earlier in the script will be set to True on line 42 in the case that we do not find the name of any farmer in record. Should the name given match a name in our records we prepare the output by setting appropriate variables and then formatting and printing them out in the absence of an error.","title":"14 - If, elif and else"},{"location":"14-If-elif-and-else/#conditionals","text":"The section about logical operators introduced us to the idea that everything can be evaluated with a value of True or False . In this section we put that logic to work for us. The conditional or \"if\" statement in python has the following syntax: if Expression1: # don't forget the colon do_thing_one() # indent 4 spaces # if Expression1 evaluates to False check Expression 2 elif Expression2: do_thing_two() # and so on elif Expression3: do_thing_three() # if all previous expressions evaluate to False do the 'else' part else: do_thing_three() We will explain the syntax step by step. When Python comes to an if statement, the following is executed: Python evaluates whatever is in place for Expression1 for a truth value. If Expression1 evaluates to True : Everything in the indented block of code under if will be executed. Once the block has ended (by un-indenting), the rest of the elif and else blocks of code are skipped. If Expression1 evaluates to False , Expression2 is checked for its truth value If Expression2 evaluates to True : Everything in the indented block of code under elif will be executed. Once the block has ended (by un-indenting), the rest of the elif and else blocks of code are skipped. If Expression2 evaluates to False , Expression3 is checked for its truth value and so on... This pattern continues for all the elif expressions. Finally, if none of the 'if' or elif expressions evaluate to True , the code under the else is executed. Python's conditional syntax allows as many elif statements as the programmer wishes. However, the elif and else parts are not necessary. You may choose to have a conditional block without an else or without an elif part. For coding purposes this is good practice as we will see in the section about errors.","title":"Conditionals"},{"location":"14-If-elif-and-else/#indented-blocks","text":"We have introduced an important syntax in Python. That is the indented block. This one feature that Python uses to make it more readable and to avoid cluttering the code page with unnecessary symbols or words. As you saw below each if , elif or else statement, the code is executed as normal. An indented block is just a way of python separating a chunk of code and executing it in a different context, in this case, the context is that the code is executed if the logical expression evaluates to True . There are many other contexts that we will cover later but for now, memorize the following rules about indented blocks: Indented blocks must start with a colon : . A colon tells Python in effect \"This is the beginning of a new indented block\" Indent 4 spaces. Four spaces is an accepted convention although Python will technically allow whatever spacing you want as long as you are consistent. Any code you see written will follow the 4 space convention and that is the standard so it is best if you follow suit. If you mix spacings or are inconsistent with this Python will throw a syntax error. End the block by un-indenting. The only way Python knows that the indented block has ended is when an un-indented line of code is observed. Nested blocks are allowed. If you want to have an indented block inside an indented block that is fine. the same rules apply in all cases. You may not know understand yet why these are so important but as we go along it will be obvious why they exist.","title":"Indented Blocks"},{"location":"14-If-elif-and-else/#hone-your-skills","text":"Write a script that has several nested if and elif statements. Can you simplify the logic to not need as many nested blocks of code?","title":"Hone Your Skills"},{"location":"14-If-elif-and-else/#advanced-mastery","text":"There is a problem in the above script if_else.py that can cause errors if we're not careful. Can you find the problem? How would you fix it? Previous: 13-Logic and Boolean Operators | Table of Contents | Next: 15-Errors Exceptions and Bugs","title":"Advanced Mastery"},{"location":"15-Errors-Exceptions-and-Bugs/","text":"Previous: 14-If elif and else | Table of Contents | Next: 16-File Reading and Writing 15 - Errors, Exceptions and Bugs We are going to \"break\" Python in a lot of ways in this section. Your assignment for this section is to fix all the problems in the following script. For the purposes of this exercise, here is how you should go about doing this: Write out the code exactly as it appears as always Try to run it Each time it breaks or throws an error, fix the error Continue running the script and fixing each error that comes up until the script runs without any errors # errors.py fav_number = input(\"Please enter your favorite number: \" fav_number = float(fav_number) # there is a line of code missing here # pi is the same as \u03c0 and should have a value of 3.14 if fav_number > pi print(\"Your number is bigger than pi!\") else: print(\"Your number is less than or equal to pi!\") print(\"You can print all sorts of \"numbers\" given by the user.\") Here is what should happen This is what should happen as you run it. You should be fixing the problems with the script between each time you attempt to run it. $ python3 errors.py File \"errors.py\", line 5 fav_number = float(fav_number) ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 5 fav_number = float(fav_number) ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 9 if fav_number < pi ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 14 print(\"You can print all sorts of \"numbers\" given by the user.\") ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 14 print(\"You can print all sorts of \\\"numbers\" given by the user.\") ^ SyntaxError: invalid syntax $ python3 errors.py Please enter your favorite number: 23 Traceback (most recent call last): File \"errors.py\", line 9, in <module> if fav_number < pi: NameError: name 'pi' is not defined $ python3 errors.py Please enter your favorite number: 23 Your number is less than or equal to pi! You can print all sorts of \"numbers\" given by the user. $ python3 errors.py Please enter your favorite number: 23 Your number is bigger than pi! You can print all sorts of \"numbers\" given by the user. $ python3 errors.py Please enter your favorite number: 23d Traceback (most recent call last): File \"errors.py\", line 5, in <module> fav_number = float(fav_number) ValueError: could not convert string to float: '23d' $ Errors and Exceptions I am using the term \"error\" loosely here. In reality, there was a time when an error was the computer equivalent of certain death. You see, Python has all sorts of protections and carefully constructed walls up to protect the programmer from him or herself. But it wasn't always this way. Older languages such as C (especially in their earlier years) were perfectly happy to let you crash your entire computer. (It turns out that you could also destroy your hardware too but that's another can of worms we are not getting into here.) From the stand point of these programming languages, an error is a death sentence, at least, for the program in which it occurs. Not to mention, there were potentially a lot of weird side effects from a program that just stopped running unexpectedly. To deal with the problems that this caused, languages like C++ introduced the concept of an \"exception\" in which an error could be caught and handled without breaking the program or computer. In Python, there are no such things as \"errors\", at least in the sense that is described above. Everything is an exception. This means that Python is a relatively forgiving language. You can put any amount of junk in there and generally it will keep you from causing major problems. In fact as you have seen by now, Python does everything it can to help you understand what went wrong and sometimes even tells you how you can fix it. I mentioned in an earlier section that \"There is no such thing as perfect code\". I mean it. Even when you write the simplest programs there are hundreds if not thousands of little things that have to go right for you to get a desired result. And I want you to understand this now as well. You will make mistakes. This doesn't necessarily make you a bad programmer. Mistakes are almost inevitable. What I want you to get from this lesson is to not fear making mistakes and to know how to fix them when you make them. To that end we will now go over the kinds of exceptions and errors you will run into and how they can be fixed. Syntax Errors When Python says, \"I have no idea what you are saying.\" This is the simplest problem to fix and is also the most common mistake most programmers make. Syntax errors occur when you make mistakes such as forgetting to close parentheses. When you make these mistakes Python cannot even understand what you are telling it to do. When you run a command on the CLI like $ python a_script.py , Python first passes over the whole script file scanning for syntax errors. Before running any code Python has to make sure that you're giving it valid Python code to parse and run. Once this is done, it begins executing the script line by line until the file ends or an exception is thrown. Therefore you may have noticed that none of your script ran until you fixed everything that was considered a Syntax Error . (See \"Hone Your Skills\" for more on this subject.) Exceptions When Python says, \"I know what you're saying but I can't do that.\" Once Python starts executing code there are many things that can go wrong. Mostly, these consist of you asking Python to do things it was not designed to do. An obvious example is when you attempt to divide by 0 in Python. You can try this by opening the Python interactive prompt and typing >>> 1/0 . This error occurs because you are telling Python \"Divide 1 by 0\" to which Python replies \"I have no idea how to do that,\" and throws an exception. The programmer has to be aware of what these exceptions mean and how to handle them. (See \"Hone Your Skills\" for more on this subject.) Warnings Soft exceptions. Python says, \"I can do that but you're going to have a bad time.\" A warning is like an exception but it doesn't stop the script execution. Generally, you will see warnings when you are getting close to the limits of what Python can do or Python couldn't do exactly what you wanted. There are many different Syntax Errors, Exceptions and Warnings that are built in to python. It is a good idea to learn about as many as you can. (See \"Hone Your Skills\" for more on this subject.) Logic errors When it's not Python it's you. You are not doing what you think you are doing Did you notice that I put the wrong comparison operator on the line that says if fav_number < 3.14 ? You should have realized that the wrong operator was being used and switched it for > . This is an example of a logic error, the hardest kind of error to detect and fix. This is mainly because Python has no idea anything is going wrong. Python is only executing the commands you gave it. If you give Python the wrong commands you cannot expect it to give you the right result.Later on, you will get a chance to make and fix your own logic errors. User Errors You were not prepared for the tidal wave of junk coming your way. Users are stupid. Repeat that 3 times. Get it tattooed on your forehead. Engrave it in your grave stone. One thing to always remember about using the input function is that when you put that in your code you are asking for your program to be abused. You must be ready to handle the situation whatever that may be. A few examples are when you want a number but the user gives you letters or when you want a certain word but the users gives you that word misspelled. With all that said, we will cover how to deal with bad user input in later lessons. But for now just understand that you have no guarantee what your user will provide as input. We saw this in the output for errors.py when the user input 23d for their favorite number. The error happened when Python tried to turn the the string \"23d\" into a number. Python didn't know what to do with it and threw an exception. Bugs and debugging There is a story that you can read in detail here . The story goes that in one of the earliest computers a system failure occurred when a moth got stuck inside the computer. Since then, the terms \"bugs\" and \"debugging\" are a catch-all terms for exceptions and logic errors in a program and the process of identifying and fixing these errors respectively. Much of what programmers do involves debugging programs. As I noted above, the hardest thing to fix is logic errors. Later we will go much more into detail about debugging such errors. However for the purposes of lesson, the above strategy of running and fixing until all the errors disappear is sufficient. Just note for now that this is not the only way nor necessarily the best way of debugging. Hone Your Skills Go to the Python Documentation on errors and exceptions and learn about as many of them as you can. How can you avoid each type of exception? If you come to one that you don't understand don't worry, you'll understand more as you go along. Research defensive programming and test-driven development. How do these practices improve code? Advanced Mastery Research and begin to learn how to use the Python Debugger . This will be more useful for more for larger and more complex programs. Research debugging strategies and begin to implement them in your programs. Previous: 14-If elif and else | Table of Contents | Next: 16-File Reading and Writing","title":"15. Errors Exceptions and Bugs"},{"location":"15-Errors-Exceptions-and-Bugs/#15-errors-exceptions-and-bugs","text":"We are going to \"break\" Python in a lot of ways in this section. Your assignment for this section is to fix all the problems in the following script. For the purposes of this exercise, here is how you should go about doing this: Write out the code exactly as it appears as always Try to run it Each time it breaks or throws an error, fix the error Continue running the script and fixing each error that comes up until the script runs without any errors # errors.py fav_number = input(\"Please enter your favorite number: \" fav_number = float(fav_number) # there is a line of code missing here # pi is the same as \u03c0 and should have a value of 3.14 if fav_number > pi print(\"Your number is bigger than pi!\") else: print(\"Your number is less than or equal to pi!\") print(\"You can print all sorts of \"numbers\" given by the user.\") Here is what should happen This is what should happen as you run it. You should be fixing the problems with the script between each time you attempt to run it. $ python3 errors.py File \"errors.py\", line 5 fav_number = float(fav_number) ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 5 fav_number = float(fav_number) ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 9 if fav_number < pi ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 14 print(\"You can print all sorts of \"numbers\" given by the user.\") ^ SyntaxError: invalid syntax $ python3 errors.py File \"errors.py\", line 14 print(\"You can print all sorts of \\\"numbers\" given by the user.\") ^ SyntaxError: invalid syntax $ python3 errors.py Please enter your favorite number: 23 Traceback (most recent call last): File \"errors.py\", line 9, in <module> if fav_number < pi: NameError: name 'pi' is not defined $ python3 errors.py Please enter your favorite number: 23 Your number is less than or equal to pi! You can print all sorts of \"numbers\" given by the user. $ python3 errors.py Please enter your favorite number: 23 Your number is bigger than pi! You can print all sorts of \"numbers\" given by the user. $ python3 errors.py Please enter your favorite number: 23d Traceback (most recent call last): File \"errors.py\", line 5, in <module> fav_number = float(fav_number) ValueError: could not convert string to float: '23d' $","title":"15 - Errors, Exceptions and Bugs"},{"location":"15-Errors-Exceptions-and-Bugs/#errors-and-exceptions","text":"I am using the term \"error\" loosely here. In reality, there was a time when an error was the computer equivalent of certain death. You see, Python has all sorts of protections and carefully constructed walls up to protect the programmer from him or herself. But it wasn't always this way. Older languages such as C (especially in their earlier years) were perfectly happy to let you crash your entire computer. (It turns out that you could also destroy your hardware too but that's another can of worms we are not getting into here.) From the stand point of these programming languages, an error is a death sentence, at least, for the program in which it occurs. Not to mention, there were potentially a lot of weird side effects from a program that just stopped running unexpectedly. To deal with the problems that this caused, languages like C++ introduced the concept of an \"exception\" in which an error could be caught and handled without breaking the program or computer. In Python, there are no such things as \"errors\", at least in the sense that is described above. Everything is an exception. This means that Python is a relatively forgiving language. You can put any amount of junk in there and generally it will keep you from causing major problems. In fact as you have seen by now, Python does everything it can to help you understand what went wrong and sometimes even tells you how you can fix it. I mentioned in an earlier section that \"There is no such thing as perfect code\". I mean it. Even when you write the simplest programs there are hundreds if not thousands of little things that have to go right for you to get a desired result. And I want you to understand this now as well. You will make mistakes. This doesn't necessarily make you a bad programmer. Mistakes are almost inevitable. What I want you to get from this lesson is to not fear making mistakes and to know how to fix them when you make them. To that end we will now go over the kinds of exceptions and errors you will run into and how they can be fixed.","title":"Errors and Exceptions"},{"location":"15-Errors-Exceptions-and-Bugs/#syntax-errors","text":"When Python says, \"I have no idea what you are saying.\" This is the simplest problem to fix and is also the most common mistake most programmers make. Syntax errors occur when you make mistakes such as forgetting to close parentheses. When you make these mistakes Python cannot even understand what you are telling it to do. When you run a command on the CLI like $ python a_script.py , Python first passes over the whole script file scanning for syntax errors. Before running any code Python has to make sure that you're giving it valid Python code to parse and run. Once this is done, it begins executing the script line by line until the file ends or an exception is thrown. Therefore you may have noticed that none of your script ran until you fixed everything that was considered a Syntax Error . (See \"Hone Your Skills\" for more on this subject.)","title":"Syntax Errors"},{"location":"15-Errors-Exceptions-and-Bugs/#exceptions","text":"When Python says, \"I know what you're saying but I can't do that.\" Once Python starts executing code there are many things that can go wrong. Mostly, these consist of you asking Python to do things it was not designed to do. An obvious example is when you attempt to divide by 0 in Python. You can try this by opening the Python interactive prompt and typing >>> 1/0 . This error occurs because you are telling Python \"Divide 1 by 0\" to which Python replies \"I have no idea how to do that,\" and throws an exception. The programmer has to be aware of what these exceptions mean and how to handle them. (See \"Hone Your Skills\" for more on this subject.)","title":"Exceptions"},{"location":"15-Errors-Exceptions-and-Bugs/#warnings","text":"Soft exceptions. Python says, \"I can do that but you're going to have a bad time.\" A warning is like an exception but it doesn't stop the script execution. Generally, you will see warnings when you are getting close to the limits of what Python can do or Python couldn't do exactly what you wanted. There are many different Syntax Errors, Exceptions and Warnings that are built in to python. It is a good idea to learn about as many as you can. (See \"Hone Your Skills\" for more on this subject.)","title":"Warnings"},{"location":"15-Errors-Exceptions-and-Bugs/#logic-errors","text":"When it's not Python it's you. You are not doing what you think you are doing Did you notice that I put the wrong comparison operator on the line that says if fav_number < 3.14 ? You should have realized that the wrong operator was being used and switched it for > . This is an example of a logic error, the hardest kind of error to detect and fix. This is mainly because Python has no idea anything is going wrong. Python is only executing the commands you gave it. If you give Python the wrong commands you cannot expect it to give you the right result.Later on, you will get a chance to make and fix your own logic errors.","title":"Logic errors"},{"location":"15-Errors-Exceptions-and-Bugs/#user-errors","text":"You were not prepared for the tidal wave of junk coming your way. Users are stupid. Repeat that 3 times. Get it tattooed on your forehead. Engrave it in your grave stone. One thing to always remember about using the input function is that when you put that in your code you are asking for your program to be abused. You must be ready to handle the situation whatever that may be. A few examples are when you want a number but the user gives you letters or when you want a certain word but the users gives you that word misspelled. With all that said, we will cover how to deal with bad user input in later lessons. But for now just understand that you have no guarantee what your user will provide as input. We saw this in the output for errors.py when the user input 23d for their favorite number. The error happened when Python tried to turn the the string \"23d\" into a number. Python didn't know what to do with it and threw an exception.","title":"User Errors"},{"location":"15-Errors-Exceptions-and-Bugs/#bugs-and-debugging","text":"There is a story that you can read in detail here . The story goes that in one of the earliest computers a system failure occurred when a moth got stuck inside the computer. Since then, the terms \"bugs\" and \"debugging\" are a catch-all terms for exceptions and logic errors in a program and the process of identifying and fixing these errors respectively. Much of what programmers do involves debugging programs. As I noted above, the hardest thing to fix is logic errors. Later we will go much more into detail about debugging such errors. However for the purposes of lesson, the above strategy of running and fixing until all the errors disappear is sufficient. Just note for now that this is not the only way nor necessarily the best way of debugging.","title":"Bugs and debugging"},{"location":"15-Errors-Exceptions-and-Bugs/#hone-your-skills","text":"Go to the Python Documentation on errors and exceptions and learn about as many of them as you can. How can you avoid each type of exception? If you come to one that you don't understand don't worry, you'll understand more as you go along. Research defensive programming and test-driven development. How do these practices improve code?","title":"Hone Your Skills"},{"location":"15-Errors-Exceptions-and-Bugs/#advanced-mastery","text":"Research and begin to learn how to use the Python Debugger . This will be more useful for more for larger and more complex programs. Research debugging strategies and begin to implement them in your programs. Previous: 14-If elif and else | Table of Contents | Next: 16-File Reading and Writing","title":"Advanced Mastery"},{"location":"16-File-Reading-and-Writing/","text":"Previous: 15-Errors Exceptions and Bugs | Table of Contents | Next: 17-Loops 16 - File Reading and Writing When we talked about variables and memory I mentioned that there were three basic parts to the computer. They are: The CPU The RAM or volatile memory The hard drive or persistent memory This lesson is an opportunity to interact with the third part, that is the hard drive. We will learn in this lesson how to read and write files from the hard drive. #io_files.py ext = '.txt' user_name = input(\"Enter your name : \") user_age = input(\"Enter your age : \") user_job = input(\"Enter your occupation : \") filename = input(\"Enter a valid filename: \") # let's print out what we got from the user print(f\"\\nHello {user_name}! You are {user_age} years old.\") print(f\"You work as a/an {user_job}\") print(f\"\\nSaving Your Information to \\\"{filename + ext}\\\"...\", end=\"\") # older/worse way of working with files f = open(filename + ext , \"w\") # open in write mode 'w' f.write(\"name,age,occupation\\n\") # write headers to file data = user_name + \",\" # concatenate a string data += user_age + ',' data += user_job + \"\\n\" f.write(data) # then write it to the file f.close() # save and close the file print(\"Done.\") # newer/better way of working with files # always use 4 spaces to indent with open(filename + ext, 'r') as f: # r is for read data = f.read() print(\"\\nHere are your data:\\n---\") print(data) print(\"---\") Here is what should happen $ python io_files.py Enter your name : Mark Enter your age : 92 Enter your occupation : Professional Old Guy Enter a valid filename: mark_info Hello Mark! You are 92 years old. You work as a/an Professional Old Guy Saving Your Information to \"mark_info.txt\"...Done. Here are your data: --- name,age,occupation Mark,92,Professional Old Guy --- $ If you open the file \"mark_info.txt\" that should have appeared in the same folder you will see the following: name,age,occupation Mark,92,Professional Old Guy What is happening here? We are writing and reading files here with a special tool called a file object. A file object from Python's point of view is another data type although that is not the most convenient way of understanding it. Without going too much into detail here is what is happening: We get some data from the user. We organize this data into a table where the rows are separated by newline characters ( \\n ) and the columns are separated in each row by commas ( , ). We give this table headers and concatenate this string all together using the addition operator. We call open on a string containing a filename which returns a file object. We feed appropriate method statements to the file object to read, write or save and close the object. The file is altered as we alter the object. Some of this nomenclature is new. I will now explain some of the newer concepts below. Objects In Python, every variable you work with is an object. Objects are instances of types just as you are an instance of a human. Read that last sentence over again. A type, as I explained before, is a mark that a computer puts on a 'box' or set of 'boxes' in volatile memory. It is a label that lets the computer know how to work with those boxes. An object is those boxes themselves. An object may have a type assigned to it just as you have the label \"human\" or \"homo sapien\" assigned to you. For example, when you have a string variable, virtually speaking you have a set of boxes in a certain order and each box has a character in it. In addition, you have other boxes that contain the code that makes .format work and everything else the string needs to know how to do what it does. Collectively, all these boxes together in memory are the object. This nomenclature will be used often so it's important to internalize this concept early. File Objects and Methods Now that we have discussed objects lets look specifically at file objects. Lets begin with the open built-in function. The basic usage for the open function has the following form and arguments: open(filename, mode) where filename is the name of the file (okay maybe that's obvious) you want to open and mode is the way you want to open the file. The basic ways you can open a file are: 'r' for read mode. In this mode the file can only be read (this is sometimes called \"read-only\" mode). This is the default mode, meaning if you do not give the open function a mode it will assume read mode. Because you are in read mode operations like .write() will throw an error. Also, if the filename you are put into filename doesn't exist that will also throw an error. The .read() method returns the entirety of the file as a string. Experiment with this function. What happens when you try to call .read() twice? 'w' for write mode. Write mode will automatically overwrite whatever was previously in the file. This may also be considered a \"write-only\" mode, meaning methods like .read() will throw an error. However, unlike read mode, if the filename does not exist, open(\"filename.txt\", 'w') will create a new file with the name \"filename.txt\". 'a' for append mode. This mode is like write mode in that methods like .read() will throw an error. It is also like read mode in that if the filename doesn't exist it will also throw an error. It is used to write without truncating and simply appends text to the end of files. However using methods like the ones here , you can edit files directly. (With that said and depending onthere are better ways to do this that we will cover later.) There are ways to combine these that you can experiment with in \"Hone Your Skills\" below. with Statements To save the changes we made to the file we opened in f = open(filename + ext , \"w\") , we need to call f.close() on our file object. This ends up being a problem if you forget to call f.close() on the object. A better way to deal with files is with a with statement. To be clear the following code snippet: f = open(filename + ext , \"w\") f.write(\"name,age,occupation\\n\") data = user_name + \",\" data += user_age + ',' data += user_job + \"\\n\" f.write(data) f.close() is equivalent to: with open(filename + ext , \"w\") as f: f.write(\"name,age,occupation\\n\") data = user_name + \",\" data += user_age + ',' data += user_job + \"\\n\" f.write(data) Not only does the second code snippet use fewer lines of code but it is clear by looking at the indented block when you are working with the file and when you are done. The with statement simply remembers to close the file when the indented block ends. Whenever you work with files you should always use a with statement (unless you have a very good reason not to do so). Hone Your Skills Remember to use with statements in all the following exercises. Try using the three basic ways of writing files ( 'r','w','a' ). Try to write a paragraph of text to a file, close it and edit it again, putting a line of text at the beginning and end of the file. How would you do this? Experiment with the ways of opening a file by trying the combined and other options (e.g. r+ , 'wb+' etc.) for opening files. You can read about them here . How do they differ? Research the open() function and learn all you can about how it works. The official Python reference is here . Advanced Mastery Try to open and read a non-.txt file with Python. Were you able to read it? Research why or why not. Read about the complete list of methods for working with files here . How could you use these methods? Previous: 15-Errors Exceptions and Bugs | Table of Contents | Next: 17-Loops","title":"16. File Reading and Writing"},{"location":"16-File-Reading-and-Writing/#16-file-reading-and-writing","text":"When we talked about variables and memory I mentioned that there were three basic parts to the computer. They are: The CPU The RAM or volatile memory The hard drive or persistent memory This lesson is an opportunity to interact with the third part, that is the hard drive. We will learn in this lesson how to read and write files from the hard drive. #io_files.py ext = '.txt' user_name = input(\"Enter your name : \") user_age = input(\"Enter your age : \") user_job = input(\"Enter your occupation : \") filename = input(\"Enter a valid filename: \") # let's print out what we got from the user print(f\"\\nHello {user_name}! You are {user_age} years old.\") print(f\"You work as a/an {user_job}\") print(f\"\\nSaving Your Information to \\\"{filename + ext}\\\"...\", end=\"\") # older/worse way of working with files f = open(filename + ext , \"w\") # open in write mode 'w' f.write(\"name,age,occupation\\n\") # write headers to file data = user_name + \",\" # concatenate a string data += user_age + ',' data += user_job + \"\\n\" f.write(data) # then write it to the file f.close() # save and close the file print(\"Done.\") # newer/better way of working with files # always use 4 spaces to indent with open(filename + ext, 'r') as f: # r is for read data = f.read() print(\"\\nHere are your data:\\n---\") print(data) print(\"---\") Here is what should happen $ python io_files.py Enter your name : Mark Enter your age : 92 Enter your occupation : Professional Old Guy Enter a valid filename: mark_info Hello Mark! You are 92 years old. You work as a/an Professional Old Guy Saving Your Information to \"mark_info.txt\"...Done. Here are your data: --- name,age,occupation Mark,92,Professional Old Guy --- $ If you open the file \"mark_info.txt\" that should have appeared in the same folder you will see the following: name,age,occupation Mark,92,Professional Old Guy What is happening here? We are writing and reading files here with a special tool called a file object. A file object from Python's point of view is another data type although that is not the most convenient way of understanding it. Without going too much into detail here is what is happening: We get some data from the user. We organize this data into a table where the rows are separated by newline characters ( \\n ) and the columns are separated in each row by commas ( , ). We give this table headers and concatenate this string all together using the addition operator. We call open on a string containing a filename which returns a file object. We feed appropriate method statements to the file object to read, write or save and close the object. The file is altered as we alter the object. Some of this nomenclature is new. I will now explain some of the newer concepts below.","title":"16 - File Reading and Writing"},{"location":"16-File-Reading-and-Writing/#objects","text":"In Python, every variable you work with is an object. Objects are instances of types just as you are an instance of a human. Read that last sentence over again. A type, as I explained before, is a mark that a computer puts on a 'box' or set of 'boxes' in volatile memory. It is a label that lets the computer know how to work with those boxes. An object is those boxes themselves. An object may have a type assigned to it just as you have the label \"human\" or \"homo sapien\" assigned to you. For example, when you have a string variable, virtually speaking you have a set of boxes in a certain order and each box has a character in it. In addition, you have other boxes that contain the code that makes .format work and everything else the string needs to know how to do what it does. Collectively, all these boxes together in memory are the object. This nomenclature will be used often so it's important to internalize this concept early.","title":"Objects"},{"location":"16-File-Reading-and-Writing/#file-objects-and-methods","text":"Now that we have discussed objects lets look specifically at file objects. Lets begin with the open built-in function. The basic usage for the open function has the following form and arguments: open(filename, mode) where filename is the name of the file (okay maybe that's obvious) you want to open and mode is the way you want to open the file. The basic ways you can open a file are: 'r' for read mode. In this mode the file can only be read (this is sometimes called \"read-only\" mode). This is the default mode, meaning if you do not give the open function a mode it will assume read mode. Because you are in read mode operations like .write() will throw an error. Also, if the filename you are put into filename doesn't exist that will also throw an error. The .read() method returns the entirety of the file as a string. Experiment with this function. What happens when you try to call .read() twice? 'w' for write mode. Write mode will automatically overwrite whatever was previously in the file. This may also be considered a \"write-only\" mode, meaning methods like .read() will throw an error. However, unlike read mode, if the filename does not exist, open(\"filename.txt\", 'w') will create a new file with the name \"filename.txt\". 'a' for append mode. This mode is like write mode in that methods like .read() will throw an error. It is also like read mode in that if the filename doesn't exist it will also throw an error. It is used to write without truncating and simply appends text to the end of files. However using methods like the ones here , you can edit files directly. (With that said and depending onthere are better ways to do this that we will cover later.) There are ways to combine these that you can experiment with in \"Hone Your Skills\" below.","title":"File Objects and Methods"},{"location":"16-File-Reading-and-Writing/#with-statements","text":"To save the changes we made to the file we opened in f = open(filename + ext , \"w\") , we need to call f.close() on our file object. This ends up being a problem if you forget to call f.close() on the object. A better way to deal with files is with a with statement. To be clear the following code snippet: f = open(filename + ext , \"w\") f.write(\"name,age,occupation\\n\") data = user_name + \",\" data += user_age + ',' data += user_job + \"\\n\" f.write(data) f.close() is equivalent to: with open(filename + ext , \"w\") as f: f.write(\"name,age,occupation\\n\") data = user_name + \",\" data += user_age + ',' data += user_job + \"\\n\" f.write(data) Not only does the second code snippet use fewer lines of code but it is clear by looking at the indented block when you are working with the file and when you are done. The with statement simply remembers to close the file when the indented block ends. Whenever you work with files you should always use a with statement (unless you have a very good reason not to do so).","title":"with Statements"},{"location":"16-File-Reading-and-Writing/#hone-your-skills","text":"Remember to use with statements in all the following exercises. Try using the three basic ways of writing files ( 'r','w','a' ). Try to write a paragraph of text to a file, close it and edit it again, putting a line of text at the beginning and end of the file. How would you do this? Experiment with the ways of opening a file by trying the combined and other options (e.g. r+ , 'wb+' etc.) for opening files. You can read about them here . How do they differ? Research the open() function and learn all you can about how it works. The official Python reference is here .","title":"Hone Your Skills"},{"location":"16-File-Reading-and-Writing/#advanced-mastery","text":"Try to open and read a non-.txt file with Python. Were you able to read it? Research why or why not. Read about the complete list of methods for working with files here . How could you use these methods? Previous: 15-Errors Exceptions and Bugs | Table of Contents | Next: 17-Loops","title":"Advanced Mastery"},{"location":"17-Loops/","text":"Previous: 16-File Reading and Writing | Table of Contents | Next: 18-Iterables 17 - Loops We are about to introduce another fundamental aspect of programming that will be used over and over again in programming. We will, as always, introduce the subject in an example script. # loops.py # we need to print numbers 1 - 5 with each # number on its own line so: print(1) print(2) print(3) print(4) print(5) # there is a better way of doing this print(\"\") n = 1 while n <= 5: print(n) n += 1 # better! that only took 4 lines of code # but here is a better way print(\"\") for n in range(5): print(n + 1) Here is what should happen $ python loops.py 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 $ What is happening here? Here we see the concept of a loop. We just did the same thing (i.e. print numbers 1-5 with each number on its own line) 3 different ways. We will briefly touch on the pros and cons of each way of doing this particular task: Writing out each print statement: Never do this. Just don't. Not only is this tedious to do but if you want to do this for 1-10 or 1-1,000,000 the second and third ways require a change to only one variable. This way literally requires 10 or 1,000,000 lines of code respectively. Now that you have seen how terrible this is I will never ask you to do it again. (Remember, the point of programming is to make the computer do the work, not you.) A while-loop: The way we have used the while-loop here is not how while-loops should be used. I am only showing it here to introduce the syntax. Again, I have asked you to do it this way once so that we can explore the syntax. After this lesson you should NEVER use it this way again. (If you're confused about what \"this way\" is, don't worry, I'll explain it below.) A for-loop: This is, by far, the optimal way to do this particular task. A for-loop is perfect for when you know exactly how many times you want to loop. I will explain while-loops and for-loops below. while-loops I consider while-loops to generally be more simple than for loops. The while-loop follows the following syntax: while truth_expression: do_things1 do_things2 ... # end of the indented block This can be read as \"While truth_expression evaluates to True , do_things or else end the loop.\" The while-loop proceeds as follows: The truth_expression is some conditional expression like var > 3 If truth_expression evaluates to True : The statements in the indented block are executed in order until the block ends The code then returns to the while statement and evaluates the truth_expression again and the process starts over. This will repeat until truth_expression evaluates to False . If at any time truth_expression evaluates to False , the indented block is skipped over and the code continues normally. truth_expression is sometimes known as the loop exit condition . For the while-loop we did in loops.py , we wanted to loop a particular number of times so we initialized n to 1 and then incremented n each time before the loop started again. for-loops The built-in function range produces a range object which is a type of iterable . An iterable is something in code that produces a sequence that can give each value one at a time. It can do this through a number of methods that we will not cover here. In the case of range however, it produces a sequence of integer numbers starting with 0. (Remember: Python counting always starts with 0.) The sequence increments by integers up to but not including the number passed as an argument. (Note: range can be modified to do other things but we will get to that later.) In our case, that means that range(5) produced the sequence: 0, 1, 2, 3, 4 . This is a common way to say that we want to do something 5 times (as we see the sequence is 5 elements long) or to count up to from 0 to 4. The range function is a common way to do a for-loop but any iterable will do. We will learn more about ranges in the next lesson. For-loops follow the following syntax: for i in iterable: do_things1 do_things2 ... # end of the indented block A for-loop will only repeat as many times as the iterable fed to it allows. (Again in loops.py , this was 5 times.) It also has the feature that, before each time that the loop runs, it defines a variable (which, in the example above, is i but you can name it whatever you want) based on the current element of the iterable. Therefore, i gets redefined for every iteration of the loop based on the next element of iterable . Other than that, the statements executed in the indented block are done normally and an un-indentation indicates that the loop block is done and the loop can continue. Once the iterable has run out of values to give to i , the loop terminates and code continues normally. In my estimation, for-loops are one of the most powerful features in programming and, as we discussed above, are closely connected with iterables. In the next lesson we will talk more in depth about iterables and how to make and use them. Hone Your Skills For the while loop in loops.py , there are a number of ways we can change the loop exit condition so that the code is technically different but it does the same thing. What are some ways we can change the loop exit condition to do the same thing? How would each of these be better or worse than the original? Play around with the code in loops.py and try to change what the range function does in a for-loop. Can you make it start at a number other than 0? Can you make it count by 2s or 3s? Can you make it count down instead of up? (Hint: The documentation here should be helpful.) Previous: 16-File Reading and Writing | Table of Contents | Next: 18-Iterables","title":"17. Loops"},{"location":"17-Loops/#17-loops","text":"We are about to introduce another fundamental aspect of programming that will be used over and over again in programming. We will, as always, introduce the subject in an example script. # loops.py # we need to print numbers 1 - 5 with each # number on its own line so: print(1) print(2) print(3) print(4) print(5) # there is a better way of doing this print(\"\") n = 1 while n <= 5: print(n) n += 1 # better! that only took 4 lines of code # but here is a better way print(\"\") for n in range(5): print(n + 1) Here is what should happen $ python loops.py 1 2 3 4 5 1 2 3 4 5 1 2 3 4 5 $ What is happening here? Here we see the concept of a loop. We just did the same thing (i.e. print numbers 1-5 with each number on its own line) 3 different ways. We will briefly touch on the pros and cons of each way of doing this particular task: Writing out each print statement: Never do this. Just don't. Not only is this tedious to do but if you want to do this for 1-10 or 1-1,000,000 the second and third ways require a change to only one variable. This way literally requires 10 or 1,000,000 lines of code respectively. Now that you have seen how terrible this is I will never ask you to do it again. (Remember, the point of programming is to make the computer do the work, not you.) A while-loop: The way we have used the while-loop here is not how while-loops should be used. I am only showing it here to introduce the syntax. Again, I have asked you to do it this way once so that we can explore the syntax. After this lesson you should NEVER use it this way again. (If you're confused about what \"this way\" is, don't worry, I'll explain it below.) A for-loop: This is, by far, the optimal way to do this particular task. A for-loop is perfect for when you know exactly how many times you want to loop. I will explain while-loops and for-loops below.","title":"17 - Loops"},{"location":"17-Loops/#while-loops","text":"I consider while-loops to generally be more simple than for loops. The while-loop follows the following syntax: while truth_expression: do_things1 do_things2 ... # end of the indented block This can be read as \"While truth_expression evaluates to True , do_things or else end the loop.\" The while-loop proceeds as follows: The truth_expression is some conditional expression like var > 3 If truth_expression evaluates to True : The statements in the indented block are executed in order until the block ends The code then returns to the while statement and evaluates the truth_expression again and the process starts over. This will repeat until truth_expression evaluates to False . If at any time truth_expression evaluates to False , the indented block is skipped over and the code continues normally. truth_expression is sometimes known as the loop exit condition . For the while-loop we did in loops.py , we wanted to loop a particular number of times so we initialized n to 1 and then incremented n each time before the loop started again.","title":"while-loops"},{"location":"17-Loops/#for-loops","text":"The built-in function range produces a range object which is a type of iterable . An iterable is something in code that produces a sequence that can give each value one at a time. It can do this through a number of methods that we will not cover here. In the case of range however, it produces a sequence of integer numbers starting with 0. (Remember: Python counting always starts with 0.) The sequence increments by integers up to but not including the number passed as an argument. (Note: range can be modified to do other things but we will get to that later.) In our case, that means that range(5) produced the sequence: 0, 1, 2, 3, 4 . This is a common way to say that we want to do something 5 times (as we see the sequence is 5 elements long) or to count up to from 0 to 4. The range function is a common way to do a for-loop but any iterable will do. We will learn more about ranges in the next lesson. For-loops follow the following syntax: for i in iterable: do_things1 do_things2 ... # end of the indented block A for-loop will only repeat as many times as the iterable fed to it allows. (Again in loops.py , this was 5 times.) It also has the feature that, before each time that the loop runs, it defines a variable (which, in the example above, is i but you can name it whatever you want) based on the current element of the iterable. Therefore, i gets redefined for every iteration of the loop based on the next element of iterable . Other than that, the statements executed in the indented block are done normally and an un-indentation indicates that the loop block is done and the loop can continue. Once the iterable has run out of values to give to i , the loop terminates and code continues normally. In my estimation, for-loops are one of the most powerful features in programming and, as we discussed above, are closely connected with iterables. In the next lesson we will talk more in depth about iterables and how to make and use them.","title":"for-loops"},{"location":"17-Loops/#hone-your-skills","text":"For the while loop in loops.py , there are a number of ways we can change the loop exit condition so that the code is technically different but it does the same thing. What are some ways we can change the loop exit condition to do the same thing? How would each of these be better or worse than the original? Play around with the code in loops.py and try to change what the range function does in a for-loop. Can you make it start at a number other than 0? Can you make it count by 2s or 3s? Can you make it count down instead of up? (Hint: The documentation here should be helpful.) Previous: 16-File Reading and Writing | Table of Contents | Next: 18-Iterables","title":"Hone Your Skills"},{"location":"18-Iterables/","text":"Previous: 17-Loops | Table of Contents | Next: 19-Dictionaries 18 - Iterables The Python Documentation defines an iterable this way: Iterable: An object capable of returning its members one at a time. Iterables are a powerful way to structure data. In this lesson, we will introduce a common type of iterable called sequenced types and explore how to use them. Note that there are many iterable types that we will not cover here but these (the sequenced types) are the most common. This is the longest exercise you've done so far so don't get complacent. Make sure that it is exactly as it appears here. # iterables.py # --- strings --- example_string = \"Hello World!\" print(\"A string:\", example_string) print(\"\") # white space to make output readable # --- ranges --- example_range = range(5) print(\"A range:\", example_range) print(\"\") # --- lists --- # brackets initialize a list example_list = [\"tea\", \"biscuts\", \"crackers\", \"kale\"] print(\"A list:\", example_list) # lists are mutable print(\"adding cheese to the list...\") example_list.append(\"cheese\") print(example_list) print(\"changing the first element to 'Lemon Tea'...\") example_list[0] = \"Lemon Tea\" print(example_list) print(\"popping off the last element...\") example_list.pop() print(example_list) print(\"\") # --- tuples --- # parethesis define a tuple example_tuple = (\"tea\", \"biscuts\", \"crackers\", \"kale\") print(\"A tuple:\", example_tuple) # a comma-separated list can also define a tuple example_tuple = \"biscuts\", \"crackers\", \"kale\", \"tea\" print(\"Another tuple:\", example_tuple) # tuples are immutable # notice how this throws an error: # comment it out after you have looked at the error # example_tuple[-1] = \"Lemon tea\" # throws an error print(\"\") # --- Common among iterables --- # all iterables are subscriptable and sliceable print(\"The last element and\") print(\"The first two elements of each iterable:\") print(\"Last:\", example_string[-1]) print(\"First two:\",example_string[:2]) print(\"Last:\", example_range[-1]) print(\"First two:\",example_range[:2]) print(\"Last:\", example_list[-1]) print(\"First two:\",example_list[:2]) print(\"Last:\", example_tuple[-1]) print(\"First two:\",example_tuple[:2]) print(\"\") # all iterables have a length (len()) print(\"length of string: \", len(example_string)) print(\"length of range: \", len(example_range)) print(\"length of list: \", len(example_list)) print(\"length of tuple: \", len(example_tuple)) print(\"\") # all iterables can be used to make for-loops print(\"For-loop examples of each:\") for character in example_string: print(character, end=\" \") print(\"\") for index_value in example_range: print(index_value, end=\" \") print(\"\") for element in example_list: print(element, end=\" \") print(\"\") for variable in example_tuple: print(variable, end=\" \") print(\"\\n\") # you can check if something is 'in' # a sequence iterable print('\"Hello\" in example_string:', \"Hello\" in example_string) print('3 in example_range:', 3 in example_range) print('\"kale\" in example_list:', \"kale\" in example_list) print('\"potatoes\" in example_tuple:', \"potatoes\" in example_tuple) Here is what should happen $ python iterables.py A string: Hello World! A range: range(0, 5) A list: ['tea', 'biscuts', 'crackers', 'kale'] adding cheese to the list... ['tea', 'biscuts', 'crackers', 'kale', 'cheese'] changing the first element to 'Lemon Tea'... ['Lemon Tea', 'biscuts', 'crackers', 'kale', 'cheese'] popping off the last element... ['Lemon Tea', 'biscuts', 'crackers', 'kale'] A tuple: ('tea', 'biscuts', 'crackers', 'kale') Another tuple: ('biscuts', 'crackers', 'kale', 'tea') The last element and The first two elements of each iterable: Last: ! First two: He Last: 4 First two: range(0, 2) Last: kale First two: ['Lemon Tea', 'biscuts'] Last: tea First two: ('biscuts', 'crackers') length of string: 12 length of range: 5 length of list: 4 length of tuple: 4 For-loop examples of each: H e l l o W o r l d ! 0 1 2 3 4 Lemon Tea biscuts crackers kale biscuts crackers kale tea \"Hello\" in example_string: True 3 in example_range: True \"kale\" in example_list: True \"potatoes\" in example_tuple: False $ What is happening here? We have just dumped a lot of information on you. This is probably the longest script you've written yet. We will go through each step by step. Lets start with each type of iterable. String We have already covered a lot about strings. It turns out, however, that strings are iterables and have all the properties that we see at the end of the script. We will deal with these in more detail below but just understand that strings have all those common properties. Range Ranges can be thought of as a very specific subset of a list. The subset is a list of integers with a set pattern. Ranges are most useful in for-loop construction when you want a loop to run a specific number of times. They have other uses but the for-loop case is most common. List A list is a very powerful sequence type. Unlike a string which must contain only letters and a range which can only contain integers in a specified order, a list is exactly what it sounds like. A list is an object that holds objects or references to objects in a specified order. A list could be a shopping list where the elements are strings: shopping_list = [\"cheese\" \"milk\", \"sugar\", \"eggs\"] or it could be a list of names of a bunch of file objects: files = [file1, file2, file3] or it could be a bunch of different types of objects: objects = [12, 23.5, \"Nougat\"] The point is, lists can do many things and can be the structure for many types of data. A common use of lists for example is to define matrices for math: matrix_a = [ [1,2,3], [4,5,6], [7,8,9]] which is just a lists of lists of numbers. They have all sorts of methods tied to them that can be used to manipulate data. For many of the more complex problems we will tackle, lists or list-like object will be our work horse. Tuple Tuples are interesting beasts in Python. Without getting into gory details, tuples are like lists that cannot be changed once they are created and are fixed in memory. You may think of them as a \"read-only\" list. You may rightly ask why they even exist if all they appear to be is a less-useful list. The advantage of tuples is that, because they cannot be changed, the computer can use them more efficiently. However, they do have some uses that can be of interest. (See Hone Your Skills for more on this.) Subscripts and Slices A useful feature all sequenced iterators have is that of subscripting and slicing. It may not be clear what this means however. The following two operations allow us to conveniently work with sequenced iterables. Subscript Suppose we have a list of strings like shopping_list = [\"cheese\" \"milk\", \"sugar\", \"eggs\"] and we just want to get \"sugar\" out of the list. We can do that through subscripting. The \"subscript\" or \"get item\" operator is the pair of brackets after the name of the iterator (in this case, shopping_list[] ). The number that goes between the brackets is the index of the item that is being retrieved. Therefore, if we want to get \"sugar\" out of the list we can store it in a new variable like this: sugar_item = shopping_list[2] . (Remember that Python indices start with 0 so the third item in the list has an index of 2.) Slice Slicing is just like subscripting but instead of getting one element of the list we are getting multiple adjacent elements. The syntax is as follows. list_name[first_index : second_index] where first_index is the first included element in the slice and second_element is the first element not included in the slice. Therefore if we write shopping_list[1:3] we get ['sugar', 'eggs'] back. This is because we are including element 1 and 2 but not 3 . Also, shopping_list[2:3] is not the same as shopping_list[2] but instead, returns the same type of iterable with a length of 1 containing shopping_list[2] . If the first_index is omitted, everything from the beginning to the second_index is extracted. Likewise, if second_index is omitted, everything from first_index to the end is extracted. For-loops, Length and the in operator Each of the properties that we used in iterables.py that are common to all iterables are both useful and easy to understand given the context we now have. For-loops: Any iterable used in the definition of a for-loop is defined (as in the lesson on loops) as for i in iterable: where i can be called the loop variable. In the case of any sequenced iterable the loop variable takes on the next value in the sequence for each loop. len() : This is a built-in function that can find the length of any iterable if it is at all possible. The function has many uses including use for referencing by index instead of element ( i.e. using range(len(iterable)) instead of just iterable .) The in operator will return true if the operand on the left exists as one of the elements on the right or if a series of elements exist on the right. And the logic reads just like in English. Hone Your Skills Look at documentation on lists . Lists can do a lot of things, experiment with each method listed in the documentation. What are some different ways you could use a list? The three things common to all iterables we did in iterables.py are not the only things you can do to all the sequenced iterables. Look at the Documentation for operations that can be performed on all the iterables. Experiment with all of these and find out how you could find a delete a particular value from a list using these operations. Try putting negative numbers into the subscript operator. Start with -1 . What happens? How can you use this to your advantage? Look up the documentation on tuples and learn how to pack and unpack variables. How could this be useful? Previous: 17-Loops | Table of Contents | Next: 19-Dictionaries","title":"18. Iterables"},{"location":"18-Iterables/#18-iterables","text":"The Python Documentation defines an iterable this way: Iterable: An object capable of returning its members one at a time. Iterables are a powerful way to structure data. In this lesson, we will introduce a common type of iterable called sequenced types and explore how to use them. Note that there are many iterable types that we will not cover here but these (the sequenced types) are the most common. This is the longest exercise you've done so far so don't get complacent. Make sure that it is exactly as it appears here. # iterables.py # --- strings --- example_string = \"Hello World!\" print(\"A string:\", example_string) print(\"\") # white space to make output readable # --- ranges --- example_range = range(5) print(\"A range:\", example_range) print(\"\") # --- lists --- # brackets initialize a list example_list = [\"tea\", \"biscuts\", \"crackers\", \"kale\"] print(\"A list:\", example_list) # lists are mutable print(\"adding cheese to the list...\") example_list.append(\"cheese\") print(example_list) print(\"changing the first element to 'Lemon Tea'...\") example_list[0] = \"Lemon Tea\" print(example_list) print(\"popping off the last element...\") example_list.pop() print(example_list) print(\"\") # --- tuples --- # parethesis define a tuple example_tuple = (\"tea\", \"biscuts\", \"crackers\", \"kale\") print(\"A tuple:\", example_tuple) # a comma-separated list can also define a tuple example_tuple = \"biscuts\", \"crackers\", \"kale\", \"tea\" print(\"Another tuple:\", example_tuple) # tuples are immutable # notice how this throws an error: # comment it out after you have looked at the error # example_tuple[-1] = \"Lemon tea\" # throws an error print(\"\") # --- Common among iterables --- # all iterables are subscriptable and sliceable print(\"The last element and\") print(\"The first two elements of each iterable:\") print(\"Last:\", example_string[-1]) print(\"First two:\",example_string[:2]) print(\"Last:\", example_range[-1]) print(\"First two:\",example_range[:2]) print(\"Last:\", example_list[-1]) print(\"First two:\",example_list[:2]) print(\"Last:\", example_tuple[-1]) print(\"First two:\",example_tuple[:2]) print(\"\") # all iterables have a length (len()) print(\"length of string: \", len(example_string)) print(\"length of range: \", len(example_range)) print(\"length of list: \", len(example_list)) print(\"length of tuple: \", len(example_tuple)) print(\"\") # all iterables can be used to make for-loops print(\"For-loop examples of each:\") for character in example_string: print(character, end=\" \") print(\"\") for index_value in example_range: print(index_value, end=\" \") print(\"\") for element in example_list: print(element, end=\" \") print(\"\") for variable in example_tuple: print(variable, end=\" \") print(\"\\n\") # you can check if something is 'in' # a sequence iterable print('\"Hello\" in example_string:', \"Hello\" in example_string) print('3 in example_range:', 3 in example_range) print('\"kale\" in example_list:', \"kale\" in example_list) print('\"potatoes\" in example_tuple:', \"potatoes\" in example_tuple) Here is what should happen $ python iterables.py A string: Hello World! A range: range(0, 5) A list: ['tea', 'biscuts', 'crackers', 'kale'] adding cheese to the list... ['tea', 'biscuts', 'crackers', 'kale', 'cheese'] changing the first element to 'Lemon Tea'... ['Lemon Tea', 'biscuts', 'crackers', 'kale', 'cheese'] popping off the last element... ['Lemon Tea', 'biscuts', 'crackers', 'kale'] A tuple: ('tea', 'biscuts', 'crackers', 'kale') Another tuple: ('biscuts', 'crackers', 'kale', 'tea') The last element and The first two elements of each iterable: Last: ! First two: He Last: 4 First two: range(0, 2) Last: kale First two: ['Lemon Tea', 'biscuts'] Last: tea First two: ('biscuts', 'crackers') length of string: 12 length of range: 5 length of list: 4 length of tuple: 4 For-loop examples of each: H e l l o W o r l d ! 0 1 2 3 4 Lemon Tea biscuts crackers kale biscuts crackers kale tea \"Hello\" in example_string: True 3 in example_range: True \"kale\" in example_list: True \"potatoes\" in example_tuple: False $ What is happening here? We have just dumped a lot of information on you. This is probably the longest script you've written yet. We will go through each step by step. Lets start with each type of iterable.","title":"18 - Iterables"},{"location":"18-Iterables/#string","text":"We have already covered a lot about strings. It turns out, however, that strings are iterables and have all the properties that we see at the end of the script. We will deal with these in more detail below but just understand that strings have all those common properties.","title":"String"},{"location":"18-Iterables/#range","text":"Ranges can be thought of as a very specific subset of a list. The subset is a list of integers with a set pattern. Ranges are most useful in for-loop construction when you want a loop to run a specific number of times. They have other uses but the for-loop case is most common.","title":"Range"},{"location":"18-Iterables/#list","text":"A list is a very powerful sequence type. Unlike a string which must contain only letters and a range which can only contain integers in a specified order, a list is exactly what it sounds like. A list is an object that holds objects or references to objects in a specified order. A list could be a shopping list where the elements are strings: shopping_list = [\"cheese\" \"milk\", \"sugar\", \"eggs\"] or it could be a list of names of a bunch of file objects: files = [file1, file2, file3] or it could be a bunch of different types of objects: objects = [12, 23.5, \"Nougat\"] The point is, lists can do many things and can be the structure for many types of data. A common use of lists for example is to define matrices for math: matrix_a = [ [1,2,3], [4,5,6], [7,8,9]] which is just a lists of lists of numbers. They have all sorts of methods tied to them that can be used to manipulate data. For many of the more complex problems we will tackle, lists or list-like object will be our work horse.","title":"List"},{"location":"18-Iterables/#tuple","text":"Tuples are interesting beasts in Python. Without getting into gory details, tuples are like lists that cannot be changed once they are created and are fixed in memory. You may think of them as a \"read-only\" list. You may rightly ask why they even exist if all they appear to be is a less-useful list. The advantage of tuples is that, because they cannot be changed, the computer can use them more efficiently. However, they do have some uses that can be of interest. (See Hone Your Skills for more on this.)","title":"Tuple"},{"location":"18-Iterables/#subscripts-and-slices","text":"A useful feature all sequenced iterators have is that of subscripting and slicing. It may not be clear what this means however. The following two operations allow us to conveniently work with sequenced iterables. Subscript Suppose we have a list of strings like shopping_list = [\"cheese\" \"milk\", \"sugar\", \"eggs\"] and we just want to get \"sugar\" out of the list. We can do that through subscripting. The \"subscript\" or \"get item\" operator is the pair of brackets after the name of the iterator (in this case, shopping_list[] ). The number that goes between the brackets is the index of the item that is being retrieved. Therefore, if we want to get \"sugar\" out of the list we can store it in a new variable like this: sugar_item = shopping_list[2] . (Remember that Python indices start with 0 so the third item in the list has an index of 2.) Slice Slicing is just like subscripting but instead of getting one element of the list we are getting multiple adjacent elements. The syntax is as follows. list_name[first_index : second_index] where first_index is the first included element in the slice and second_element is the first element not included in the slice. Therefore if we write shopping_list[1:3] we get ['sugar', 'eggs'] back. This is because we are including element 1 and 2 but not 3 . Also, shopping_list[2:3] is not the same as shopping_list[2] but instead, returns the same type of iterable with a length of 1 containing shopping_list[2] . If the first_index is omitted, everything from the beginning to the second_index is extracted. Likewise, if second_index is omitted, everything from first_index to the end is extracted.","title":"Subscripts and Slices"},{"location":"18-Iterables/#for-loops-length-and-the-in-operator","text":"Each of the properties that we used in iterables.py that are common to all iterables are both useful and easy to understand given the context we now have. For-loops: Any iterable used in the definition of a for-loop is defined (as in the lesson on loops) as for i in iterable: where i can be called the loop variable. In the case of any sequenced iterable the loop variable takes on the next value in the sequence for each loop. len() : This is a built-in function that can find the length of any iterable if it is at all possible. The function has many uses including use for referencing by index instead of element ( i.e. using range(len(iterable)) instead of just iterable .) The in operator will return true if the operand on the left exists as one of the elements on the right or if a series of elements exist on the right. And the logic reads just like in English.","title":"For-loops, Length and the in operator"},{"location":"18-Iterables/#hone-your-skills","text":"Look at documentation on lists . Lists can do a lot of things, experiment with each method listed in the documentation. What are some different ways you could use a list? The three things common to all iterables we did in iterables.py are not the only things you can do to all the sequenced iterables. Look at the Documentation for operations that can be performed on all the iterables. Experiment with all of these and find out how you could find a delete a particular value from a list using these operations. Try putting negative numbers into the subscript operator. Start with -1 . What happens? How can you use this to your advantage? Look up the documentation on tuples and learn how to pack and unpack variables. How could this be useful? Previous: 17-Loops | Table of Contents | Next: 19-Dictionaries","title":"Hone Your Skills"},{"location":"19-Dictionaries/","text":"Previous: 18-Iterables | Table of Contents | Next: 20-Functions 20 - Dictionaries In the last lesson we learned about sequenced iterables. In this lesson we will learn about one of the most powerful iterables that does not exist in a sequence. This is called a dictionary. The following lesson will introduce and illustrate how to use a dictionary. # dictionary_practice.py # curly braces or just \"braces\" define a dictionary player_data = {\"Name\":\"Jack\", \"Team\":\"Wildcats\", \"Wins\":3} # we subscript with a keyword instead of an index, print(player_data[\"Name\"]) print(player_data[\"Team\"]) print(player_data[\"Wins\"],\"\\n\") # a dictionary is an iterable for key in player_data: print(key, \":\", player_data[key]) print(\"\") # another possibly better way to do the same thing for key, value in player_data.items(): print(key, \":\", value) print(\"\") # dictionaries are mutable and extendable player_data[\"Wins\"] += 1 player_data[\"Height\"] = \"6'2\\\"\" for key, value in player_data.items(): print(key, \":\", value) print(\"\") # you can also delete items too del player_data[\"Height\"] for key, value in player_data.items(): print(key, \":\", value) Here is what should happen $ python dictionary_practice.py Jack Wildcats 3 Name : Jack Team : Wildcats Wins : 3 Name : Jack Team : Wildcats Wins : 3 Name : Jack Team : Wildcats Wins : 4 Height : 6'2\" Name : Jack Team : Wildcats Wins : 4 $ Dictionaries A dictionary is a mapping type, that is, a data type that takes one kind of object and connects it to another. In other programming languages this is Dictionaries are nothing short of magic in programming for their efficiency and usefulness. A dictionary can be like a mini database or a convenient way to describe almost any object. As we saw above, dictionaries can be thought of as a list of unique keys that, when passed in the subscript operator, return a corresponding value. These key-value pairs allow a data structure that acts like a literal dictionary. This short lesson is only do introduce dictionaries but there are many things you can do with them. Hone Your Skills Look up the documentation on Mapping Types (dictionaries) and experiment with all the dictionary methods. Think about how you might go about making a dictionary that can turn English into Python code. Advanced Mastery Search the Internet and learn about hashmaps and how they work. From what you learn, why are dictionaries/hashmaps so efficient? How can you use this to make your code better? Previous: 18-Iterables | Table of Contents | Next: 20-Functions","title":"19. Dictionaries"},{"location":"19-Dictionaries/#20-dictionaries","text":"In the last lesson we learned about sequenced iterables. In this lesson we will learn about one of the most powerful iterables that does not exist in a sequence. This is called a dictionary. The following lesson will introduce and illustrate how to use a dictionary. # dictionary_practice.py # curly braces or just \"braces\" define a dictionary player_data = {\"Name\":\"Jack\", \"Team\":\"Wildcats\", \"Wins\":3} # we subscript with a keyword instead of an index, print(player_data[\"Name\"]) print(player_data[\"Team\"]) print(player_data[\"Wins\"],\"\\n\") # a dictionary is an iterable for key in player_data: print(key, \":\", player_data[key]) print(\"\") # another possibly better way to do the same thing for key, value in player_data.items(): print(key, \":\", value) print(\"\") # dictionaries are mutable and extendable player_data[\"Wins\"] += 1 player_data[\"Height\"] = \"6'2\\\"\" for key, value in player_data.items(): print(key, \":\", value) print(\"\") # you can also delete items too del player_data[\"Height\"] for key, value in player_data.items(): print(key, \":\", value) Here is what should happen $ python dictionary_practice.py Jack Wildcats 3 Name : Jack Team : Wildcats Wins : 3 Name : Jack Team : Wildcats Wins : 3 Name : Jack Team : Wildcats Wins : 4 Height : 6'2\" Name : Jack Team : Wildcats Wins : 4 $","title":"20 - Dictionaries"},{"location":"19-Dictionaries/#dictionaries","text":"A dictionary is a mapping type, that is, a data type that takes one kind of object and connects it to another. In other programming languages this is Dictionaries are nothing short of magic in programming for their efficiency and usefulness. A dictionary can be like a mini database or a convenient way to describe almost any object. As we saw above, dictionaries can be thought of as a list of unique keys that, when passed in the subscript operator, return a corresponding value. These key-value pairs allow a data structure that acts like a literal dictionary. This short lesson is only do introduce dictionaries but there are many things you can do with them.","title":"Dictionaries"},{"location":"19-Dictionaries/#hone-your-skills","text":"Look up the documentation on Mapping Types (dictionaries) and experiment with all the dictionary methods. Think about how you might go about making a dictionary that can turn English into Python code.","title":"Hone Your Skills"},{"location":"19-Dictionaries/#advanced-mastery","text":"Search the Internet and learn about hashmaps and how they work. From what you learn, why are dictionaries/hashmaps so efficient? How can you use this to make your code better? Previous: 18-Iterables | Table of Contents | Next: 20-Functions","title":"Advanced Mastery"},{"location":"20-Functions/","text":"Previous: 19-Dictionaries | Table of Contents | Next: 21-More Functions 20 - Functions We are nearing the end of the basics of Python programming. Most of the concepts we have covered so far are features in all programming languages. To recap, all complete programing languages have the following basic features or some equivalent thereof: The ability to format text and print it to the command line Assignment of variables and storage in volatile memory Receiving user input Reading and writing files in persistent memory Performing mathematical operations on numbers Conditionals (i.e. if, else statements) and logical evaluation Both for-loops and while-loops The ability to define and manipulate list-like structures (i.e. array or linked structures) Functions It is this last feature that we have not yet sufficiently explored. This next exercise will introduce what is perhaps the most powerful of the features we have explored so far. # function_intro.py # define a global variable number_of_sandwiches = 0 # 'def' defines a function def count_sandwiches(): print(f\"\\nThere are {number_of_sandwiches} sandchwiches.\") def make_a_sandwich(): global number_of_sandwiches number_of_sandwiches += 1 print(\"\\nA sandwich has been made.\") print(f\"There are now {number_of_sandwiches} sandwiches.\") def eat_a_sandwich(): global number_of_sandwiches number_of_sandwiches -= 1 print(\"\\nYou ate a sandwich.\") print(f\"There are now {number_of_sandwiches} sandwiches.\") def main(): \"\"\" This is the main function of the program. It will be the main entry point for all the functions. \"\"\" prompt = \"\"\" Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> \"\"\" running = True while running: choice = input(prompt) if \"count\" in choice: count_sandwiches() elif \"make\" in choice: make_a_sandwich() elif \"eat\" in choice: if number_of_sandwiches > 0: eat_a_sandwich() else: print(\"There are no sandwiches to eat!\") elif \"quit\" in choice: running = False else: print(\"That isn't an option.\") main() Here is what should happen $ python3 function_intro.py Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> make A sandwich has been made. There are now 1 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> count There are 1 sandchwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> make A sandwich has been made. There are now 2 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> eat You ate a sandwich. There are now 1 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> eat You ate a sandwich. There are now 0 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> eat There are no sandwiches to eat! Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> quit $ Functions Upon finishing this lesson, you should have made your first functions! There will always be times when you code that you will wish to reuse a chunk of code multiple times. A function allows you to reuse that code as many times as you want with a single call to the function. We will explore the basic aspects in this and the next lessons. Functions follow the following syntax: def function_name(argument1, argument2 ...): <statements ...> <statements ...> <statements ...> # code continues unindented # call the function using function_name(argument1, argument2) # or if there are no arguments function_name() We will talk more about arguments in the next lesson so don't worry too much about them here. As seen from the syntax above, when called the function executes the code in the indented block (this is what is meant by <statements ...> ). The first example of this was in the count_sandwiches() function. As you saw while executing the script, it simply gets the value of number_of_sandwiches and prints the corresponding text. Scope In the second and third functions, make_a_sandwich() and eat_a_sandwich() , you see the statement global number_of_sandwiches . The word global is a keyword in Python that we have not talked about yet and relates to how Python manages variables and memory. Up to this, point we have used only global variables. That is, we have had variables that were visible to every part of the program. Consider the following code: egg = \"Brown\" def change_color(): egg = \"White\" change_color() print(f\"The egg is {egg}\") Based on this code, which will print? The egg is White The egg is Brown If you try this out yourself, you will find that The egg is Brown is printed even though we changed the color of egg with change_color() . This is because of the scope of the egg variable. From Python's point of view, the egg defined on line 1 and the egg defined on line 4 inside the change_color() function are two different variables. The egg defined in the function only works inside the function and ceases to exist once the function ends. If we want the egg on line 1 and the egg inside the function to be the same variable we need to tell Python to do that. We do this with the global key word as follows: egg = \"Brown\" def change_color(): global egg egg = \"White\" change_color() print(f\"The egg is {egg}\") The line global egg tells Python to treat the egg variable in the function as the same egg variable defined in the global scope. There are many possible scopes that could exist in a Python program but for now the function scope and the global scope are the most important. A good thing to bear in mind while writing functions is that every variable that is defined in the context of the function will disappear as soon as the function ends. This means that if you want a variable to hang around after the function ends that variable needs to be defined in a scope outside the function. In the case of function_intro.py , you may have noticed that we did not have to use global in the first function. Why? This is a nuance of how Python deals with scope. If you are not defining a variable in a function but only referencing it (as was the case with count_sandwiches() ), Python first searches the function for the referenced name and then then expands the scope of the variable until the variable name is found. For the other two functions we were using assignment operators. Any time an assignment operator is used, Python defines the scope of the variable this way. This means that if you comment out the lines in function_intro.py you will get an error because the function variables have not yet been defined in that scope. Try this out for yourself! Hone Your Skills Make a function that calculates the factorial of a number (use a for-loop in your function) using a global variable from the user as your input. Previous: 19-Dictionaries | Table of Contents | Next: 21-More Functions","title":"20. Functions"},{"location":"20-Functions/#20-functions","text":"We are nearing the end of the basics of Python programming. Most of the concepts we have covered so far are features in all programming languages. To recap, all complete programing languages have the following basic features or some equivalent thereof: The ability to format text and print it to the command line Assignment of variables and storage in volatile memory Receiving user input Reading and writing files in persistent memory Performing mathematical operations on numbers Conditionals (i.e. if, else statements) and logical evaluation Both for-loops and while-loops The ability to define and manipulate list-like structures (i.e. array or linked structures) Functions It is this last feature that we have not yet sufficiently explored. This next exercise will introduce what is perhaps the most powerful of the features we have explored so far. # function_intro.py # define a global variable number_of_sandwiches = 0 # 'def' defines a function def count_sandwiches(): print(f\"\\nThere are {number_of_sandwiches} sandchwiches.\") def make_a_sandwich(): global number_of_sandwiches number_of_sandwiches += 1 print(\"\\nA sandwich has been made.\") print(f\"There are now {number_of_sandwiches} sandwiches.\") def eat_a_sandwich(): global number_of_sandwiches number_of_sandwiches -= 1 print(\"\\nYou ate a sandwich.\") print(f\"There are now {number_of_sandwiches} sandwiches.\") def main(): \"\"\" This is the main function of the program. It will be the main entry point for all the functions. \"\"\" prompt = \"\"\" Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> \"\"\" running = True while running: choice = input(prompt) if \"count\" in choice: count_sandwiches() elif \"make\" in choice: make_a_sandwich() elif \"eat\" in choice: if number_of_sandwiches > 0: eat_a_sandwich() else: print(\"There are no sandwiches to eat!\") elif \"quit\" in choice: running = False else: print(\"That isn't an option.\") main() Here is what should happen $ python3 function_intro.py Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> make A sandwich has been made. There are now 1 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> count There are 1 sandchwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> make A sandwich has been made. There are now 2 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> eat You ate a sandwich. There are now 1 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> eat You ate a sandwich. There are now 0 sandwiches. Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> eat There are no sandwiches to eat! Would you like to \"make\" a sandwich, \"eat\" a sandchwich, \"count\" your sandchwiches or \"quit\"? --> quit $","title":"20 - Functions"},{"location":"20-Functions/#functions","text":"Upon finishing this lesson, you should have made your first functions! There will always be times when you code that you will wish to reuse a chunk of code multiple times. A function allows you to reuse that code as many times as you want with a single call to the function. We will explore the basic aspects in this and the next lessons. Functions follow the following syntax: def function_name(argument1, argument2 ...): <statements ...> <statements ...> <statements ...> # code continues unindented # call the function using function_name(argument1, argument2) # or if there are no arguments function_name() We will talk more about arguments in the next lesson so don't worry too much about them here. As seen from the syntax above, when called the function executes the code in the indented block (this is what is meant by <statements ...> ). The first example of this was in the count_sandwiches() function. As you saw while executing the script, it simply gets the value of number_of_sandwiches and prints the corresponding text.","title":"Functions"},{"location":"20-Functions/#scope","text":"In the second and third functions, make_a_sandwich() and eat_a_sandwich() , you see the statement global number_of_sandwiches . The word global is a keyword in Python that we have not talked about yet and relates to how Python manages variables and memory. Up to this, point we have used only global variables. That is, we have had variables that were visible to every part of the program. Consider the following code: egg = \"Brown\" def change_color(): egg = \"White\" change_color() print(f\"The egg is {egg}\") Based on this code, which will print? The egg is White The egg is Brown If you try this out yourself, you will find that The egg is Brown is printed even though we changed the color of egg with change_color() . This is because of the scope of the egg variable. From Python's point of view, the egg defined on line 1 and the egg defined on line 4 inside the change_color() function are two different variables. The egg defined in the function only works inside the function and ceases to exist once the function ends. If we want the egg on line 1 and the egg inside the function to be the same variable we need to tell Python to do that. We do this with the global key word as follows: egg = \"Brown\" def change_color(): global egg egg = \"White\" change_color() print(f\"The egg is {egg}\") The line global egg tells Python to treat the egg variable in the function as the same egg variable defined in the global scope. There are many possible scopes that could exist in a Python program but for now the function scope and the global scope are the most important. A good thing to bear in mind while writing functions is that every variable that is defined in the context of the function will disappear as soon as the function ends. This means that if you want a variable to hang around after the function ends that variable needs to be defined in a scope outside the function. In the case of function_intro.py , you may have noticed that we did not have to use global in the first function. Why? This is a nuance of how Python deals with scope. If you are not defining a variable in a function but only referencing it (as was the case with count_sandwiches() ), Python first searches the function for the referenced name and then then expands the scope of the variable until the variable name is found. For the other two functions we were using assignment operators. Any time an assignment operator is used, Python defines the scope of the variable this way. This means that if you comment out the lines in function_intro.py you will get an error because the function variables have not yet been defined in that scope. Try this out for yourself!","title":"Scope"},{"location":"20-Functions/#hone-your-skills","text":"Make a function that calculates the factorial of a number (use a for-loop in your function) using a global variable from the user as your input. Previous: 19-Dictionaries | Table of Contents | Next: 21-More Functions","title":"Hone Your Skills"},{"location":"21-More-Functions/","text":"Previous: 20-Functions | Table of Contents | Next: 22-Try Except 21 - More Functions There are three more concepts tied to functions that we must understand before moving on. They are each demonstrated in the following exercise: # more_functions.py # params and returns def quadratic_formula(a, b, c): \"\"\" Calculates the roots of f(x) given a, b, c where f(x) = a * x**2 + b * x + c Returns the solution as a tuple. Returns None if the solutions are imaginary \"\"\" discriminant = b**2 - 4*a*c if discriminant < 0: return None root1 = (-b - discriminant**0.5) / 2 / a root2 = (-b + discriminant**0.5) / 2 / a return root1, root2 imaginary_solution = quadratic_formula(1, 2, 3) real_solution = quadratic_formula(1, -2, -3) print(\"Imaginary Solution is:\", imaginary_solution) print(\"Real Solution is:\", real_solution) # default params def print_a_number(number=1): print(f\"Your number is: {number}\") print_a_number(3) print_a_number() # recursion def factorial(number): \"\"\" Returns the factorial of a number It first turns it into an integer before calculating its factorial \"\"\" number = abs(int(number)) if number <= 0: return 1 return number * factorial(number - 1) print(\"4! =\", factorial(4)) print(\"2.5! =\", factorial(2.5)) Here is what should happen $ more_functions.py Imaginary Solution is: None Real Solution is: (-1.0, 3.0) Your number is: 3 Your number is: 1 4! = 24 2.5! = 2 $ Parameters and Arguments Parameters are related to arguments. Many times these two terms are used interchangeably. To clarify, a parameter is the variable name that is used in the definition of a function. Whereas, an argument is what actually gets passed into the function call as seen here: def function_name(parameter): parameter += 3 print(parameter) # now we call the function function_name(argument) Following this logic, the argument replaces the parameter while the function code executes. You have worked with arguments since the first Python program you ran. The simple statement print(\"Hello World!\") is just you calling the Python function named print and passing in the string \"Hello World!\" as an argument. Somewhere in the Python core code, there is a print function defined in a similar manner that executes all the details of printing text out to the command line. Default Values for Parameters We saw in line 29 the following line of code: def print_a_number(number=1): . This function definition supplied a default value for the number parameter. Any function parameter may have a default value. The effect of this definition is that if no argument is passed that corresponds to that parameter the value for the parameter will be assumed and inserted into the function. However, if the corresponding argument is given then it will override the default value. Returns and the None type You may have found that functions in Python have some practical similarities with mathematical functions. Just as a mathematical function f(x) will evaluate to a number when a value of x is supplied, a Python function that returns a value will evaluate to whatever value is returned. There are a few things to understand about the return statement: Any time a return statement is reached in Python, the expression after the word return is evaluated and the function call takes on the value of that evaluation. Therefore, if you have a return statement such as return 2*3 + 4 the function will evaluate to 10 . This is shown below: ```python def get_10(): return 2*3 + 4 x = get_10() # x now has a value of 10 ``` A function always ends after a return statement regardless of where the statement occurs in the code. Therefore, return is often used to end a function code early if necessary. We saw this on line 13 - 14 in more_functions.py where it says: python if discriminant < 0: return None This will end the function if it is found that the solution will be imaginary. Functions that have no return statement return a special data type called None by default. The None data type is basically Python's way of saying this data is nothing or void. Therefore when we explicit returned None we could have also just written return . Both cases would be saying, if the solution will be imaginary return nothing! It is possible to return multiple values (as seen in more_functions.py in the quadratic_formula function). As you saw above, they will simply be returned as a tuple. Return statements are crucial for effective functions and it is a good idea to experiment with what you can return in a function. Recursion Recursion is the idea that a function or some process can reference itself. A great explanation of recursion as a concept can be found on Wikipedia . We saw this with the factorial example. In mathematics, a factorial is a number being multiplied by all the positive integers below it and is symbolized by an exclamtion mark. So the factorial of 4 = 4! = 4 * 3 * 2 * 1. In this case we could do a loop to accomplish this but to demonstrate this principle we can do it with recursion. We set up a base case to end the recursion: if number <= 0: return 1 Then we have the function call itself with a small adjustment: return number * factorial(number - 1) And the function starts over again. This continues until the base case has been reached. Hone your Skills Try to write a recursive function that acts like a for-loop or a while-loop. Can you do it? What are the pros and cons of doing this? Write a function that returns multiple value and then try to unpack those into variables (see \"Hone Your Skills\" in the section on Iterables for more on how to do this.) Previous: 20-Functions | Table of Contents | Next: 22-Try Except","title":"21. More Functions"},{"location":"21-More-Functions/#21-more-functions","text":"There are three more concepts tied to functions that we must understand before moving on. They are each demonstrated in the following exercise: # more_functions.py # params and returns def quadratic_formula(a, b, c): \"\"\" Calculates the roots of f(x) given a, b, c where f(x) = a * x**2 + b * x + c Returns the solution as a tuple. Returns None if the solutions are imaginary \"\"\" discriminant = b**2 - 4*a*c if discriminant < 0: return None root1 = (-b - discriminant**0.5) / 2 / a root2 = (-b + discriminant**0.5) / 2 / a return root1, root2 imaginary_solution = quadratic_formula(1, 2, 3) real_solution = quadratic_formula(1, -2, -3) print(\"Imaginary Solution is:\", imaginary_solution) print(\"Real Solution is:\", real_solution) # default params def print_a_number(number=1): print(f\"Your number is: {number}\") print_a_number(3) print_a_number() # recursion def factorial(number): \"\"\" Returns the factorial of a number It first turns it into an integer before calculating its factorial \"\"\" number = abs(int(number)) if number <= 0: return 1 return number * factorial(number - 1) print(\"4! =\", factorial(4)) print(\"2.5! =\", factorial(2.5)) Here is what should happen $ more_functions.py Imaginary Solution is: None Real Solution is: (-1.0, 3.0) Your number is: 3 Your number is: 1 4! = 24 2.5! = 2 $","title":"21 - More Functions"},{"location":"21-More-Functions/#parameters-and-arguments","text":"Parameters are related to arguments. Many times these two terms are used interchangeably. To clarify, a parameter is the variable name that is used in the definition of a function. Whereas, an argument is what actually gets passed into the function call as seen here: def function_name(parameter): parameter += 3 print(parameter) # now we call the function function_name(argument) Following this logic, the argument replaces the parameter while the function code executes. You have worked with arguments since the first Python program you ran. The simple statement print(\"Hello World!\") is just you calling the Python function named print and passing in the string \"Hello World!\" as an argument. Somewhere in the Python core code, there is a print function defined in a similar manner that executes all the details of printing text out to the command line.","title":"Parameters and Arguments"},{"location":"21-More-Functions/#default-values-for-parameters","text":"We saw in line 29 the following line of code: def print_a_number(number=1): . This function definition supplied a default value for the number parameter. Any function parameter may have a default value. The effect of this definition is that if no argument is passed that corresponds to that parameter the value for the parameter will be assumed and inserted into the function. However, if the corresponding argument is given then it will override the default value.","title":"Default Values for Parameters"},{"location":"21-More-Functions/#returns-and-the-none-type","text":"You may have found that functions in Python have some practical similarities with mathematical functions. Just as a mathematical function f(x) will evaluate to a number when a value of x is supplied, a Python function that returns a value will evaluate to whatever value is returned. There are a few things to understand about the return statement: Any time a return statement is reached in Python, the expression after the word return is evaluated and the function call takes on the value of that evaluation. Therefore, if you have a return statement such as return 2*3 + 4 the function will evaluate to 10 . This is shown below: ```python def get_10(): return 2*3 + 4 x = get_10() # x now has a value of 10 ``` A function always ends after a return statement regardless of where the statement occurs in the code. Therefore, return is often used to end a function code early if necessary. We saw this on line 13 - 14 in more_functions.py where it says: python if discriminant < 0: return None This will end the function if it is found that the solution will be imaginary. Functions that have no return statement return a special data type called None by default. The None data type is basically Python's way of saying this data is nothing or void. Therefore when we explicit returned None we could have also just written return . Both cases would be saying, if the solution will be imaginary return nothing! It is possible to return multiple values (as seen in more_functions.py in the quadratic_formula function). As you saw above, they will simply be returned as a tuple. Return statements are crucial for effective functions and it is a good idea to experiment with what you can return in a function.","title":"Returns and the None type"},{"location":"21-More-Functions/#recursion","text":"Recursion is the idea that a function or some process can reference itself. A great explanation of recursion as a concept can be found on Wikipedia . We saw this with the factorial example. In mathematics, a factorial is a number being multiplied by all the positive integers below it and is symbolized by an exclamtion mark. So the factorial of 4 = 4! = 4 * 3 * 2 * 1. In this case we could do a loop to accomplish this but to demonstrate this principle we can do it with recursion. We set up a base case to end the recursion: if number <= 0: return 1 Then we have the function call itself with a small adjustment: return number * factorial(number - 1) And the function starts over again. This continues until the base case has been reached.","title":"Recursion"},{"location":"21-More-Functions/#hone-your-skills","text":"Try to write a recursive function that acts like a for-loop or a while-loop. Can you do it? What are the pros and cons of doing this? Write a function that returns multiple value and then try to unpack those into variables (see \"Hone Your Skills\" in the section on Iterables for more on how to do this.) Previous: 20-Functions | Table of Contents | Next: 22-Try Except","title":"Hone your Skills"},{"location":"22-Try-Except/","text":"Previous: 21-More Functions | Table of Contents | Next: 23-Imports 22 - Try Except Surely you have noticed by now that errors can be common as you program. Well they are more than common. They are practically inevitable. In this lesson we will explore how you can \"try\" some code without letting it break your program. # try_except.py month_names = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"] running = True while running: date_string = input(\"Enter a date of the format: MM/DD/YYYY\\n--> \") try: month, day, year = date_string.split(\"/\") month, day, year = int(month), int(day), int(year) if day < 1 or day > 31: raise Exception(\"Invalid day value.\") era = \"B.C.\" if year < 0 else \"A.D.\" year = abs(year) print(f\"The date you entered was {month_names[month - 1]}\"\\ \" {day} in the year {year} {era}\") running = False except Exception as e: print(\"Invalid Date detected!\") print(e) Here is what should happen $ python try_except.py Enter a date of the format: MM/DD/YYYY --> 100/10/1230 Invalid Date detected! list index out of range Enter a date of the format: MM/DD/YYYY --> 12/200/-30 Invalid Date detected! Invalid day value. Enter a date of the format: MM/DD/YYYY --> 12/10/-100 The date you entered was December 10 in the year 100 B.C. $ The try-except Statement Most of the time time in programming, you, the programmer, cannot guarantee that an error will not occur or an exception will not be thrown. You could try to prevent every problem with a series of if statements but that becomes cumbersome and is difficult to cover every eventuality. Python deals with this problem with try-except statements. A try statement will attempt to execute code in its corresponding block of indented code until an exception is \"raised\" or \"thrown\". If such is the case, then the try block stops and the except block is executed. If no exceptions are \"raised\" the the except block is skipped. In try_except.py , we used the statement to deal with bad user input and invalid dates. The syntax is as follows: try: # Block of code you expect may # raise an exception except: # this block runs if an exception is raised You will notice that we added a part to the except line that reads except Exception as e: . This allows us to capture data about the Exception that was thrown but the Exception covers all exceptions that can be thrown in Python. If you wish to catch a particular exception or multiple types of exceptions you may do so with multiple except blocks as follows: try: # Block of code you expect may # raise an exception except ZeroDivisionError: # this block runs if the # try block tries to divide by 0 except TypeError: # this block runs if # a type error is raised except Exception as e: # this block runs for all other exceptions Any exception in Python can be handled this way. When writing these statements one should always order them from specific errors to more general errors. This is because Python will execute the first valid except block it comes to. Therefore if you begin your list of except blocks with except Exception: no other except block will ever run. These statements allow for writing more secure code that can handle any amount of garbage that is fed to it. Use these judiciously as overuse can clutter your code and silence bugs and issues in your programs. Raising Exceptions We saw in try_except.py that we can force an exception to be raised with the raise statement. This is a powerful tool as it allows us to throw exceptions with customized messages. These can be very useful in debugging especially if we are careful about where we raise errors and what message we send. In our case we just wanted to send a general error to the user so a general Exception worked just fine here. Line Continuation You may have noticed the snippet of code from try_except.py : print(f\"The date you entered was {month_names[month - 1]}\"\\ f\" {day} in the year {year} {era}\") The backslash \\ at the end of the line is called a \"line continuation character\" and allows us to split long lines of code into multiple lines that are interpreted as one line of code. These are useful when you are trying to limit the length of your lines for ease of reading. Hone Your Skills Change the code to catch specific exceptions such as a TypeError and others. Try to do multiple except statements. How does this improve your code's usability? Change the code to raise some errors when a date is invalid. Does your message help the user understand what went wrong? Experiment with the security of this script. Try to break it or make it produce invalid dates. You may notice some dates that can be written are invalid. Rewrite this script so that it cannot produce an invalid date according to the Gregorian Calendar . (Go as detailed as you like, but at least account for basic leap years and months having different lengths.) Advanced Mastery What is a User-Defined Exception and why would you want to use one? What is the finally statement for and why would you need it? Previous: 21-More Functions | Table of Contents | Next: 23-Imports","title":"22. Try Except"},{"location":"22-Try-Except/#22-try-except","text":"Surely you have noticed by now that errors can be common as you program. Well they are more than common. They are practically inevitable. In this lesson we will explore how you can \"try\" some code without letting it break your program. # try_except.py month_names = [ \"January\", \"February\", \"March\", \"April\", \"May\", \"June\", \"July\", \"August\", \"September\", \"October\", \"November\", \"December\"] running = True while running: date_string = input(\"Enter a date of the format: MM/DD/YYYY\\n--> \") try: month, day, year = date_string.split(\"/\") month, day, year = int(month), int(day), int(year) if day < 1 or day > 31: raise Exception(\"Invalid day value.\") era = \"B.C.\" if year < 0 else \"A.D.\" year = abs(year) print(f\"The date you entered was {month_names[month - 1]}\"\\ \" {day} in the year {year} {era}\") running = False except Exception as e: print(\"Invalid Date detected!\") print(e) Here is what should happen $ python try_except.py Enter a date of the format: MM/DD/YYYY --> 100/10/1230 Invalid Date detected! list index out of range Enter a date of the format: MM/DD/YYYY --> 12/200/-30 Invalid Date detected! Invalid day value. Enter a date of the format: MM/DD/YYYY --> 12/10/-100 The date you entered was December 10 in the year 100 B.C. $","title":"22 - Try Except"},{"location":"22-Try-Except/#the-try-except-statement","text":"Most of the time time in programming, you, the programmer, cannot guarantee that an error will not occur or an exception will not be thrown. You could try to prevent every problem with a series of if statements but that becomes cumbersome and is difficult to cover every eventuality. Python deals with this problem with try-except statements. A try statement will attempt to execute code in its corresponding block of indented code until an exception is \"raised\" or \"thrown\". If such is the case, then the try block stops and the except block is executed. If no exceptions are \"raised\" the the except block is skipped. In try_except.py , we used the statement to deal with bad user input and invalid dates. The syntax is as follows: try: # Block of code you expect may # raise an exception except: # this block runs if an exception is raised You will notice that we added a part to the except line that reads except Exception as e: . This allows us to capture data about the Exception that was thrown but the Exception covers all exceptions that can be thrown in Python. If you wish to catch a particular exception or multiple types of exceptions you may do so with multiple except blocks as follows: try: # Block of code you expect may # raise an exception except ZeroDivisionError: # this block runs if the # try block tries to divide by 0 except TypeError: # this block runs if # a type error is raised except Exception as e: # this block runs for all other exceptions Any exception in Python can be handled this way. When writing these statements one should always order them from specific errors to more general errors. This is because Python will execute the first valid except block it comes to. Therefore if you begin your list of except blocks with except Exception: no other except block will ever run. These statements allow for writing more secure code that can handle any amount of garbage that is fed to it. Use these judiciously as overuse can clutter your code and silence bugs and issues in your programs.","title":"The try-except Statement"},{"location":"22-Try-Except/#raising-exceptions","text":"We saw in try_except.py that we can force an exception to be raised with the raise statement. This is a powerful tool as it allows us to throw exceptions with customized messages. These can be very useful in debugging especially if we are careful about where we raise errors and what message we send. In our case we just wanted to send a general error to the user so a general Exception worked just fine here.","title":"Raising Exceptions"},{"location":"22-Try-Except/#line-continuation","text":"You may have noticed the snippet of code from try_except.py : print(f\"The date you entered was {month_names[month - 1]}\"\\ f\" {day} in the year {year} {era}\") The backslash \\ at the end of the line is called a \"line continuation character\" and allows us to split long lines of code into multiple lines that are interpreted as one line of code. These are useful when you are trying to limit the length of your lines for ease of reading.","title":"Line Continuation"},{"location":"22-Try-Except/#hone-your-skills","text":"Change the code to catch specific exceptions such as a TypeError and others. Try to do multiple except statements. How does this improve your code's usability? Change the code to raise some errors when a date is invalid. Does your message help the user understand what went wrong? Experiment with the security of this script. Try to break it or make it produce invalid dates. You may notice some dates that can be written are invalid. Rewrite this script so that it cannot produce an invalid date according to the Gregorian Calendar . (Go as detailed as you like, but at least account for basic leap years and months having different lengths.)","title":"Hone Your Skills"},{"location":"22-Try-Except/#advanced-mastery","text":"What is a User-Defined Exception and why would you want to use one? What is the finally statement for and why would you need it? Previous: 21-More Functions | Table of Contents | Next: 23-Imports","title":"Advanced Mastery"},{"location":"23-Imports/","text":"Previous: 22-Try Except | Table of Contents | Next: 24-Reading Code 23 - Imports This is the last concept we will cover that I would consider the \"basics\" of Python and programming in general. Up to now, we have been using only the built-in functionality of Python. This is, in fact, a very limited view of what Python can do. To get the full power and utility of Python, we can use libraries of code that other programmers have written to do all sorts of complex and powerful tasks. In this lesson we will introduce many different tools that you may want to use. While going through the exercises in this lesson do not worry about learning everything there is to know about each set of tools. The point of this lesson is to get you familiar with how to get what you need for programming. With that said let's start! # import_practice.py import os from math import sin, log, pi from random import random import csv import datetime as dt # os example print(\"Python doing: ls\") for root, dirs, files in os.walk(\".\"): print(\"-\" * 20) print(\"Folder Name:\", root, \"\\n----\") print(\"Sub-folders:\") for directory in dirs: print(\"\\t\", directory) print(\"---\\nFiles:\") for file in files: print(\"\\t\", file) print(\"\") print(\"-\" * 20) # math example print(\"sin(\\u03C0/2) =\", sin(pi/2)) print(\"ln(23) =\", round(log(24), 2)) # random example def gen_random_matrix(size): \"\"\" Returns a 2D matrix (a.k.a. a list of lists) of shape \"size X size\" with elements generated having random values between 0 and 1 \"\"\" matrix = [] for row_index in range(size): row = [] for element in range(size): row.append(random()) matrix.append(row) return matrix # csv example with open(\"data.csv\", 'w', newline=\"\") as f: writer = csv.writer(f) writer.writerows(gen_random_matrix(3)) # datetime example print(\"\\nThe exact date and time is:\", dt.datetime.now()) Here is what should happen $ python import_practice.py Python doing: ls -------------------- Folder Name: . ---- Sub-folders: .ipynb_checkpoints --- Files: data.csv import_practice.py import_text.py solution_test_1.py test_write.ipynb TOC_tba.md wacky_story.py -------------------- Folder Name: .\\.ipynb_checkpoints ---- Sub-folders: --- Files: test_write-checkpoint.ipynb -------------------- sin(\u03c0/2) = 1.0 ln(23) = 3.18 The exact date and time is: 2019-01-05 12:38:55.442190 PS C:\\Users\\Jilly\\Documents\\Mark\\python_book\\code_files> python .\\ import_practice.py Python doing: ls -------------------- Folder Name: . ---- Sub-folders: .ipynb_checkpoints --- Files: data.csv import_practice.py solution_test_1.py test_write.ipynb TOC_tba.md wacky_story.py -------------------- Folder Name: .\\.ipynb_checkpoints ---- Sub-folders: --- Files: test_write-checkpoint.ipynb -------------------- sin(\u03c0/2) = 1.0 ln(23) = 3.18 The exact date and time is: 2019-01-05 12:49:54.332969 $ Imports The main concept we introduced in this exercise is that of an import statement. These statements are how we use code from another script written in Python. The syntax of an import statement follows two basic forms: import NAME This statement pulls an object called NAME into your script that contains the entirety of the script called NAME.py . This kind of object is called a module. (Python has rules to keep track of where to look for any module you import.) You can then use any of the contents of NAME.py such as functions or objects defined in that module. You use them by the dot notation as we saw in the case of os (i.e. NAME.function_name() or as above with os.walk() ). from MODULE import NAMES Sometimes pulling in an entire script is inefficient especially when you want only one or two things from the script. You can pick and choose what you want to use with the from-import style statements. As we saw from the math and random examples, you can then call these functions directly without dot notation. However be aware that if you make a variable or write a function with the same name as these, it will override their definition. For the line that reads import datetime as dt , the as part of the statement is just changing the name of the function and is practically the same as writing dt = datetime . This is common practice in Python especially for libraries with longer names. Standard Libraries The five libraries we used in import_practice.py are part of the Python Standard Library and can be considered \"built-in\" to Python. There are well over 200 different modules in Standard Library and to go over each one would be and not very useful. Therefore, this exercise is designed to introduce a few common libraries and get you used to the syntax of importing and using them. But to be thorough, here some brief explanations of each of the libraries we used in this exercise: os os stands for \"Operating System\". This module allows you to interact with the operating system and the command line to some extent. It contains some file managing tools (e.g. rename or move files, explore the file system etc.) and also some system-specific functionality. There are other modules like sys and subprocess that provide more specific functionality depending on what you need. math This module allows you to access the basic math functions provided by the C standard library. These include but are not limited to trigonometric and hyperbolic functions (e.g. sin, cos, sinh, cosh etc.), exponential and logarithmic functions (e.g. exp, log etc.) and common logical functions you may need. random This provides a large selection of random number generators and functionality related thereto. csv A popular plain-text format for data is the \"Comma-Separated Values\" format. This is a handy library for working with these files without having to constantly reinvent the wheel. Specifically, it can turn iterables into csv files with minimal coding. datetime A library for working with date and time. The library bases its times on computer times and is a useful feature for getting calendar-like functionality out of your programs. It includes sub modules for both date and time if you happen to be interested in only one of the two. These are just a surface look at each of these libraries but don't worry too much about learning every library. I have never had occasion to use many of the standard libraries but they are a great starting place for accomplishing complex tasks more easily. Getting More Libraries and Packages Any package in the Python Standard Library is written and endorsed by the creators and maintainers of Python. However, there is an enormous number of libraries that are written and maintained by thousands of programmers everywhere. These are sometimes called third-party libraries or packages and are available for quick download and installation through a handy software called pip which is built-in to your standard Python 3 installation. Let's practice with it here by installing a package called nose . Open your command line and enter pip install nose : $ pip install nose <a bunch of text> Successfully installed nose-1.3.7 $ nose is a package that allows you to write tests for larger programs. If you see something like Successfully installed nose-1.3.7 then the package installed correctly. Skim the basic commands of pip here and use them to install libraries/packages when you need them. We will install more packages later once we get further along. Hone Your Skills The Python Standard Library is a good reference to get an idea of all the things that Python can do without even including third-party libraries and packages. Read the general statement at the beginning of the linked page and browse the index looking for 2 or 3 things that interest you. Begin to experiment with them and see if you can pick up how they work. Consider the following function definition from import_practice.py : def gen_random_matrix(size): \"\"\" Returns a 2D matrix (a.k.a. a list of lists) of shape \"size X size\" with elements generated having random values between 0 and 1 \"\"\" matrix = [] for row_index in range(size): row = [] for element in range(size): row.append(random()) matrix.append(row) return matrix It turns out Python has a neat trick called a List Comprehension to turn all that code into one line of code so that it can be written as follows: def gen_random_matrix(size): \"\"\" Returns a 2D matrix (a.k.a. a list of lists) of shape \"size X size\" with elements generated having random values between 0 and 1 \"\"\" return # insert line of code here After reading about list comprehensions write one line of code that will do the same thing as above and run it to test it. Previous: 22-Try Except | Table of Contents | Next: 24-Reading Code","title":"23. Imports"},{"location":"23-Imports/#23-imports","text":"This is the last concept we will cover that I would consider the \"basics\" of Python and programming in general. Up to now, we have been using only the built-in functionality of Python. This is, in fact, a very limited view of what Python can do. To get the full power and utility of Python, we can use libraries of code that other programmers have written to do all sorts of complex and powerful tasks. In this lesson we will introduce many different tools that you may want to use. While going through the exercises in this lesson do not worry about learning everything there is to know about each set of tools. The point of this lesson is to get you familiar with how to get what you need for programming. With that said let's start! # import_practice.py import os from math import sin, log, pi from random import random import csv import datetime as dt # os example print(\"Python doing: ls\") for root, dirs, files in os.walk(\".\"): print(\"-\" * 20) print(\"Folder Name:\", root, \"\\n----\") print(\"Sub-folders:\") for directory in dirs: print(\"\\t\", directory) print(\"---\\nFiles:\") for file in files: print(\"\\t\", file) print(\"\") print(\"-\" * 20) # math example print(\"sin(\\u03C0/2) =\", sin(pi/2)) print(\"ln(23) =\", round(log(24), 2)) # random example def gen_random_matrix(size): \"\"\" Returns a 2D matrix (a.k.a. a list of lists) of shape \"size X size\" with elements generated having random values between 0 and 1 \"\"\" matrix = [] for row_index in range(size): row = [] for element in range(size): row.append(random()) matrix.append(row) return matrix # csv example with open(\"data.csv\", 'w', newline=\"\") as f: writer = csv.writer(f) writer.writerows(gen_random_matrix(3)) # datetime example print(\"\\nThe exact date and time is:\", dt.datetime.now()) Here is what should happen $ python import_practice.py Python doing: ls -------------------- Folder Name: . ---- Sub-folders: .ipynb_checkpoints --- Files: data.csv import_practice.py import_text.py solution_test_1.py test_write.ipynb TOC_tba.md wacky_story.py -------------------- Folder Name: .\\.ipynb_checkpoints ---- Sub-folders: --- Files: test_write-checkpoint.ipynb -------------------- sin(\u03c0/2) = 1.0 ln(23) = 3.18 The exact date and time is: 2019-01-05 12:38:55.442190 PS C:\\Users\\Jilly\\Documents\\Mark\\python_book\\code_files> python .\\ import_practice.py Python doing: ls -------------------- Folder Name: . ---- Sub-folders: .ipynb_checkpoints --- Files: data.csv import_practice.py solution_test_1.py test_write.ipynb TOC_tba.md wacky_story.py -------------------- Folder Name: .\\.ipynb_checkpoints ---- Sub-folders: --- Files: test_write-checkpoint.ipynb -------------------- sin(\u03c0/2) = 1.0 ln(23) = 3.18 The exact date and time is: 2019-01-05 12:49:54.332969 $","title":"23 - Imports"},{"location":"23-Imports/#imports","text":"The main concept we introduced in this exercise is that of an import statement. These statements are how we use code from another script written in Python. The syntax of an import statement follows two basic forms: import NAME This statement pulls an object called NAME into your script that contains the entirety of the script called NAME.py . This kind of object is called a module. (Python has rules to keep track of where to look for any module you import.) You can then use any of the contents of NAME.py such as functions or objects defined in that module. You use them by the dot notation as we saw in the case of os (i.e. NAME.function_name() or as above with os.walk() ). from MODULE import NAMES Sometimes pulling in an entire script is inefficient especially when you want only one or two things from the script. You can pick and choose what you want to use with the from-import style statements. As we saw from the math and random examples, you can then call these functions directly without dot notation. However be aware that if you make a variable or write a function with the same name as these, it will override their definition. For the line that reads import datetime as dt , the as part of the statement is just changing the name of the function and is practically the same as writing dt = datetime . This is common practice in Python especially for libraries with longer names.","title":"Imports"},{"location":"23-Imports/#standard-libraries","text":"The five libraries we used in import_practice.py are part of the Python Standard Library and can be considered \"built-in\" to Python. There are well over 200 different modules in Standard Library and to go over each one would be and not very useful. Therefore, this exercise is designed to introduce a few common libraries and get you used to the syntax of importing and using them. But to be thorough, here some brief explanations of each of the libraries we used in this exercise: os os stands for \"Operating System\". This module allows you to interact with the operating system and the command line to some extent. It contains some file managing tools (e.g. rename or move files, explore the file system etc.) and also some system-specific functionality. There are other modules like sys and subprocess that provide more specific functionality depending on what you need. math This module allows you to access the basic math functions provided by the C standard library. These include but are not limited to trigonometric and hyperbolic functions (e.g. sin, cos, sinh, cosh etc.), exponential and logarithmic functions (e.g. exp, log etc.) and common logical functions you may need. random This provides a large selection of random number generators and functionality related thereto. csv A popular plain-text format for data is the \"Comma-Separated Values\" format. This is a handy library for working with these files without having to constantly reinvent the wheel. Specifically, it can turn iterables into csv files with minimal coding. datetime A library for working with date and time. The library bases its times on computer times and is a useful feature for getting calendar-like functionality out of your programs. It includes sub modules for both date and time if you happen to be interested in only one of the two. These are just a surface look at each of these libraries but don't worry too much about learning every library. I have never had occasion to use many of the standard libraries but they are a great starting place for accomplishing complex tasks more easily.","title":"Standard Libraries"},{"location":"23-Imports/#getting-more-libraries-and-packages","text":"Any package in the Python Standard Library is written and endorsed by the creators and maintainers of Python. However, there is an enormous number of libraries that are written and maintained by thousands of programmers everywhere. These are sometimes called third-party libraries or packages and are available for quick download and installation through a handy software called pip which is built-in to your standard Python 3 installation. Let's practice with it here by installing a package called nose . Open your command line and enter pip install nose : $ pip install nose <a bunch of text> Successfully installed nose-1.3.7 $ nose is a package that allows you to write tests for larger programs. If you see something like Successfully installed nose-1.3.7 then the package installed correctly. Skim the basic commands of pip here and use them to install libraries/packages when you need them. We will install more packages later once we get further along.","title":"Getting More Libraries and Packages"},{"location":"23-Imports/#hone-your-skills","text":"The Python Standard Library is a good reference to get an idea of all the things that Python can do without even including third-party libraries and packages. Read the general statement at the beginning of the linked page and browse the index looking for 2 or 3 things that interest you. Begin to experiment with them and see if you can pick up how they work. Consider the following function definition from import_practice.py : def gen_random_matrix(size): \"\"\" Returns a 2D matrix (a.k.a. a list of lists) of shape \"size X size\" with elements generated having random values between 0 and 1 \"\"\" matrix = [] for row_index in range(size): row = [] for element in range(size): row.append(random()) matrix.append(row) return matrix It turns out Python has a neat trick called a List Comprehension to turn all that code into one line of code so that it can be written as follows: def gen_random_matrix(size): \"\"\" Returns a 2D matrix (a.k.a. a list of lists) of shape \"size X size\" with elements generated having random values between 0 and 1 \"\"\" return # insert line of code here After reading about list comprehensions write one line of code that will do the same thing as above and run it to test it. Previous: 22-Try Except | Table of Contents | Next: 24-Reading Code","title":"Hone Your Skills"},{"location":"24-Reading-Code/","text":"Previous: 23-Imports | Table of Contents | Next: 25-Do a Project 24 - Reading Code If you have stuck with Python up to this point, congratulations! You have learned the basics of Python scripting. Everything you have learned up to now has been an exercise to get you familiar with the syntax of Python as well as a few basic principles of programming and computer science. I mentioned when we introduced functions that there are a few things that are common to all programming languages. There are only a few more concepts common to many programming languages that we have not yet covered in Python. However, you now know enough to understand the bulk of the language. Your Reading Assignment For this lesson, do the following steps: Go to a website that hosts open source code such as github.com . Search the website for Python code you can read. It really doesn't matter what exactly you read, just don't read anything that is marked as Python 2 (it will just confuse you). Read one or two scripts and see if you can figure out what the scripts are doing and how they are doing them. It is possible you will run into some things what we have not covered yet. Do not worry about understanding the code perfectly, just do your best to understand it. If you cannot follow some code at all, try another script until you can rough idea of what a script is doing. As you read, feel free to reference sections we have covered so far or search the Internet to help you understand. (Remember to type \"Python\" and then write what you are looking for into any search engine.) Pay attention to how the code is documented as you do this. Is the documentation helpful in understanding the code? As you work take notes on things you notice about the code. How can you apply what you see in other's code to your own code? Like all of these lessons, what you put in to this exercise is what you will get out of it. If you put forth the effort and really try to understand the code you will gain some valuable insight into how real code is written. Hone Your Skills Do this exercise for a Python third-party library such as the Python scientific library scipy . Could you write your own module? How? (Note: We will go into detail on this later.) Previous: 23-Imports | Table of Contents | Next: 25-Do a Project","title":"24. Reading Code"},{"location":"24-Reading-Code/#24-reading-code","text":"If you have stuck with Python up to this point, congratulations! You have learned the basics of Python scripting. Everything you have learned up to now has been an exercise to get you familiar with the syntax of Python as well as a few basic principles of programming and computer science. I mentioned when we introduced functions that there are a few things that are common to all programming languages. There are only a few more concepts common to many programming languages that we have not yet covered in Python. However, you now know enough to understand the bulk of the language.","title":"24 - Reading Code"},{"location":"24-Reading-Code/#your-reading-assignment","text":"For this lesson, do the following steps: Go to a website that hosts open source code such as github.com . Search the website for Python code you can read. It really doesn't matter what exactly you read, just don't read anything that is marked as Python 2 (it will just confuse you). Read one or two scripts and see if you can figure out what the scripts are doing and how they are doing them. It is possible you will run into some things what we have not covered yet. Do not worry about understanding the code perfectly, just do your best to understand it. If you cannot follow some code at all, try another script until you can rough idea of what a script is doing. As you read, feel free to reference sections we have covered so far or search the Internet to help you understand. (Remember to type \"Python\" and then write what you are looking for into any search engine.) Pay attention to how the code is documented as you do this. Is the documentation helpful in understanding the code? As you work take notes on things you notice about the code. How can you apply what you see in other's code to your own code? Like all of these lessons, what you put in to this exercise is what you will get out of it. If you put forth the effort and really try to understand the code you will gain some valuable insight into how real code is written.","title":"Your Reading Assignment"},{"location":"24-Reading-Code/#hone-your-skills","text":"Do this exercise for a Python third-party library such as the Python scientific library scipy . Could you write your own module? How? (Note: We will go into detail on this later.) Previous: 23-Imports | Table of Contents | Next: 25-Do a Project","title":"Hone Your Skills"},{"location":"25-Do-a-Project/","text":"Previous: 24-Reading Code | Table of Contents | Next: 26-Objects and Classes 25 - Do a Project It is now time to put your new found skills to use! You have learned enough in Python to find out how to solve many of your own problems. Now your assignment is to integrate everything you have learned into a project. My only requirement is that the project must interact with a user and the user must have some measure of control over what happens in the program. There are two basic ways this can be done. The first is by using the input function as we have covered. Another way is to use sys.argv (i.e. the argv variable from the sys module). Before you get started, make sure you read the entirety of this lesson before deciding what to do. The next few sections are important concepts that will aid you as you synthesize your first fully featured program. This section also has an appendix with a quick introduction to some minor things we have not yet covered that you may find useful. Have fun with this. Think about why you started this in the first place. This may not be a perfect program but it will be a great learning and growing experience for you as a programmer. Remember that the internet is your friend and 99% of questions you have can be found there. Good luck! Styling Code Before you begin coding you should make sure you are styling your code correctly. Up to now you should have been following my code along and styling it as I have in each example. To make your code easy to debug and easy to read as possible you should continue to use good style practices in Python. Before doing any coding, read Python's style guide called PEP-8 . Commit to using these conventions to make your code readable and easier to debug. Once you have practiced this style enough you will be able to follow and debug your code much more easily. Debugging Inevitably you may run into situations where your code is doing unexpected things (think 'logic errors' from the lesson on errors exceptions and bugs). Fixing these errors is not a trivial process. In fact by some estimates, programmers generally spend 50 - 75 percent of their time just debugging their programs! The following are some simple strategies used by professionals to avoid debugging or effectively debug their software: Plan Ahead The best way to fix bugs is to do your best to ensure that they never happen. You can plan your code so you have an idea of where you want to be when you finish up. Before you write any code at all, pull out a pencil and paper or open up a drawing software like draw.io . Make an outline and write down in general what your code will do. Then get more specific by specifying how it will do it. Repeat this process until you have a general idea of what you need to code the project and the logic it will follow. This can be a flow chart or a list of function names and descriptions of what they do. This can be a difficult habit to follow but rest assured that doing good planning up front will save you a large amount of time debugging later on. Use Good Coding Practice One strategy that should probably go without saying is to use good coding practice while you work. The following are some suggestions used by professionals to make Ensure you are following the Python Style Guide . Good style makes code easy to read and therefore easier to debug. Use descriptive variable names that make clear the purpose of a variable Follow the principles found in the Zen of Python Document your code as you go. It is easy to forget what your code is doing. If you leave notes for yourself you are less likely to get lost. Do a little at a time There are two general approaches to implementing a large project. The first it s a \"Top-Down\" approach where you get the simplest version of the program working and add features, fleshing out the auxiliary parts of the program as you go. The other is the \"bottom-up\" approach where you get one little part of the program to work at a time. Once enough parts are working independently, you link them together. Both have advantages depending on the application but for this first attempt at a larger program I will recommend doing the bottom-up approach. As you go, decide what each part of the program must do and get each part working before you link them together. Test-Driven development As you build your code up you will inevitably run into errors. One of the best ways to avoid difficult-to-debug logic errors is to implement test-driven development. The process of test-driven development is simple to understand. Before writing any code you write code that tests the function or you will write. The test should be written to get certain outputs of inputs to the function. You will want to write tests that test the normal cases and the edge cases of your function. Once the tests have been written and you have ensured that they work (a relatively simple coding task), write your code so it passes those tests. If you have written good tests then the code will act as you expect it to. Getting intermediate values Everything we have listed above is about how to prevent errors. Eventually you will have to go in and figure out how you messed up. When this happens getting intermediate values will help you see what your code is doing. Use the print function to print out values as you go. Start by ensuring that you are getting the input you think you are. Then check your loops are doing what you think they are by going through just one iteration (i.e. use a break statement to end the loop early). Finally, check your returns so you know you are getting back what you think you should be getting back. This is not an exhaustive list of strategies. But the simple act of checking intermediate values will help you a lot as you go along. Explain it to a rubber duck This is one of the weirdest and most effective strategies used by programmers. More detail about it can be found here . The idea is to explain your code out loud to a rubber duck (although you could explain it to another person too if they were willing to listen for that long). As you explain the code out loud you will find that often the solution to your problem will occur to you. This is a strange practice but has been shown to be a powerful debugging too to help you gain clarity about what is going wrong. \"If you cannot solve your problem, solve an easier problem first.\" - Dr. David Lignell Taken from here . This is a good tip for you if you find yourself at a dead end. Split up your problem into parts and tackle each one at a time. For example, split your code into shorter sub-functions and debug each of them. Possible Projects There are many different things you may want to do with your newfound skills. In reality, this project will be the most valuable thing you do yet as it will introduce problems you have not yet faced and develop skills you have not yet even thought of. Ideally, you will make something that interests you and feeds your passions. Below I have provided some general ideas and perhaps a push in the right direction. However, you must flesh out the ideas here and make them your own. Please note that right now, everything you will do will interface with your user in the command line. This however does not mean that you cannot make something interesting or useful. With that said, here are some possible projects. Design A Game Video games back in earlier days of computing were all based in the command line. A popular one that was among the first video games was called \"Zork\". Search the Internet for information about Zork and make your own little version. A tiny version of a Zork-like might look like: def entrance_hall(): look = \"\"\" You find yourself locked inside a castle. You are in the entrance hall to the palace. To the SOUTH there is a locked door to the outside. To the NORTH there is a staircase. To the EAST and WEST there are large wooden doors standing ajar. \"\"\" print(look) do = input(\"What will you do? > \") if do == \"go north\": staircase() elif do == \"go south\": print(\"You're pretty bad at this game.\") elif do == 'go east' or do == \"go west\": east_west_rooms() else: print(\"You lose. Next time try doing something\", \"like 'go <direction>' to do something.\") def staircase(): look = \"\"\" There is a lot of treasure here! You take the treasure, get rich and live happily ever after! YOU WIN! \"\"\" print(look) def east_west_rooms(): look = \"\"\" There is a monster in this room. He eats you and you regret ever being born as you fall down his throat. GAME OVER \"\"\" print(look) entrance_hall() # this starts the game It is up to you to develop this idea. The following are some suggestions the intent of this exercise it that you make the best game you can with your current skill set. Try some of the following as you develop your game: Draw a map and allow your character to move through many rooms. (At least 10 rooms/encounters.) Make obstacles, enemies or puzzles for your character to overcome. Allow the user to do many things in each room and write code to allow the user to put in bad input without breaking the game. Figure out how to parse and interpret input so that GO WEST and Go WEst are both interpreted as go west. Use a main-loop structure to simplify how the game works. There are no real limits or minimum requirements for this. Like I said above what you get out of this is what you put into it. Make a Database Manager Make a manager for a database. The database can consist of a text file or a .json file or a .csv file to store your data. (Note: There are both json and csv libraries built into Python for working with these types of files.) For example suppose you are writing software to manage an inventory and assets for a used car dealership. Make a dictionary of all the pertinent data for each car (i.e. make, model, year, mileage, price) for each car and keep a database of these. Make a fully featured program that lets the user keep track of all the pertinent data and allows you to add, delete and edit car data in the database. Ensure these are saved to a file of some type. Code a Calculator Write a program that allows the user to quickly enter mathematical statements and evaluates them. This would be similar to how a graphing calculator works. This should go without saying but, this should be more extensive than running python in the command line and using the built-in functionality. The user may not know what an import statement is or that you need to use x**y to get x to the power of y . Make the program as smart as possible and able to do as many things as possible. If you wish to use add graphing functionality, I suggest looking up the third-party matplotlib library. APPENDIX: A quick introduction to some useful concepts sys.argv Included here are some useful concepts and ideas for your project. Write out the following file and run it: # add_numbers.py from sys import argv print(f\"The name of this file is: {argv[0]}\") # get the filename numbers = [float(i) for i in argv[1:]] # turn string arguments into numbers print(f\"The sum of the numbers given is {sum(numbers)}\") # sum numbers together Here is what should happen $ python add_numbers.py 1 0.2 3 5 4 3 The name of this file is: add_numbers.py The sum of the numbers given is 16.2 $ argv is short for argument variables and represents the space-separated arguments passed in with any call to Python. It takes the form of a list of strings with the first element being the name of the script that is being run. In our case the rest of the arguments are numbers to be summed together. If you want more detail on argv you can read about it here . This is a common way to have your user interact with a program by passing it arguments as you run it. Main-loops Write out the following and run it as well: # mainloop.py menu = ''' Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program ''' running = True while running: print(menu) command = input(\"--> \") if command == \"1\": print(\"a word\") elif command == \"2\": for i in range(10): print(i+1) print(\"I did a thing!\") elif command == \"3\": running = False else: print(\"I do not understand that command.\") Here is what should happen $ python mainloop.py Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 1 a word Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 2 1 2 3 4 5 6 7 8 9 10 I did a thing! Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 4 I do not understand that command. Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 3 $ As you can see, this program has a main-loop which runs the program until the user elects to end the program. In fact, it is a staple of programming to have a main-loop-like structure. The basic idea of a main-loop is a program that acts as follows: Gets user input (e.g. a button press, keystroke etc.) Processes the user input and apply some internal logic to it Produces some output (e.g. a printed statement or a newly rendered image on screen) Returns to step one This basic structure should be a norm of programming for a user. Use this as your model for user input. Break and Continue statements You can skip a loop iteration or stop a loop entirely with the continue or break statements respectively. Write out the following code to practice it. # cont_break.py # this loop counts to 100 by 10's for i in range(1,101): if not i % 10 == 0: continue print(i, end=\" \") print(\"\") # this loop will prematurely end at 24 for j in range(100): print(j, end=\" \") if j > 23: break print(\"\") Here is what should happen $ python cont_break.py 10 20 30 40 50 60 70 80 90 100 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ Consider how the break and continue statements change the flow of the code. Use these statements to skip iterations of loops or get out of loops entirely. You may notice that these introductions have been brief. This is on purpose. My goal was to simply let you know that these features exist. It is up to you to research and utilize them. They are not required. Previous: 24-Reading Code | Table of Contents | Next: 26-Objects and Classes","title":"25. Do a Project"},{"location":"25-Do-a-Project/#25-do-a-project","text":"It is now time to put your new found skills to use! You have learned enough in Python to find out how to solve many of your own problems. Now your assignment is to integrate everything you have learned into a project. My only requirement is that the project must interact with a user and the user must have some measure of control over what happens in the program. There are two basic ways this can be done. The first is by using the input function as we have covered. Another way is to use sys.argv (i.e. the argv variable from the sys module). Before you get started, make sure you read the entirety of this lesson before deciding what to do. The next few sections are important concepts that will aid you as you synthesize your first fully featured program. This section also has an appendix with a quick introduction to some minor things we have not yet covered that you may find useful. Have fun with this. Think about why you started this in the first place. This may not be a perfect program but it will be a great learning and growing experience for you as a programmer. Remember that the internet is your friend and 99% of questions you have can be found there. Good luck!","title":"25 - Do a Project"},{"location":"25-Do-a-Project/#styling-code","text":"Before you begin coding you should make sure you are styling your code correctly. Up to now you should have been following my code along and styling it as I have in each example. To make your code easy to debug and easy to read as possible you should continue to use good style practices in Python. Before doing any coding, read Python's style guide called PEP-8 . Commit to using these conventions to make your code readable and easier to debug. Once you have practiced this style enough you will be able to follow and debug your code much more easily.","title":"Styling Code"},{"location":"25-Do-a-Project/#debugging","text":"Inevitably you may run into situations where your code is doing unexpected things (think 'logic errors' from the lesson on errors exceptions and bugs). Fixing these errors is not a trivial process. In fact by some estimates, programmers generally spend 50 - 75 percent of their time just debugging their programs! The following are some simple strategies used by professionals to avoid debugging or effectively debug their software: Plan Ahead The best way to fix bugs is to do your best to ensure that they never happen. You can plan your code so you have an idea of where you want to be when you finish up. Before you write any code at all, pull out a pencil and paper or open up a drawing software like draw.io . Make an outline and write down in general what your code will do. Then get more specific by specifying how it will do it. Repeat this process until you have a general idea of what you need to code the project and the logic it will follow. This can be a flow chart or a list of function names and descriptions of what they do. This can be a difficult habit to follow but rest assured that doing good planning up front will save you a large amount of time debugging later on. Use Good Coding Practice One strategy that should probably go without saying is to use good coding practice while you work. The following are some suggestions used by professionals to make Ensure you are following the Python Style Guide . Good style makes code easy to read and therefore easier to debug. Use descriptive variable names that make clear the purpose of a variable Follow the principles found in the Zen of Python Document your code as you go. It is easy to forget what your code is doing. If you leave notes for yourself you are less likely to get lost. Do a little at a time There are two general approaches to implementing a large project. The first it s a \"Top-Down\" approach where you get the simplest version of the program working and add features, fleshing out the auxiliary parts of the program as you go. The other is the \"bottom-up\" approach where you get one little part of the program to work at a time. Once enough parts are working independently, you link them together. Both have advantages depending on the application but for this first attempt at a larger program I will recommend doing the bottom-up approach. As you go, decide what each part of the program must do and get each part working before you link them together. Test-Driven development As you build your code up you will inevitably run into errors. One of the best ways to avoid difficult-to-debug logic errors is to implement test-driven development. The process of test-driven development is simple to understand. Before writing any code you write code that tests the function or you will write. The test should be written to get certain outputs of inputs to the function. You will want to write tests that test the normal cases and the edge cases of your function. Once the tests have been written and you have ensured that they work (a relatively simple coding task), write your code so it passes those tests. If you have written good tests then the code will act as you expect it to. Getting intermediate values Everything we have listed above is about how to prevent errors. Eventually you will have to go in and figure out how you messed up. When this happens getting intermediate values will help you see what your code is doing. Use the print function to print out values as you go. Start by ensuring that you are getting the input you think you are. Then check your loops are doing what you think they are by going through just one iteration (i.e. use a break statement to end the loop early). Finally, check your returns so you know you are getting back what you think you should be getting back. This is not an exhaustive list of strategies. But the simple act of checking intermediate values will help you a lot as you go along. Explain it to a rubber duck This is one of the weirdest and most effective strategies used by programmers. More detail about it can be found here . The idea is to explain your code out loud to a rubber duck (although you could explain it to another person too if they were willing to listen for that long). As you explain the code out loud you will find that often the solution to your problem will occur to you. This is a strange practice but has been shown to be a powerful debugging too to help you gain clarity about what is going wrong. \"If you cannot solve your problem, solve an easier problem first.\" - Dr. David Lignell Taken from here . This is a good tip for you if you find yourself at a dead end. Split up your problem into parts and tackle each one at a time. For example, split your code into shorter sub-functions and debug each of them.","title":"Debugging"},{"location":"25-Do-a-Project/#possible-projects","text":"There are many different things you may want to do with your newfound skills. In reality, this project will be the most valuable thing you do yet as it will introduce problems you have not yet faced and develop skills you have not yet even thought of. Ideally, you will make something that interests you and feeds your passions. Below I have provided some general ideas and perhaps a push in the right direction. However, you must flesh out the ideas here and make them your own. Please note that right now, everything you will do will interface with your user in the command line. This however does not mean that you cannot make something interesting or useful. With that said, here are some possible projects.","title":"Possible Projects"},{"location":"25-Do-a-Project/#design-a-game","text":"Video games back in earlier days of computing were all based in the command line. A popular one that was among the first video games was called \"Zork\". Search the Internet for information about Zork and make your own little version. A tiny version of a Zork-like might look like: def entrance_hall(): look = \"\"\" You find yourself locked inside a castle. You are in the entrance hall to the palace. To the SOUTH there is a locked door to the outside. To the NORTH there is a staircase. To the EAST and WEST there are large wooden doors standing ajar. \"\"\" print(look) do = input(\"What will you do? > \") if do == \"go north\": staircase() elif do == \"go south\": print(\"You're pretty bad at this game.\") elif do == 'go east' or do == \"go west\": east_west_rooms() else: print(\"You lose. Next time try doing something\", \"like 'go <direction>' to do something.\") def staircase(): look = \"\"\" There is a lot of treasure here! You take the treasure, get rich and live happily ever after! YOU WIN! \"\"\" print(look) def east_west_rooms(): look = \"\"\" There is a monster in this room. He eats you and you regret ever being born as you fall down his throat. GAME OVER \"\"\" print(look) entrance_hall() # this starts the game It is up to you to develop this idea. The following are some suggestions the intent of this exercise it that you make the best game you can with your current skill set. Try some of the following as you develop your game: Draw a map and allow your character to move through many rooms. (At least 10 rooms/encounters.) Make obstacles, enemies or puzzles for your character to overcome. Allow the user to do many things in each room and write code to allow the user to put in bad input without breaking the game. Figure out how to parse and interpret input so that GO WEST and Go WEst are both interpreted as go west. Use a main-loop structure to simplify how the game works. There are no real limits or minimum requirements for this. Like I said above what you get out of this is what you put into it.","title":"Design A Game"},{"location":"25-Do-a-Project/#make-a-database-manager","text":"Make a manager for a database. The database can consist of a text file or a .json file or a .csv file to store your data. (Note: There are both json and csv libraries built into Python for working with these types of files.) For example suppose you are writing software to manage an inventory and assets for a used car dealership. Make a dictionary of all the pertinent data for each car (i.e. make, model, year, mileage, price) for each car and keep a database of these. Make a fully featured program that lets the user keep track of all the pertinent data and allows you to add, delete and edit car data in the database. Ensure these are saved to a file of some type.","title":"Make a Database Manager"},{"location":"25-Do-a-Project/#code-a-calculator","text":"Write a program that allows the user to quickly enter mathematical statements and evaluates them. This would be similar to how a graphing calculator works. This should go without saying but, this should be more extensive than running python in the command line and using the built-in functionality. The user may not know what an import statement is or that you need to use x**y to get x to the power of y . Make the program as smart as possible and able to do as many things as possible. If you wish to use add graphing functionality, I suggest looking up the third-party matplotlib library.","title":"Code a Calculator"},{"location":"25-Do-a-Project/#appendix-a-quick-introduction-to-some-useful-concepts","text":"","title":"APPENDIX: A quick introduction to some useful concepts"},{"location":"25-Do-a-Project/#sysargv","text":"Included here are some useful concepts and ideas for your project. Write out the following file and run it: # add_numbers.py from sys import argv print(f\"The name of this file is: {argv[0]}\") # get the filename numbers = [float(i) for i in argv[1:]] # turn string arguments into numbers print(f\"The sum of the numbers given is {sum(numbers)}\") # sum numbers together Here is what should happen $ python add_numbers.py 1 0.2 3 5 4 3 The name of this file is: add_numbers.py The sum of the numbers given is 16.2 $ argv is short for argument variables and represents the space-separated arguments passed in with any call to Python. It takes the form of a list of strings with the first element being the name of the script that is being run. In our case the rest of the arguments are numbers to be summed together. If you want more detail on argv you can read about it here . This is a common way to have your user interact with a program by passing it arguments as you run it.","title":"sys.argv"},{"location":"25-Do-a-Project/#main-loops","text":"Write out the following and run it as well: # mainloop.py menu = ''' Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program ''' running = True while running: print(menu) command = input(\"--> \") if command == \"1\": print(\"a word\") elif command == \"2\": for i in range(10): print(i+1) print(\"I did a thing!\") elif command == \"3\": running = False else: print(\"I do not understand that command.\") Here is what should happen $ python mainloop.py Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 1 a word Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 2 1 2 3 4 5 6 7 8 9 10 I did a thing! Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 4 I do not understand that command. Enter one of the following. 1 - print a word 2 - do a thing 3 - quit the program --> 3 $ As you can see, this program has a main-loop which runs the program until the user elects to end the program. In fact, it is a staple of programming to have a main-loop-like structure. The basic idea of a main-loop is a program that acts as follows: Gets user input (e.g. a button press, keystroke etc.) Processes the user input and apply some internal logic to it Produces some output (e.g. a printed statement or a newly rendered image on screen) Returns to step one This basic structure should be a norm of programming for a user. Use this as your model for user input.","title":"Main-loops"},{"location":"25-Do-a-Project/#break-and-continue-statements","text":"You can skip a loop iteration or stop a loop entirely with the continue or break statements respectively. Write out the following code to practice it. # cont_break.py # this loop counts to 100 by 10's for i in range(1,101): if not i % 10 == 0: continue print(i, end=\" \") print(\"\") # this loop will prematurely end at 24 for j in range(100): print(j, end=\" \") if j > 23: break print(\"\") Here is what should happen $ python cont_break.py 10 20 30 40 50 60 70 80 90 100 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 $ Consider how the break and continue statements change the flow of the code. Use these statements to skip iterations of loops or get out of loops entirely. You may notice that these introductions have been brief. This is on purpose. My goal was to simply let you know that these features exist. It is up to you to research and utilize them. They are not required. Previous: 24-Reading Code | Table of Contents | Next: 26-Objects and Classes","title":"Break and Continue statements"},{"location":"26-Objects-and-Classes/","text":"Previous: 25-Do a Project | Table of Contents | Next: 27-Inheritance and Polymorphism 26 - Objects and Classes Now that you have finished your project you should feel more or less comfortable with the basics of Python. The next thing to learn about is a new paradigm of programming: Object oriented programming! There are two shorter exercises in this section as well as some new vocabulary. Ensure that you understand all the terms in bold as you go along as these concepts will come up later. What is object oriented programming? In Python, everything is an object. That means that every type of data is held inside a container of memory. Inside this container is everything the object needs to work. For an example, we will use some list objects in Python. Do the following exercise: # list_objects.py list_object = [] # this is more or less equivalent to list_object2 = list() print(\"Initial objects\", list_object, list_object2) # now that we have these objects built # or \"initialized\" we can call methods on them! list_object.append(23) list_object2.append(24) print(\"Added 1 element to each\", list_object, list_object2) list_object.append(36) list_object2.append(45) print(\"Added another element to each\", list_object, list_object2) # now we will remove both elements of each list_object.pop() list_object2.pop() print(\"Popped off one element\", list_object, list_object2) list_object.pop() list_object2.pop() print(\"Popped off the other\", list_object, list_object2) Here is what should happen $ python list_objects.py Initial objects [] [] Added 1 element to each [23] [24] Added another element to each [23, 36] [24, 45] Popped off one element [23] [24] Popped off the other [] [] $ From this short exercise you should be able to see the following: Objects must be called into existence by some function You may not see exactly where it happens but when you write x = [] you are effectively calling list() and setting it equal to x. You will not see the details of this but they are implemented in the Python code somewhere. The process of calling an object into existence is called instantiation and the function that makes it happen is called an object constructor. Another way to think about this relationship is that list_object1 and list_object2 are both instances of a list data type. Objects have and can be modified by methods You have seen before and in this short exercise that functions may be called with dot syntax (e.g. list_object.pop() ). I have mentioned before that these functions are called methods and \"belong\" to the object they are being called from. A method may do anything the programmer wishes but often are used to modify the object or, more specifically, the data or variables that \"belong\" to the object. The variables that \"belong\" to the object are called the object's attributes . Objects are handled by reference Since everything is an object in Python, this may not make much sense until you see the effects of this behavior. In Python when you write code like: x = 2 y = x y += 3 You would rightly expect that x = 2 and y = 5 . However should you do something similar with a list: x = [2] y = x y[0] += 3 You will find that y[0] = 5 and x[0] = 5 . This is because you just made two variables x and y that refer to the same object! This is how all objects behave. The variable names act only as a reference. Therefore when you modified one of the variables it changed the object that both variables pointed to. This idea of only replicating a reference to an object is called a shallow copy of an object. If you wish to have a distinct deep copy of an list object you may use the list.copy() method as follows: x = [2] y = x.copy() y[0] += 3 This will return y[0] = 5 and x[0] = 2 . This may not make a big difference right now, but understanding this upfront will aid your understanding of how objects behave. Classes Python has a way for the programmer to define their own objects with unique behavior. These are called classes. The next exercise will help you understand how they work. # learn_classes.py class Cat(): species = \"Felis catus\" def __init__(self, name, color, favorite_food): self.name = name self.color = color self.favorite_food = favorite_food def print_introduction(self): print(f'This is {self.name}. '\\ f'He is of the species \\'{self.species}\\'.') print(f'He is a/an {self.color} cat. '\\ f'He really likes {self.favorite_food}!') cat1 = Cat(\"Snowflake\", \"White\", \"Fish\") cat2 = Cat(\"Milo\", \"Orange\", \"Bacon\") for cat in [cat1, cat2]: cat.print_introduction() Here is what should happen $ python learn_classes.py This is Snowflake. He is of the species 'Felis catus'. He is a/an White cat. He really likes Fish! This is Milo. He is of the species 'Felis catus'. He is a/an Orange cat. He really likes Bacon! $ From this exercise you should see that with the class keyword we are defining a new data type or a \"class\" of objects. Therefore each object created from the \"class\" template is also called an instance of that class. As I said before, in Python, everything is an object. That means that somewhere in the Python source code there must be some Python class definition (or some equivalent definition) that defines the structure and behavior of all Python objects. Defining Behavior and Data Structures It may not be obvious right now but, this structure of programming allows you to scale your programs in a very powerful way. In a class, the programmer may define any behavior he/she wants for the class of objects once and may reuse that behavior for every instance of the class. The way that behavior is defined is via methods and attributes . Attributes and the self variable Any object that is contained by the class or object is considered an attribute of the class or object. This includes functions and the data members inside the class. Functions inside the class are called methods and members are generally any other objects contained in the class. These are generally referenced in code with the dot syntax (i.e. object_name.attribute_name ). However, you may have noticed that inside the class definition you see that they are referenced using the self variable. self is just a variable that could be named anything but is used by convention in Python. It is a reference to the instance of the object that is referring to the attribute. Therefore when you instantiated the cats named \"Snowflake\" and \"Milo\" when you called .print_introduction on both of them they produced their respective data types in the print statement. In the class definition, if one simply tried to print name instead of self.name , Python looks for a global variable called name and will throw an error if it cannot find one. Methods Methods are just functions defined in the class definition and operate solely within the context of the class or instances of the class. Methods are there to define how a class will behave. In fact, a class can be altered to act in all sorts of useful ways (see Advanced Mastery below). As a matter of good coding practice, methods should alter the class's members or return outputs of the class but should not alter other objects or classes not referred to by the class. Hone Your Skills Experiment with how objects are handled by reference. Try doing different things with lists for example. Can you predict what different actions will do to an object? Make your own classes and experiment with what you can do. How can this make your programs cleaner? Consider the project you just did in the previous lesson. How could object-oriented programming simplify and improve your code? Advanced Mastery Look up operator overloading in Python and see if you can write some classes that do it. You may want to implement something like how complex numbers should act or numbers with units. Previous: 25-Do a Project | Table of Contents | Next: 27-Inheritance and Polymorphism","title":"26. Objects and Classes"},{"location":"26-Objects-and-Classes/#26-objects-and-classes","text":"Now that you have finished your project you should feel more or less comfortable with the basics of Python. The next thing to learn about is a new paradigm of programming: Object oriented programming! There are two shorter exercises in this section as well as some new vocabulary. Ensure that you understand all the terms in bold as you go along as these concepts will come up later.","title":"26 - Objects and Classes"},{"location":"26-Objects-and-Classes/#what-is-object-oriented-programming","text":"In Python, everything is an object. That means that every type of data is held inside a container of memory. Inside this container is everything the object needs to work. For an example, we will use some list objects in Python. Do the following exercise: # list_objects.py list_object = [] # this is more or less equivalent to list_object2 = list() print(\"Initial objects\", list_object, list_object2) # now that we have these objects built # or \"initialized\" we can call methods on them! list_object.append(23) list_object2.append(24) print(\"Added 1 element to each\", list_object, list_object2) list_object.append(36) list_object2.append(45) print(\"Added another element to each\", list_object, list_object2) # now we will remove both elements of each list_object.pop() list_object2.pop() print(\"Popped off one element\", list_object, list_object2) list_object.pop() list_object2.pop() print(\"Popped off the other\", list_object, list_object2) Here is what should happen $ python list_objects.py Initial objects [] [] Added 1 element to each [23] [24] Added another element to each [23, 36] [24, 45] Popped off one element [23] [24] Popped off the other [] [] $ From this short exercise you should be able to see the following: Objects must be called into existence by some function You may not see exactly where it happens but when you write x = [] you are effectively calling list() and setting it equal to x. You will not see the details of this but they are implemented in the Python code somewhere. The process of calling an object into existence is called instantiation and the function that makes it happen is called an object constructor. Another way to think about this relationship is that list_object1 and list_object2 are both instances of a list data type. Objects have and can be modified by methods You have seen before and in this short exercise that functions may be called with dot syntax (e.g. list_object.pop() ). I have mentioned before that these functions are called methods and \"belong\" to the object they are being called from. A method may do anything the programmer wishes but often are used to modify the object or, more specifically, the data or variables that \"belong\" to the object. The variables that \"belong\" to the object are called the object's attributes .","title":"What is object oriented programming?"},{"location":"26-Objects-and-Classes/#objects-are-handled-by-reference","text":"Since everything is an object in Python, this may not make much sense until you see the effects of this behavior. In Python when you write code like: x = 2 y = x y += 3 You would rightly expect that x = 2 and y = 5 . However should you do something similar with a list: x = [2] y = x y[0] += 3 You will find that y[0] = 5 and x[0] = 5 . This is because you just made two variables x and y that refer to the same object! This is how all objects behave. The variable names act only as a reference. Therefore when you modified one of the variables it changed the object that both variables pointed to. This idea of only replicating a reference to an object is called a shallow copy of an object. If you wish to have a distinct deep copy of an list object you may use the list.copy() method as follows: x = [2] y = x.copy() y[0] += 3 This will return y[0] = 5 and x[0] = 2 . This may not make a big difference right now, but understanding this upfront will aid your understanding of how objects behave.","title":"Objects are handled by reference"},{"location":"26-Objects-and-Classes/#classes","text":"Python has a way for the programmer to define their own objects with unique behavior. These are called classes. The next exercise will help you understand how they work. # learn_classes.py class Cat(): species = \"Felis catus\" def __init__(self, name, color, favorite_food): self.name = name self.color = color self.favorite_food = favorite_food def print_introduction(self): print(f'This is {self.name}. '\\ f'He is of the species \\'{self.species}\\'.') print(f'He is a/an {self.color} cat. '\\ f'He really likes {self.favorite_food}!') cat1 = Cat(\"Snowflake\", \"White\", \"Fish\") cat2 = Cat(\"Milo\", \"Orange\", \"Bacon\") for cat in [cat1, cat2]: cat.print_introduction() Here is what should happen $ python learn_classes.py This is Snowflake. He is of the species 'Felis catus'. He is a/an White cat. He really likes Fish! This is Milo. He is of the species 'Felis catus'. He is a/an Orange cat. He really likes Bacon! $ From this exercise you should see that with the class keyword we are defining a new data type or a \"class\" of objects. Therefore each object created from the \"class\" template is also called an instance of that class. As I said before, in Python, everything is an object. That means that somewhere in the Python source code there must be some Python class definition (or some equivalent definition) that defines the structure and behavior of all Python objects.","title":"Classes"},{"location":"26-Objects-and-Classes/#defining-behavior-and-data-structures","text":"It may not be obvious right now but, this structure of programming allows you to scale your programs in a very powerful way. In a class, the programmer may define any behavior he/she wants for the class of objects once and may reuse that behavior for every instance of the class. The way that behavior is defined is via methods and attributes .","title":"Defining Behavior and Data Structures"},{"location":"26-Objects-and-Classes/#attributes-and-the-self-variable","text":"Any object that is contained by the class or object is considered an attribute of the class or object. This includes functions and the data members inside the class. Functions inside the class are called methods and members are generally any other objects contained in the class. These are generally referenced in code with the dot syntax (i.e. object_name.attribute_name ). However, you may have noticed that inside the class definition you see that they are referenced using the self variable. self is just a variable that could be named anything but is used by convention in Python. It is a reference to the instance of the object that is referring to the attribute. Therefore when you instantiated the cats named \"Snowflake\" and \"Milo\" when you called .print_introduction on both of them they produced their respective data types in the print statement. In the class definition, if one simply tried to print name instead of self.name , Python looks for a global variable called name and will throw an error if it cannot find one.","title":"Attributes and the self variable"},{"location":"26-Objects-and-Classes/#methods","text":"Methods are just functions defined in the class definition and operate solely within the context of the class or instances of the class. Methods are there to define how a class will behave. In fact, a class can be altered to act in all sorts of useful ways (see Advanced Mastery below). As a matter of good coding practice, methods should alter the class's members or return outputs of the class but should not alter other objects or classes not referred to by the class.","title":"Methods"},{"location":"26-Objects-and-Classes/#hone-your-skills","text":"Experiment with how objects are handled by reference. Try doing different things with lists for example. Can you predict what different actions will do to an object? Make your own classes and experiment with what you can do. How can this make your programs cleaner? Consider the project you just did in the previous lesson. How could object-oriented programming simplify and improve your code?","title":"Hone Your Skills"},{"location":"26-Objects-and-Classes/#advanced-mastery","text":"Look up operator overloading in Python and see if you can write some classes that do it. You may want to implement something like how complex numbers should act or numbers with units. Previous: 25-Do a Project | Table of Contents | Next: 27-Inheritance and Polymorphism","title":"Advanced Mastery"},{"location":"27-Inheritance-and-Polymorphism/","text":"Previous: 26-Objects and Classes | Table of Contents | Next: 28-Modules 27 - Inheritance and Polymorphism As we saw from the last lesson, object oriented programming allows us to scale our software in a convenient way. There is another powerful way object-oriented programming allows us to structure our programs. That is through a family-like structure called inheritance that gives rise to polymorphism. The following exercise will illustrate how one may use this programming to their advantage. # inheritance.py class Automobile(): ''' This is the base \"parent\" class and generally should not be instantiated. ''' number_of_doors = 2 def __init__(self, year, make, model): self.year = year self.make = make self.model = model def __repr__(self): return f\"\"\"Automobile Data: Year of manufacture : {self.year} Automobile make : {self.make} Automobile model : {self.model}\"\"\" class Truck(Automobile): ''' A Truck object is a type of Automobile. ''' def __init__(self, year, make, model, bed_type, bed_size, axel_weight): super().__init__(year, make, model) self.bed_type = bed_type self.bed_size = bed_size self.axel_weight = axel_weight class Sedan(Automobile): ''' A Sedan is not a Truck but is a type of Automobile. ''' number_of_doors = 4 def __init__(self, year, make, model, engine_type, engine_size): super().__init__(year, make, model) self.engine_type = engine_type self.engine_size = engine_size class Coupe(Automobile): ''' A Coupe is not a Sedan or a Truck but is a type of Automobile. ''' def __init__(self, year, make, model, engine_type, engine_size): super().__init__(year, make, model) self.engine_type = engine_type self.engine_size = engine_size class Corvette(Coupe): ''' A Corvette is a specific type of Coupe. ''' def __init__(self, year, edition, engine_size): super().__init__(year, \"Chevrolet\", \"Corvette\", \"V8\", engine_size) self.edition = edition def __repr__(self): return f\"\"\"This car is a {self.make} {self.model},\"\"\"\\ f\"\"\" {self.edition} Edition made in {self.year}. It has a {self.engine_size} cubic-inch {self.engine_type} engine. It is awesome!!!\"\"\" t = Truck(1990, \"Ford\", \"F-250\", \"Flat\", \"Long (8')\", '3/4 Ton') s = Sedan(2017, \"Hyundai\", \"Elantra\", 'Straight 4', 92) p = Coupe(2012, \"Toyota\", \"Camry\", \"V6\", 205) c = Corvette(1975, \"Sting Ray\", 350) for car in [t,s,p,c]: print(car, '\\n') Here is what should happen $ python inheritance.py Automobile Data: Year of manufacture : 1990 Automobile make : Ford Automobile model : F-250 Automobile Data: Year of manufacture : 2017 Automobile make : Hyundai Automobile model : Elantra Automobile Data: Year of manufacture : 2012 Automobile make : Toyota Automobile model : Camry This car is a Chevrolet Corvette, Sting Ray Edition made in 1975. It has a 350 cubic-inch V8 engine. It is awesome!!! $ Inheritance Classes have the following syntax to define them: # class # name # | # v class Name(Parent): # ^ ^ # | | # class parent # keyword class # name That is, the class with the name Name is a type of the previously-defined class called Parent . This means that class Name \"inherits\" all the attributes from the Parent class. We saw this in inheritance.py when we had a parent class, Automobile , pass its attributes to each of its children. For example, in the Truck class we see that a Truck instance was able to use the __repr__ method belonging to the Automobile class without it having to be explicitly coded in the Truck class. Another way of describing the relationship between Automobile and Truck is that a Truck class is a type of Automobile class. This is a very useful feature as it allows a programmer to avoid having to recode every method and attribute for a set of similar classes. This also allows a clean structuring of sub-classes or \"child\" classes to produce powerful data structures. Much of this will come to bear later on when we do more interesting things with object-oriented programming. Polymorphism Another feature of inheritance is the idea that a child class need not be exactly the same as its parent class. In fact, a the utility of this construct hinges on the idea that a child class can be a specialized instance of a parent class. This allows the creation of many child classes that specialize in particular things. The child class may take the attributes that the parent class has and build on them, adding its own attributes and methods to do what it needs to do. This concept is called \"polymorphism\" meaning \"having many forms\". After experimenting with this structure, it becomes apparent how this may be used to build large data structures that model complex systems. We saw this as well in the Truck class. The Automobile parent class had only 4 attributes namely, number_of_doors , year , make and model . The Truck class expanded on this data set by adding attributes that are specific to a Truck , namely bed_type , bed_size and axel_weight . Furthermore, each child class of Automobile brought something unique to the table by adding its own attributes or methods. In the case of the Corvette class, it inherited from the Coupe class, a sub-class of Automobile . This means it took all the attributes of both the Automobile class and the Coupe class and then added its own methods and attributes. Overriding and the super function You may have also noticed that sometimes things defined in a parent class are redefined in a child class. This is not an accident. It is common to have a generic implementation of each method in a parent class and then a specific implementation in the child classes tailored to their specific needs. When any method or attribute is redefined in a child class this is called \"overriding\" the method or attribute. This is something you can and absolutely should do when programming. It is one of the great strengths of object-oriented programming and allows the utility of polymorphism to be expressed to its fullest extent. We saw this above in every child implementation of the constructor method or __init__ method. Every child has an __init__ method distinct from each other and the parent class. That means the the original __init__ belonging to Automobile was overridden by each child. Other overriding examples are in the __repr__ function and the number_of_doors variable. In each case the overriding was done to make the class act in a unique way by defining specific behavior for a given method. One important drawback of overriding a parent method is that, for the child, the parent's version of the method is no longer available to use if needed. To deal with this and make classes more flexible, Python has the super function. This function returns a temporary instance of the parent of the class from which it was called. This instance can be then used to call a parent's implementation of any method. As we saw above we needed to ensure that year , make and model were defined in the class structure for each child but rather than writing 3 extra lines of code for each child, we simply pass in the needed variables and then use super().__init__(year, make, model) to get the parent class to do that for us. Furthermore, the Corvette class specified some variables that would always be true for itself when calling the parent Coupe class. For each of these features we have introduced some of the possible uses of each but you should understand that we have only scratched the surface of what object-oriented programming can do. In later lessons you will have the opportunity to use these principles in a more powerful and tangible way. The __repr__ method One thing you may still have questions about is the __repr__ method. The __repr__ name stands for \"representation\" and is intended to return a string representation of the object. One more powerful feature of object-oriented programming is the idea that a given method name will act in an expected way in any instance of an object. Remember that in Python, everything is an object. Therefore when we call print(obj) where obj is the object we wish to print, what is actually happens is that the print function looks at the object and calls its __repr__ method (i.e. it calls obj.__repr__() ) or some equivalent command. To make this work for any Python object, every object must have a default implementation of __repr__ . Python enforces this by making all objects inherit from a base class that implements basic functionality like having a default string representation of any object. Therefore, when you implement a __repr__ method you are overriding the Python base class's implementation of __repr__ and when you call print on some instance of the class. This will be inherited by any children of that class unless they override the definition too. There are more functions like __repr__ that allow you to customize your classes. You can learn more about them in Advanced Mastery below. Hone your Skills Copy the code from inheritance.py into a separate text file and use code comments to mark every example in the code of children using inherited traits with something like # inheritance used here . Mark up the code in a similar fashion for every example of polymorphism and every example of overriding. You may notice that each automobile class has more data to offer than just its year, make and model. Implement __repr__ for every class so all of their data members are shown when you print them. Add a method and data attribute that sets and adjusts the color of the car. Add this color to the __repr__ method for each class. Add other methods and attributes to all the children in inheritance.py that more fully describe each class. Why would you want certain attributes? Are there some you wouldn't want or some that are unnecessary? Make sure you can understand the code, then make a separate parent-child class structure using another concept with which you are familiar. For example, you could make a similar structure with genres of music or animals. Start with a parent class that defines attributes and methods that will be common to all the children. Then define child classes that inherit from that parent and have attributes of their own especially attributes that override the parent attributes. Advanced Mastery Learn more about customized methods in the Python Documentation on the subject. Why would you want to alter these types of functions? Implement operator overloading for some classes you make up yourself. These classes could represent complex numbers or numbers with units. Previous: 26-Objects and Classes | Table of Contents | Next: 28-Modules","title":"27. Inheritance and Polymorphism"},{"location":"27-Inheritance-and-Polymorphism/#27-inheritance-and-polymorphism","text":"As we saw from the last lesson, object oriented programming allows us to scale our software in a convenient way. There is another powerful way object-oriented programming allows us to structure our programs. That is through a family-like structure called inheritance that gives rise to polymorphism. The following exercise will illustrate how one may use this programming to their advantage. # inheritance.py class Automobile(): ''' This is the base \"parent\" class and generally should not be instantiated. ''' number_of_doors = 2 def __init__(self, year, make, model): self.year = year self.make = make self.model = model def __repr__(self): return f\"\"\"Automobile Data: Year of manufacture : {self.year} Automobile make : {self.make} Automobile model : {self.model}\"\"\" class Truck(Automobile): ''' A Truck object is a type of Automobile. ''' def __init__(self, year, make, model, bed_type, bed_size, axel_weight): super().__init__(year, make, model) self.bed_type = bed_type self.bed_size = bed_size self.axel_weight = axel_weight class Sedan(Automobile): ''' A Sedan is not a Truck but is a type of Automobile. ''' number_of_doors = 4 def __init__(self, year, make, model, engine_type, engine_size): super().__init__(year, make, model) self.engine_type = engine_type self.engine_size = engine_size class Coupe(Automobile): ''' A Coupe is not a Sedan or a Truck but is a type of Automobile. ''' def __init__(self, year, make, model, engine_type, engine_size): super().__init__(year, make, model) self.engine_type = engine_type self.engine_size = engine_size class Corvette(Coupe): ''' A Corvette is a specific type of Coupe. ''' def __init__(self, year, edition, engine_size): super().__init__(year, \"Chevrolet\", \"Corvette\", \"V8\", engine_size) self.edition = edition def __repr__(self): return f\"\"\"This car is a {self.make} {self.model},\"\"\"\\ f\"\"\" {self.edition} Edition made in {self.year}. It has a {self.engine_size} cubic-inch {self.engine_type} engine. It is awesome!!!\"\"\" t = Truck(1990, \"Ford\", \"F-250\", \"Flat\", \"Long (8')\", '3/4 Ton') s = Sedan(2017, \"Hyundai\", \"Elantra\", 'Straight 4', 92) p = Coupe(2012, \"Toyota\", \"Camry\", \"V6\", 205) c = Corvette(1975, \"Sting Ray\", 350) for car in [t,s,p,c]: print(car, '\\n') Here is what should happen $ python inheritance.py Automobile Data: Year of manufacture : 1990 Automobile make : Ford Automobile model : F-250 Automobile Data: Year of manufacture : 2017 Automobile make : Hyundai Automobile model : Elantra Automobile Data: Year of manufacture : 2012 Automobile make : Toyota Automobile model : Camry This car is a Chevrolet Corvette, Sting Ray Edition made in 1975. It has a 350 cubic-inch V8 engine. It is awesome!!! $","title":"27 - Inheritance and Polymorphism"},{"location":"27-Inheritance-and-Polymorphism/#inheritance","text":"Classes have the following syntax to define them: # class # name # | # v class Name(Parent): # ^ ^ # | | # class parent # keyword class # name That is, the class with the name Name is a type of the previously-defined class called Parent . This means that class Name \"inherits\" all the attributes from the Parent class. We saw this in inheritance.py when we had a parent class, Automobile , pass its attributes to each of its children. For example, in the Truck class we see that a Truck instance was able to use the __repr__ method belonging to the Automobile class without it having to be explicitly coded in the Truck class. Another way of describing the relationship between Automobile and Truck is that a Truck class is a type of Automobile class. This is a very useful feature as it allows a programmer to avoid having to recode every method and attribute for a set of similar classes. This also allows a clean structuring of sub-classes or \"child\" classes to produce powerful data structures. Much of this will come to bear later on when we do more interesting things with object-oriented programming.","title":"Inheritance"},{"location":"27-Inheritance-and-Polymorphism/#polymorphism","text":"Another feature of inheritance is the idea that a child class need not be exactly the same as its parent class. In fact, a the utility of this construct hinges on the idea that a child class can be a specialized instance of a parent class. This allows the creation of many child classes that specialize in particular things. The child class may take the attributes that the parent class has and build on them, adding its own attributes and methods to do what it needs to do. This concept is called \"polymorphism\" meaning \"having many forms\". After experimenting with this structure, it becomes apparent how this may be used to build large data structures that model complex systems. We saw this as well in the Truck class. The Automobile parent class had only 4 attributes namely, number_of_doors , year , make and model . The Truck class expanded on this data set by adding attributes that are specific to a Truck , namely bed_type , bed_size and axel_weight . Furthermore, each child class of Automobile brought something unique to the table by adding its own attributes or methods. In the case of the Corvette class, it inherited from the Coupe class, a sub-class of Automobile . This means it took all the attributes of both the Automobile class and the Coupe class and then added its own methods and attributes.","title":"Polymorphism"},{"location":"27-Inheritance-and-Polymorphism/#overriding-and-the-super-function","text":"You may have also noticed that sometimes things defined in a parent class are redefined in a child class. This is not an accident. It is common to have a generic implementation of each method in a parent class and then a specific implementation in the child classes tailored to their specific needs. When any method or attribute is redefined in a child class this is called \"overriding\" the method or attribute. This is something you can and absolutely should do when programming. It is one of the great strengths of object-oriented programming and allows the utility of polymorphism to be expressed to its fullest extent. We saw this above in every child implementation of the constructor method or __init__ method. Every child has an __init__ method distinct from each other and the parent class. That means the the original __init__ belonging to Automobile was overridden by each child. Other overriding examples are in the __repr__ function and the number_of_doors variable. In each case the overriding was done to make the class act in a unique way by defining specific behavior for a given method. One important drawback of overriding a parent method is that, for the child, the parent's version of the method is no longer available to use if needed. To deal with this and make classes more flexible, Python has the super function. This function returns a temporary instance of the parent of the class from which it was called. This instance can be then used to call a parent's implementation of any method. As we saw above we needed to ensure that year , make and model were defined in the class structure for each child but rather than writing 3 extra lines of code for each child, we simply pass in the needed variables and then use super().__init__(year, make, model) to get the parent class to do that for us. Furthermore, the Corvette class specified some variables that would always be true for itself when calling the parent Coupe class. For each of these features we have introduced some of the possible uses of each but you should understand that we have only scratched the surface of what object-oriented programming can do. In later lessons you will have the opportunity to use these principles in a more powerful and tangible way.","title":"Overriding and the super function"},{"location":"27-Inheritance-and-Polymorphism/#the-__repr__-method","text":"One thing you may still have questions about is the __repr__ method. The __repr__ name stands for \"representation\" and is intended to return a string representation of the object. One more powerful feature of object-oriented programming is the idea that a given method name will act in an expected way in any instance of an object. Remember that in Python, everything is an object. Therefore when we call print(obj) where obj is the object we wish to print, what is actually happens is that the print function looks at the object and calls its __repr__ method (i.e. it calls obj.__repr__() ) or some equivalent command. To make this work for any Python object, every object must have a default implementation of __repr__ . Python enforces this by making all objects inherit from a base class that implements basic functionality like having a default string representation of any object. Therefore, when you implement a __repr__ method you are overriding the Python base class's implementation of __repr__ and when you call print on some instance of the class. This will be inherited by any children of that class unless they override the definition too. There are more functions like __repr__ that allow you to customize your classes. You can learn more about them in Advanced Mastery below.","title":"The __repr__ method"},{"location":"27-Inheritance-and-Polymorphism/#hone-your-skills","text":"Copy the code from inheritance.py into a separate text file and use code comments to mark every example in the code of children using inherited traits with something like # inheritance used here . Mark up the code in a similar fashion for every example of polymorphism and every example of overriding. You may notice that each automobile class has more data to offer than just its year, make and model. Implement __repr__ for every class so all of their data members are shown when you print them. Add a method and data attribute that sets and adjusts the color of the car. Add this color to the __repr__ method for each class. Add other methods and attributes to all the children in inheritance.py that more fully describe each class. Why would you want certain attributes? Are there some you wouldn't want or some that are unnecessary? Make sure you can understand the code, then make a separate parent-child class structure using another concept with which you are familiar. For example, you could make a similar structure with genres of music or animals. Start with a parent class that defines attributes and methods that will be common to all the children. Then define child classes that inherit from that parent and have attributes of their own especially attributes that override the parent attributes.","title":"Hone your Skills"},{"location":"27-Inheritance-and-Polymorphism/#advanced-mastery","text":"Learn more about customized methods in the Python Documentation on the subject. Why would you want to alter these types of functions? Implement operator overloading for some classes you make up yourself. These classes could represent complex numbers or numbers with units. Previous: 26-Objects and Classes | Table of Contents | Next: 28-Modules","title":"Advanced Mastery"},{"location":"28-Modules/","text":"Previous: 27-Inheritance and Polymorphism | Table of Contents | Next: 29-Comments and Code Documentation 28 - Modules In this section we will explore how to connect python files together and make them work together. Also included in this section is an opportunity to get used to using classes and do more object oriented programming. Each file in Python is sometimes called a module. A module is simply a python file you can import and use its contents. You used some of the standard modules or libraries in the section about imports . In this section we will begin learning how to build our own packages or libraries by connecting two modules together. In a later section, we will take what we accomplish here and make a complete (albeit simple) package that could be made into a distributable software. These will also be used in the next sections so make sure you save these files for later . The Email Database Manager The following are two files that you will copy-paste into separate text files. The names of these files are indicated at the top. These files serve as a sort of skeleton of a project you must complete using all you have learned so far. Take your time and get this project working as well as you possibly can. As always, the more you put into this the more you will get out of the experience. More specific information about the files is given below. Many of the same principles from your first project apply here. I have left multi-line comments under each label to guide your implimentation of this project. Do not delete these as these are the subject of the next section. The Database Manager File # database_manager.py import json class DatabaseManager(): \"\"\" Manages all aspects of the database including how and where data are stored. This database is contact list consisting of a collection of names with corresponding phone numbers and email addresses. This may be implimented as a dictionary (which sorts the list automatically) or a list. The exact structure of the database is up to you but it might be a good idea to find out how others have done first. \"\"\" def __init__(self, filename): \"\"\" Loads the database based on the passed in filename. The database should come from a .json file and be stored in the class as a dictionary. This should call self.load_database() as its last step. \"\"\" pass def load_database(self): \"\"\" Loads the database from a .json file using Python's built in json package. If the filename does not exist it should make an empty database and call self.save_database() to write the new database. \"\"\" pass def save_database(self): \"\"\" Saves the database to a .json file using Python's built-in json package. This should be called any time the database is altered. \"\"\" pass def add_item(self, entry): \"\"\" Adds and organizes an 'entry' consisting of an name, phone number and email to the database it then saves the database. \"\"\" pass def remove_item(self, name): \"\"\" Removes an entry with ID 'name' from the database and then saves the database. \"\"\" pass def get_database(self): \"\"\" Returns a reference or a copy of the database in some form to be used elsewhere. \"\"\" pass def __repr__(self): \"\"\" Returns a string representation of the database. With this, the database may be printed or otherwise represented. \"\"\" pass def test_dbman(): \"\"\" A test function to ensure the database class performed as expected \"\"\" pass if __name__ == \"__main__\": test_dbman() This file implements a class that will manage the database. The user interface class must have a reference to an instance of this class in the form of a class variable inside the UserInterface object (i.e. self.dbman ) so that it can access all its methods. For this exercise you may use any format you wish. However, for this simple example I recommend using JavaScript Object Notation or JSON. I recommend this because Python has an excellent JSON library for storing data and JSON conveniently translates to common python objects such as dictionaries, lists, strings etc. You can learn how to use both the load and save features by looking at the corresponding Python documentation here and reading about json.load() and json.dump() . The documentation strings under each label explain what should be implemented. Feel free to use your own creativity and what you have learned to implement this class. Finally, do not hesitate to add any methods or make changes to names as you see fit. The test_dbman() function is there to allow you to test the class by itself before using it in the user interface. The User Interface File # user_interface.py from database_manager import DatabaseManager class UserInterface(): \"\"\" Allows the user to access and use the features of the database without having to know how to program. The user should be allowed to do a few basic things: - view the database - add an entry to the database - remove an entry from the database - export the database to a human-readable text file - exit the program Provided the user can do these thing easily and reliably, the program is successful. \"\"\" def __init__(self, dbman): \"\"\" sets up the UI and sets the self.dbman = dbman so the database may be accessed. \"\"\" pass def mainloop(self): \"\"\" Runs the mainloop of the program. This should include the following steps: 1 - display information 2 - prompt the user for input 3 - process the input to get new information to display This also must exit the program when the user commands. \"\"\" pass def display(self): \"\"\" gets and displays information as given by the self.execute function. \"\"\" pass def get_input(self): \"\"\" Accepts user input by calling the built-in input() function \"\"\" pass def execute(self): \"\"\" Uses the information form user input to execute the program including accessing self.dbman to use database commands. \"\"\" pass def export(self, filename): \"\"\" Writes the database to a file pointed to by the variable 'filename'. May use a string representation of the database. \"\"\" pass def run_ui_test(): \"\"\" This runs a UI test if we run it as the main Python program \"\"\" db_manager = DatabaseManager('data.json') ui = UserInterface(db_manager) ui.mainloop() if __name__ == '__main__': run_ui_test() This file uses the DatabaseManager class to access the JSON files in a simple way. The user interface should contain a main-loop structure explained in the Do a Project section. Try to make the user interface as intuitive and easy to use as possible. Again, the documentation strings under each label explain what should be implemented. Also as above, use your own creativity and what you have learned and add any methods or changes as you see fit. The run_ui_test() function is there to initiate the program. Hone Your Skills Once you have finished the main objective of this exercise you should have a working database program. Modify the program in the following ways: Add user interface features to always display the database on screen or only display it when it makes sense. Add error messages and make helpful info be printed out when the user gives bad input. Add home and work versions of emails and phone numbers so that multiple emails and phone numbers may be assigned to one person. Add options to the UI to allow different formats to be exported. Make a new type of database and implement it with your existing user interface. For example, this could be a car database using code from the previous sections. Advanced Mastery Look up the curses module in Python and use it to make a more advanced and easy-to-use user interface in the CLI. Look up python tkinter and begin learning how to build a non-CLI user interface. Use what you have learned to make a better UI for the database. Previous: 27-Inheritance and Polymorphism | Table of Contents | Next: 29-Comments and Code Documentation","title":"28. Modules"},{"location":"28-Modules/#28-modules","text":"In this section we will explore how to connect python files together and make them work together. Also included in this section is an opportunity to get used to using classes and do more object oriented programming. Each file in Python is sometimes called a module. A module is simply a python file you can import and use its contents. You used some of the standard modules or libraries in the section about imports . In this section we will begin learning how to build our own packages or libraries by connecting two modules together. In a later section, we will take what we accomplish here and make a complete (albeit simple) package that could be made into a distributable software. These will also be used in the next sections so make sure you save these files for later .","title":"28 - Modules"},{"location":"28-Modules/#the-email-database-manager","text":"The following are two files that you will copy-paste into separate text files. The names of these files are indicated at the top. These files serve as a sort of skeleton of a project you must complete using all you have learned so far. Take your time and get this project working as well as you possibly can. As always, the more you put into this the more you will get out of the experience. More specific information about the files is given below. Many of the same principles from your first project apply here. I have left multi-line comments under each label to guide your implimentation of this project. Do not delete these as these are the subject of the next section.","title":"The Email Database Manager"},{"location":"28-Modules/#the-database-manager-file","text":"# database_manager.py import json class DatabaseManager(): \"\"\" Manages all aspects of the database including how and where data are stored. This database is contact list consisting of a collection of names with corresponding phone numbers and email addresses. This may be implimented as a dictionary (which sorts the list automatically) or a list. The exact structure of the database is up to you but it might be a good idea to find out how others have done first. \"\"\" def __init__(self, filename): \"\"\" Loads the database based on the passed in filename. The database should come from a .json file and be stored in the class as a dictionary. This should call self.load_database() as its last step. \"\"\" pass def load_database(self): \"\"\" Loads the database from a .json file using Python's built in json package. If the filename does not exist it should make an empty database and call self.save_database() to write the new database. \"\"\" pass def save_database(self): \"\"\" Saves the database to a .json file using Python's built-in json package. This should be called any time the database is altered. \"\"\" pass def add_item(self, entry): \"\"\" Adds and organizes an 'entry' consisting of an name, phone number and email to the database it then saves the database. \"\"\" pass def remove_item(self, name): \"\"\" Removes an entry with ID 'name' from the database and then saves the database. \"\"\" pass def get_database(self): \"\"\" Returns a reference or a copy of the database in some form to be used elsewhere. \"\"\" pass def __repr__(self): \"\"\" Returns a string representation of the database. With this, the database may be printed or otherwise represented. \"\"\" pass def test_dbman(): \"\"\" A test function to ensure the database class performed as expected \"\"\" pass if __name__ == \"__main__\": test_dbman() This file implements a class that will manage the database. The user interface class must have a reference to an instance of this class in the form of a class variable inside the UserInterface object (i.e. self.dbman ) so that it can access all its methods. For this exercise you may use any format you wish. However, for this simple example I recommend using JavaScript Object Notation or JSON. I recommend this because Python has an excellent JSON library for storing data and JSON conveniently translates to common python objects such as dictionaries, lists, strings etc. You can learn how to use both the load and save features by looking at the corresponding Python documentation here and reading about json.load() and json.dump() . The documentation strings under each label explain what should be implemented. Feel free to use your own creativity and what you have learned to implement this class. Finally, do not hesitate to add any methods or make changes to names as you see fit. The test_dbman() function is there to allow you to test the class by itself before using it in the user interface.","title":"The Database Manager File"},{"location":"28-Modules/#the-user-interface-file","text":"# user_interface.py from database_manager import DatabaseManager class UserInterface(): \"\"\" Allows the user to access and use the features of the database without having to know how to program. The user should be allowed to do a few basic things: - view the database - add an entry to the database - remove an entry from the database - export the database to a human-readable text file - exit the program Provided the user can do these thing easily and reliably, the program is successful. \"\"\" def __init__(self, dbman): \"\"\" sets up the UI and sets the self.dbman = dbman so the database may be accessed. \"\"\" pass def mainloop(self): \"\"\" Runs the mainloop of the program. This should include the following steps: 1 - display information 2 - prompt the user for input 3 - process the input to get new information to display This also must exit the program when the user commands. \"\"\" pass def display(self): \"\"\" gets and displays information as given by the self.execute function. \"\"\" pass def get_input(self): \"\"\" Accepts user input by calling the built-in input() function \"\"\" pass def execute(self): \"\"\" Uses the information form user input to execute the program including accessing self.dbman to use database commands. \"\"\" pass def export(self, filename): \"\"\" Writes the database to a file pointed to by the variable 'filename'. May use a string representation of the database. \"\"\" pass def run_ui_test(): \"\"\" This runs a UI test if we run it as the main Python program \"\"\" db_manager = DatabaseManager('data.json') ui = UserInterface(db_manager) ui.mainloop() if __name__ == '__main__': run_ui_test() This file uses the DatabaseManager class to access the JSON files in a simple way. The user interface should contain a main-loop structure explained in the Do a Project section. Try to make the user interface as intuitive and easy to use as possible. Again, the documentation strings under each label explain what should be implemented. Also as above, use your own creativity and what you have learned and add any methods or changes as you see fit. The run_ui_test() function is there to initiate the program.","title":"The User Interface File"},{"location":"28-Modules/#hone-your-skills","text":"Once you have finished the main objective of this exercise you should have a working database program. Modify the program in the following ways: Add user interface features to always display the database on screen or only display it when it makes sense. Add error messages and make helpful info be printed out when the user gives bad input. Add home and work versions of emails and phone numbers so that multiple emails and phone numbers may be assigned to one person. Add options to the UI to allow different formats to be exported. Make a new type of database and implement it with your existing user interface. For example, this could be a car database using code from the previous sections.","title":"Hone Your Skills"},{"location":"28-Modules/#advanced-mastery","text":"Look up the curses module in Python and use it to make a more advanced and easy-to-use user interface in the CLI. Look up python tkinter and begin learning how to build a non-CLI user interface. Use what you have learned to make a better UI for the database. Previous: 27-Inheritance and Polymorphism | Table of Contents | Next: 29-Comments and Code Documentation","title":"Advanced Mastery"},{"location":"29-Comments-and-Code-Documentation/","text":"Previous: 28-Modules | Table of Contents | Next: 30-Packages and Project Structure 29 - Comments and Code Documentation As you were implementing the project in the previous section, you were guided by the multi-line comment strings under each class or function label. I put those there to guide you but also to introduce you to a style of commenting and documentation used among professionals. Docstrings The \"string literals\" or multi-line comments under each labels are recognized by python as documentation strings or \"docstrings\" for short. You will see these commonly in professional code and you may also use them at the beginning of a module to give general information about the module. The following example will set out some use cases. Don't bother to write this out just read and understand it. \"\"\" file: docstrings.py author: Mark Redd github: flythereddflagg about: This module has some dummy functions and a dummy class to demonstrate proper usage of docstrings. \"\"\" class Dummy(): \"\"\" Impliments Nothing of value. Is for demonstration purposes only. Notice the indentation level of this doc string. Notice how it is different from the methods in this class. Attributes: a (integer): a meaningless value b (string): a meaningless word \"\"\" def __init__(self, a, b): \"\"\"Constructor for the Dummy class\"\"\" self.a = a self.b = b def jump(how_high, when): \"\"\" This is a function or method belonging to the Dummy class that will take longer than one sentence to explain. Where this is the case be as detailed as necessary. Some functions are so complex that they require many lines of code to explain the intent and use of a function. For such cases it is useful to list the parameters and what they mean. e.g. : Parameters: - how_high (integer): the height you want the dummy to jump in feet - when (datetime instance): a Python datetime instance specifying the moment when you want the dummy to jump Likewise it is useful to tell what the function returns e.g. : Returns: - success (boolean): True if the jump completed successfully False otherwise. \"\"\" return True def slide(left_right): \"\"\" It is not always necessary that you be extremely detailed. For instance you could get the needed information across with something like: Returns True for a successful slide \"left\" or \"right\". On an unsuccessful slide, returns False and increments a. \"\"\" success = True if left_right == \"left\" and success: return True elif left_right == \"right\" and success: return True else: self.a += 1 return False def give_me_an_a(): \"\"\"Gives you an A. Notice the indentation of the doc string\"\"\" return 'A' if __name__ == \"__main__\": #help(__name__) #help(give_me_an_a) #help(Dummy) #help(Dummy.__init__) #help(Dummy.jump) #help(Dummy.slide) The help function You will see at the bottom of the docstrings.py script there are several lines commented out. Copy-paste this script into a separate text file and uncomment those lines one by one. What do they do? You will see the docstrings show up as you do. This can also be done in the interactive prompt. Try the following commands and notice the output. $ python Python 3.x.x ... Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import docstrings >>> help(docstrings) >>> help(docstrings.Dummy) >>> For more information just type help() into the prompt. This will turn on the interactive help. This functionality is used by Python programmers everywhere to help the user learn the API. If you need information on a class or function you have imported this will give you what you need. I have introduced this feature now instead of earlier for a few reasons. Before using the feature, understanding classes and docstrings will help you understand how to use this feature and implement it in your own projects. Therefore from here on out, I expect you to include clear documentation for all your modules, classes and functions. Hone your skills Go back over some of the scripts and projects you have done so far in the course. Add docstrings to them so they can be used with the help function. Look up how you can generate web documentation from your docstrings using tools like pydoc , sphinx or Read the Docs . See if you can find some other tools to help you do this. (There are many more.) Advanced Mastery Make a full website from the documentation you pull from your docstrings. You do not have to serve it but make it useable for a website format. Previous: 28-Modules | Table of Contents | Next: 30-Packages and Project Structure","title":"29. Comments and Code Documentation"},{"location":"29-Comments-and-Code-Documentation/#29-comments-and-code-documentation","text":"As you were implementing the project in the previous section, you were guided by the multi-line comment strings under each class or function label. I put those there to guide you but also to introduce you to a style of commenting and documentation used among professionals.","title":"29 - Comments and Code Documentation"},{"location":"29-Comments-and-Code-Documentation/#docstrings","text":"The \"string literals\" or multi-line comments under each labels are recognized by python as documentation strings or \"docstrings\" for short. You will see these commonly in professional code and you may also use them at the beginning of a module to give general information about the module. The following example will set out some use cases. Don't bother to write this out just read and understand it. \"\"\" file: docstrings.py author: Mark Redd github: flythereddflagg about: This module has some dummy functions and a dummy class to demonstrate proper usage of docstrings. \"\"\" class Dummy(): \"\"\" Impliments Nothing of value. Is for demonstration purposes only. Notice the indentation level of this doc string. Notice how it is different from the methods in this class. Attributes: a (integer): a meaningless value b (string): a meaningless word \"\"\" def __init__(self, a, b): \"\"\"Constructor for the Dummy class\"\"\" self.a = a self.b = b def jump(how_high, when): \"\"\" This is a function or method belonging to the Dummy class that will take longer than one sentence to explain. Where this is the case be as detailed as necessary. Some functions are so complex that they require many lines of code to explain the intent and use of a function. For such cases it is useful to list the parameters and what they mean. e.g. : Parameters: - how_high (integer): the height you want the dummy to jump in feet - when (datetime instance): a Python datetime instance specifying the moment when you want the dummy to jump Likewise it is useful to tell what the function returns e.g. : Returns: - success (boolean): True if the jump completed successfully False otherwise. \"\"\" return True def slide(left_right): \"\"\" It is not always necessary that you be extremely detailed. For instance you could get the needed information across with something like: Returns True for a successful slide \"left\" or \"right\". On an unsuccessful slide, returns False and increments a. \"\"\" success = True if left_right == \"left\" and success: return True elif left_right == \"right\" and success: return True else: self.a += 1 return False def give_me_an_a(): \"\"\"Gives you an A. Notice the indentation of the doc string\"\"\" return 'A' if __name__ == \"__main__\": #help(__name__) #help(give_me_an_a) #help(Dummy) #help(Dummy.__init__) #help(Dummy.jump) #help(Dummy.slide)","title":"Docstrings"},{"location":"29-Comments-and-Code-Documentation/#the-help-function","text":"You will see at the bottom of the docstrings.py script there are several lines commented out. Copy-paste this script into a separate text file and uncomment those lines one by one. What do they do? You will see the docstrings show up as you do. This can also be done in the interactive prompt. Try the following commands and notice the output. $ python Python 3.x.x ... Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> import docstrings >>> help(docstrings) >>> help(docstrings.Dummy) >>> For more information just type help() into the prompt. This will turn on the interactive help. This functionality is used by Python programmers everywhere to help the user learn the API. If you need information on a class or function you have imported this will give you what you need. I have introduced this feature now instead of earlier for a few reasons. Before using the feature, understanding classes and docstrings will help you understand how to use this feature and implement it in your own projects. Therefore from here on out, I expect you to include clear documentation for all your modules, classes and functions.","title":"The help function"},{"location":"29-Comments-and-Code-Documentation/#hone-your-skills","text":"Go back over some of the scripts and projects you have done so far in the course. Add docstrings to them so they can be used with the help function. Look up how you can generate web documentation from your docstrings using tools like pydoc , sphinx or Read the Docs . See if you can find some other tools to help you do this. (There are many more.)","title":"Hone your skills"},{"location":"29-Comments-and-Code-Documentation/#advanced-mastery","text":"Make a full website from the documentation you pull from your docstrings. You do not have to serve it but make it useable for a website format. Previous: 28-Modules | Table of Contents | Next: 30-Packages and Project Structure","title":"Advanced Mastery"},{"location":"30-Packages-and-Project-Structure/","text":"Previous: 29-Comments and Code Documentation | Table of Contents | 30 - Packages and Project structure This section is low on code but introduces some powerful features of Python that will enable you to scale your code to do large, maintainable projects. Within the next few lessons you will be doing another project. This time your project will be object-oriented. You will use a class structure to do something interesting. You should start thinking about what you want to do right now. So far you have done a project in which you probably made a structure of global variables (i.e. variables that were defined outside of any function or class) and used functions to act on those variables. This project will focus on using the object-oriented features of Python to make the best and most robust piece of software that you can. However, before we can write these larger codes we must learn how to structure projects to organize our code. The following exercise will walk you through building a basic structure for your project. Building a Basic Project Structure Go to your CLI, navigate to a place where you will build your project build the following project structure using the CLI commands you have learned. Enter the following commands: For Linux and Mac: $ mkdir emails $ mkdir ./emails/emails ./emails/bin ./emails/docs ./emails/tests $ touch ./emails/README.md $ touch ./emails/emails/__init__.py ./emails/tests/__init__.py $ touch ./emails/bin/placeholder.txt ./emails/docs/placeholder.txt $ ls -R ./emails/ For windows: > mkdir emails > mkdir ./emails/emails > mkdir ./emails/bin > mkdir ./emails/docs > mkdir ./emails/tests > New-Item ./emails/README.md > New-Item ./emails/emails/__init__.py > New-Item ./emails/tests/__init__.py > New-Item ./emails/bin/placeholder.txt > New-Item ./emails/docs/placeholder.txt > ls -R ./emails/ When you are done your structure should look like this: ./emails/: emails bin docs tests README.md ./emails/bin: placeholder.txt ./emails/docs: placeholder.txt ./emails/emails: __init__.py ./emails/tests: __init__.py The emails package You have just created project called emails that contains two packages called emails and tests . Both of these packages contain an __init__.py file. This file tells python to treat the folder that contains it as its own module. Therefore, any code in ./emails/emails/__init__.py may be imported from emails as: from emails import a_thing where a_thing is any class, function or variable defined inside of the __init__.py script. Other Python scripts may be placed in the folder as well (regardless of the presence of an __init__.py script) and classes functions or variables may be imported as: from emails.module import a_thing where module corresponds to module.py inside the folder. The emails folder is where we want to put all of our Python source code for the project. The tests package is where we can write automated tests for our emails package. We will work mainly with these two folders for this section. The other two folders are bin and docs and contain binary or executable files we wish to include with our code and documentation about our code respectively. The structure we have just made is not the only or \"correct\" way to structure a project but it is a convenient way to start a project. For our purposes it is a good idea not to have an empty folder so we have put a placeholder.txt file in each empty folder. Make a project Now that we have our project 'skeleton' in place, copy your working code from the modules section into the emails folder. Because you will run this in the context of the emails package make sure you change the following imports to reflect this. Change: from database_manager import DatabaseManager to: from emails.database_manager import DatabaseManager This will ensure that you are importing from the right environment. If you are using your modules in a project structure you will need to make sure they are referenced correctly or your project will break. Test your project by opening a python prompt in your project's root directory and executing the following commands: $ pwd .../path/to/project/emails/ $ python Python 3.x.x ... Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> from emails.user_interface import run_ui_test >>> run_ui_test() Your project should run as it always has. If the above test worked, congradulations! You have yourself a working project! You can add code to the emails folder or documentation to the docs folder as you see fit. But for our purposes, the real utiltiy of the project structure is the abliity you have to automatically test your project with a little tool called nose . This will be covered in the next section. Hone Your Skills if you haven't already, now would be a good time to turn the documentation in your docstrings into a human readable manual. If you are unsure where to start, try using pydoc and invoke it by using python -m pydoc . (Enter python --help to get an idea of how this works). Begin building your own project! Have an idea you want to see? Start by building a similar project structure as above but replace every instance of emails with the name of your own project. Begin fleshing out what you want to see from this project. Previous: 29-Comments and Code Documentation | Table of Contents |","title":"30. Packages and Project Structure"},{"location":"30-Packages-and-Project-Structure/#30-packages-and-project-structure","text":"This section is low on code but introduces some powerful features of Python that will enable you to scale your code to do large, maintainable projects. Within the next few lessons you will be doing another project. This time your project will be object-oriented. You will use a class structure to do something interesting. You should start thinking about what you want to do right now. So far you have done a project in which you probably made a structure of global variables (i.e. variables that were defined outside of any function or class) and used functions to act on those variables. This project will focus on using the object-oriented features of Python to make the best and most robust piece of software that you can. However, before we can write these larger codes we must learn how to structure projects to organize our code. The following exercise will walk you through building a basic structure for your project.","title":"30 - Packages and Project structure"},{"location":"30-Packages-and-Project-Structure/#building-a-basic-project-structure","text":"Go to your CLI, navigate to a place where you will build your project build the following project structure using the CLI commands you have learned. Enter the following commands: For Linux and Mac: $ mkdir emails $ mkdir ./emails/emails ./emails/bin ./emails/docs ./emails/tests $ touch ./emails/README.md $ touch ./emails/emails/__init__.py ./emails/tests/__init__.py $ touch ./emails/bin/placeholder.txt ./emails/docs/placeholder.txt $ ls -R ./emails/ For windows: > mkdir emails > mkdir ./emails/emails > mkdir ./emails/bin > mkdir ./emails/docs > mkdir ./emails/tests > New-Item ./emails/README.md > New-Item ./emails/emails/__init__.py > New-Item ./emails/tests/__init__.py > New-Item ./emails/bin/placeholder.txt > New-Item ./emails/docs/placeholder.txt > ls -R ./emails/ When you are done your structure should look like this: ./emails/: emails bin docs tests README.md ./emails/bin: placeholder.txt ./emails/docs: placeholder.txt ./emails/emails: __init__.py ./emails/tests: __init__.py","title":"Building a Basic Project Structure"},{"location":"30-Packages-and-Project-Structure/#the-emails-package","text":"You have just created project called emails that contains two packages called emails and tests . Both of these packages contain an __init__.py file. This file tells python to treat the folder that contains it as its own module. Therefore, any code in ./emails/emails/__init__.py may be imported from emails as: from emails import a_thing where a_thing is any class, function or variable defined inside of the __init__.py script. Other Python scripts may be placed in the folder as well (regardless of the presence of an __init__.py script) and classes functions or variables may be imported as: from emails.module import a_thing where module corresponds to module.py inside the folder. The emails folder is where we want to put all of our Python source code for the project. The tests package is where we can write automated tests for our emails package. We will work mainly with these two folders for this section. The other two folders are bin and docs and contain binary or executable files we wish to include with our code and documentation about our code respectively. The structure we have just made is not the only or \"correct\" way to structure a project but it is a convenient way to start a project. For our purposes it is a good idea not to have an empty folder so we have put a placeholder.txt file in each empty folder.","title":"The emails package"},{"location":"30-Packages-and-Project-Structure/#make-a-project","text":"Now that we have our project 'skeleton' in place, copy your working code from the modules section into the emails folder. Because you will run this in the context of the emails package make sure you change the following imports to reflect this. Change: from database_manager import DatabaseManager to: from emails.database_manager import DatabaseManager This will ensure that you are importing from the right environment. If you are using your modules in a project structure you will need to make sure they are referenced correctly or your project will break. Test your project by opening a python prompt in your project's root directory and executing the following commands: $ pwd .../path/to/project/emails/ $ python Python 3.x.x ... Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. >>> from emails.user_interface import run_ui_test >>> run_ui_test() Your project should run as it always has. If the above test worked, congradulations! You have yourself a working project! You can add code to the emails folder or documentation to the docs folder as you see fit. But for our purposes, the real utiltiy of the project structure is the abliity you have to automatically test your project with a little tool called nose . This will be covered in the next section.","title":"Make a project"},{"location":"30-Packages-and-Project-Structure/#hone-your-skills","text":"if you haven't already, now would be a good time to turn the documentation in your docstrings into a human readable manual. If you are unsure where to start, try using pydoc and invoke it by using python -m pydoc . (Enter python --help to get an idea of how this works). Begin building your own project! Have an idea you want to see? Start by building a similar project structure as above but replace every instance of emails with the name of your own project. Begin fleshing out what you want to see from this project. Previous: 29-Comments and Code Documentation | Table of Contents |","title":"Hone Your Skills"},{"location":"31-Automated-Testing/","text":"31 - Automated Testing asdasdf Test-Driven Development sdalkfj About nose sdfg Install nose asdf Make your tests afds Run nose sdfdsa","title":"31 - Automated Testing"},{"location":"31-Automated-Testing/#31-automated-testing","text":"asdasdf","title":"31 - Automated Testing"},{"location":"31-Automated-Testing/#test-driven-development","text":"sdalkfj","title":"Test-Driven Development"},{"location":"31-Automated-Testing/#about-nose","text":"sdfg","title":"About nose"},{"location":"31-Automated-Testing/#install-nose","text":"asdf","title":"Install nose"},{"location":"31-Automated-Testing/#make-your-tests","text":"afds","title":"Make your tests"},{"location":"31-Automated-Testing/#run-nose","text":"sdfdsa","title":"Run nose"}]}